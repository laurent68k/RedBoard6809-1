0001                         ;
0002                         ;	Color Basic
0003                         ;	
0004                         ;	Updated for running on RedBoard 6809
0005                         ;	----------------------------------------------------------------------------------------------------                               
0006                                                        
0007 d000                    UART      EQU  $D000           
0008 d001                    RECEV     EQU  UART+1          
0009 d001                    TRANS     EQU  UART+1          
0010 d000                    USTAT     EQU  UART            
0011 d000                    UCTRL     EQU  UART            
0012                                                        
0013 0008                    BS        EQU  8              BACKSPACE 
0014 000d                    CR        EQU  $D             ENTER KEY 
0015 001b                    ESC       EQU  $1B            ESCAPE CODE 
0016 0020                    SPACE     EQU  $20            SPACE (BLANK) 
0017 003a                    STKBUF    EQU  58             STACK BUFFER ROOM 
0018 00fa                    LBUFMX    EQU  250            MAX NUMBER OF CHARS IN A BASIC LINE 
0019 00fa                    MAXLIN    EQU  $FA            MAXIMUM MS BYTE OF LINE NUMBER 
0020                                                        
0021                         * PSEUDO PSEUDO OPS                      
0022 0021                    SKP1      EQU  $21            OP CODE OF BRN — SKIP ONE BYTE 
0023 008c                    SKP2      EQU  $8C            OP CODE OF CMPX # - SKIP TWO BYTES 
0024 0086                    SKP1LD    EQU  $86            OP CODE OF LDA # - SKIP THE NEXT BYTE 
0025                         *         AND LOAD THE VALUE OF THAT BYTE INTO ACCA — THIS                 
0026                         *         IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE                 
0027                                                        
0028                         * REGISTER ADDRESSES                      
0029                                                        
0030 0000                              ORG  0               
0031 0000                    ENDFLG    RMB  1              STOP/END FLAG: POSITIVE=STOP, NEG=END 
0032 0001                    CHARAC    RMB  1              TERMINATOR FLAG 1 
0033 0002                    ENDCHR    RMB  1              TERMINATOR FLAG 2 
0034 0003                    TMPLOC    RMB  1              SCRATCH VARIABLE 
0035 0004                    IFCTR     RMB  1              IF COUNTER - HOW MANY IF STATEMENTS IN A LINE 
0036 0005                    DIMFLG    RMB  1              *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING 
0037 0006                    VALTYP    RMB  1              *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING 
0038 0007                    GARBFL    RMB  1              *TV STRING SPACE HOUSEKEEPING FLAG 
0039 0008                    ARYDIS    RMB  1              DISABLE ARRAY SEARCH: 00=ALLOW SEARCH 
0040 0009                    INPFLG    RMB  1              *TV INPUT FLAG: READ=0, INPUT<>0 
0041 000a                    RELFLG    RMB  1              *TV RELATIONAL OPERATOR FLAG 
0042 000b                    TEMPPT    RMB  2              *PV TEMPORARY STRING STACK POINTER 
0043 000d                    LASTPT    RMB  2              *PV ADDR OF LAST USED STRING STACK ADDRESS 
0044 000f                    TEMPTR    RMB  2              TEMPORARY POINTER 
0045 0011                    TMPTR1    RMB  2              TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH) 
0046                                                        
0047 0013                    FPA2      RMB  4              FLOATING POINT ACCUMULATOR #2 MANTISSA 
0048 0017                    BOTSTK    RMB  2              BOTTOM OF STACK AT LAST CHECK 
0049 0019                    TXTTAB    RMB  2              *PV BEGINNING OF BASIC PROGRAM 
0050 001b                    VARTAB    RMB  2              *PV START OF VARIABLES 
0051 001d                    ARYTAB    RMB  2              *PV START OF ARRAYS 
0052 001f                    ARYEND    RMB  2              *PV END OF ARRAYS (+1) 
0053 0021                    FRETOP    RMB  2              *PV START OF STRING STORAGE (TOP OF FREE RAM) 
0054 0023                    STRTAB    RMB  2              *PV START OF STRING VARIABLES 
0055 0025                    FRESPC    RMB  2              UTILITY STRING POINTER 
0056 0027                    MEMSIZ    RMB  2              *PV TOP OF STRING SPACE 
0057 0029                    OLDTXT    RMB  2              SAVED LINE NUMBER DURING A "STOP" 
0058 002b                    BINVAL    RMB  2              BINARY VALUE OF A CONVERTED LINE NUMBER 
0059 002d                    OLDPTR    RMB  2              SAVED INPUT PTR DURING A "STOP" 
0060 002f                    TINPTR    RMB  2              TEMPORARY INPUT POINTER STORAGE 
0061 0031                    DATTXT    RMB  2              *PV 'DATA' STATEMENT LINE NUMBER POINTER 
0062 0033                    DATPTR    RMB  2              *PV 'DATA' STATEMENT ADDRESS POINTER 
0063 0035                    DATTMP    RMB  2              DATA POINTER FOR 'INPUT' & 'READ' 
0064 0037                    VARNAM    RMB  2              *TV TEMP STORAGE FOR A VARIABLE NAME 
0065 0039                    VARPTR    RMB  2              *TV POINTER TO A VARIABLE DESCRIPTOR 
0066 003b                    VARDES    RMB  2              TEMP POINTER TO A VARIABLE DESCRIPTOR 
0067 003d                    RELPTR    RMB  2              POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE 
0068 003f                    TRELFL    RMB  1              TEMPORARY RELATIONAL OPERATOR FLAG BYTE 
0069                                                        
0070                                                        
0071                                                        
0072                                                        
0073 0040                    V40       RMB  1               
0074 0041                    V41       RMB  1               
0075 0042                    V42       RMB  1               
0076 0043                    V43       RMB  1               
0077 0044                    V44       RMB  1               
0078                                                        
0079 0045                    V45       RMB  1               
0080 0046                    V46       RMB  1               
0081 0047                    V47       RMB  1               
0082 0048                    V48       RMB  2               
0083                                                        
0084 004a                    V4A       RMB  1               
0085 004b                    V4B       RMB  2               
0086 004d                    V4D       RMB  2               
0087                                                        
0088 004f                    FP0EXP    RMB  1              *PV FLOATING POINT ACCUMULATOR #0 EXPONENT 
0089 0050                    FPA0      RMB  4              *PV FLOATING POINT ACCUMULATOR #0 MANTISSA 
0090 0054                    FP0SGN    RMB  1              *PV FLOATING POINT ACCUMULATOR #0 SIGN 
0091 0055                    COEFCT    RMB  1              POLYNOMIAL COEFFICIENT COUNTER 
0092 0056                    STRDES    RMB  5              TEMPORARY STRING DESCRIPTOR 
0093 005b                    FPCARY    RMB  1              FLOATING POINT CARRY BYTE 
0094                                                        
0095 005c                    FP1EXP    RMB  1              *PV FLOATING POINT ACCUMULATOR #1 EXPONENT 
0096 005d                    FPA1      RMB  4              *PV FLOATING POINT ACCUMULATOR #1 MANTISSA 
0097 0061                    FP1SGN    RMB  1              *PV FLOATING POINT ACCUMULATOR #1 SIGN 
0098                                                        
0099 0062                    RESSGN    RMB  1              SIGN OF RESULT OF FLOATING POINT OPERATION 
0100 0063                    FPSBYT    RMB  1              FLOATING POINT SUB BYTE (FIFTH BYTE) 
0101 0064                    COEFPT    RMB  2              POLYNOMIAL COEFFICIENT POINTER 
0102 0066                    LSTTXT    RMB  2              CURRENT LINE POINTER DURING LIST 
0103 0068                    CURLIN    RMB  2              *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT 
0104 006a                    DEVCFW    RMB  1              *TV TAB FIELD WIDTH 
0105 006b                    DEVLCF    RMB  1              *TV TAB ZONE 
0106 006c                    DEVPOS    RMB  1              *TV PRINT POSITION 
0107 006d                    DEVWID    RMB  1              *TV PRINT WIDTH 
0108                         *         -1=CASSETTE, 0=SCREEN, 1-15=DISK                 
0109 006e                    RSTFLG    RMB  1              *PV WARM START FLAG: $55=WARM, OTHER=COLD 
0110 006f                    RSTVEC    RMB  2              *PV WARM START VECTOR - JUMP ADDRESS FOR WARM START 
0111 0071                    TOPRAM    RMB  2              *PV TOP OF RAM 
0112 0073                    IKEYIM    RMB  1              *TV INKEY$ RAM IMAGE 
0113 0074                    ZERO      RMB  2              *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO 
0114                                                        
0115                                                        
0116                         *              INIT           DESCRIPTION 
0117                         *                             VALUE 
0118 0076                    LPTCFW    RMB  1              16 
0119 0077                    LPTLCF    RMB  1              112 
0120 0078                    LPTWID    RMB  1              132 
0121 0079                    LPTPOS    RMB  1              0 
0122 007a                    EXECJP    RMB  2              LB4AA 
0123                                                        
0124                                                        
0125                                                        
0126                                                        
0127                         ;	LFD update: Code moved in ROM
0128                         ;zGETNCH    INC  <CHARAD+1      *PV INCREMENT LS BYTE OF INPUT POINTER 
0129                                   ;BNE  zGETCCH         *PV BRANCH IF NOT ZERO (NO CARRY) 
0130                                   ;INC  <CHARAD        *PV INCREMENT MS BYTE OF INPUT POINTER 
0131                         ;zGETCCH    FCB  $B6            *PV OP CODE OF LDA EXTENDED 
0132 007c                    CHARAD    RMB  2              *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT 
0133                         *         *    CHARACTER WHICH THE BASIC INTERPRETER IS  
0134                         *         *    PROCESSING      
0135                          ;         JMP  BROMHK         JUMP BACK INTO THE BASIC RUM 
0136                                                        
0137 007e                    VAB       RMB  1              = LOW ORDER FOUR BYTES OF THE PRODUCT 
0138 007f                    VAC       RMB  1              = OF A FLOATING POINT MULTIPLICATION 
0139 0080                    VAD       RMB  1              = THESE BYTES ARE USE AS RANDOM DATA 
0140 0081                    VAE       RMB  1              = BY THE RND STATEMENT 
0141                                                        
0142 0082                    TRCFLG    RMB  1              *PV TRACE FLAG 0=OFF ELSE=ON 
0143 0083                    USRADR    RMB  2              *PV ADDRESS OF THE START OF USR VECTORS 
0144                                                        
0145                                                        
0146 0085                    VCF       RMB  2               
0147 0087                    VD1       RMB  2               
0148 0089                    VD3       RMB  2               
0149 008b                    VD5       RMB  2               
0150 008d                    VD7       RMB  1               
0151 008e                    VD8       RMB  1               
0152 008f                    VD9       RMB  1               
0153 0090                    VDA       RMB  1               
0154                                                        
0155                                                        
0156                         *                             BASIC 
0157                                                        
0158 0091                    SW3VEC    RMB  3              $XXXX 
0159 0094                    SW2VEC    RMB  3              $XXXX 
0160 0097                    SWIVEC    RMB  3              $XXXX 
0161 009a                    NMIVEC    RMB  3              $XXXX 
0162 009d                    IRQVEC    RMB  3              $A9B3 
0163 00a0                    FRQVEC    RMB  3              $A0F6 
0164                                                        
0165                                                        
0166 00a3                    USRJMP    RMB  3              JUMP ADDRESS FOR BASIC'S USR FUNCTION 
0167                                                        
0168                                                        
0169 00a6                    RVSEED    RMB  1              * FLOATING POINT RANDOM NUMBER SEED EXPONENT 
0170 00a7                              RMB  4              * MANTISSA: INITIALLY SET TO $804FC75259 
0171                         * INITIALLY SET TO ERROR FOR BASIC, $8489 FOR EX BASIC                      
0172                                                        
0173                         * COMMAND INTERPRETATION VECTOR TABLE                      
0174                                                        
0175                                                        
0176                                                        
0177                                                        
0178                                                        
0179                                                        
0180                                                        
0181                                                        
0182                                                        
0183                         * ANY ADDITIONAL TABLES WILL HAVE TO BE                      
0184                                                        
0185                                                        
0186                         *         BYTE DESCRIPTION                 
0187                         *         0    NUMBER OF RESERVED WORDS  
0188                         *         1,2  LOOKUP TABLE OF RESERVED WORDS  
0189                         *         3,4  JUMP TABLE FOR COMMANDS (FIRST TABLE)  
0190                         *              VECTOR TO EXPANSION COMMAND HANDLERS (ALL BUT FIRST TABLE)  
0191                         *         5    NUMBER OF SECONDARY FUNCTIONS  
0192                         *         6,7  LOOKUP TABLE OF SECONDARY FUNCTIONS (FIRST TABLE)  
0193                         *              VECTOR TO EXPANSION SECONDARY COMMAND HANDLERS (ALL BUT  
0194                         *              FIRST TABLE)    
0195                         *         8,9  JUMP TABLE FOR SECONDARY FUNCTIONS  
0196                         *         10   0 BYTE - END OF TABLE FLAG (LAST TABLE ONLY)  
0197                                                        
0198 00ab                    COMVEC    RMB  10             BASIC'S TABLE 
0199 00b5                              RMB  10             EX BASIC'S TABLE 
0200 00bf                              RMB  10             DISC BASIC'S TABLE (UNUSED BY EX BASIC) 
0201                                                        
0202                                                        
0203 00c9                    USR0      RMB  2              USR 0 VECTOR 
0204 00cb                              RMB  2              USR 1 
0205 00cd                              RMB  2              USR 2 
0206 00cf                              RMB  2              USR 3 
0207 00d1                              RMB  2              USR 4 
0208 00d3                              RMB  2              USR 5 
0209 00d5                              RMB  2              USR 6 
0210 00d7                              RMB  2              USR 7 
0211 00d9                              RMB  2              USR 8 
0212 00db                              RMB  2              USR 9 
0213                                                        
0214                                                        
0215                                                        
0216                                                        
0217                                                        
0218                                                        
0219                                                        
0220                                                        
0221                                                        
0222                                                        
0223                                                        
0224                                                        
0225                                                        
0226                                                        
0227                                                        
0228                         *                             2.0 
0229 00dd                    RVEC2     RMB  3              $A35F 
0230 00e0                    RVEC9     RMB  3              $B918 
0231 00e3                    RVEC10    RMB  3              $B061 
0232 00e6                    RVEC11    RMB  3              $A549 
0233 00e9                    RVEC12    RMB  3              $A390 
0234 00ec                    RVEC15    RMB  3              $B223 
0235 00ef                    RVEC16    RMB  3              $AC46 
0236 00f2                    RVEC17    RMB  3              $AC49 
0237 00f5                    RVEC18    RMB  3              $AE75 
0238 00f8                    RVEC19    RMB  3              $BD22 
0239 00fb                    RVEC20    RMB  3              $AD9E 
0240 00fe                    RVEC22    RMB  3              $A910 
0241                         *                             $8162 
0242                         *                             $8AFA 
0243                         *                             $975C 
0244 0101                    RVEC23    RMB  3              $B821 
0245 0104                    RVEC24    RMB  3              $B7C2 
0246                                                        
0247 0107                    STRSTK    RMB  8*5            STRING DESCRIPTOR STACK 
0248 012f                    LINHDR    RMB  2              LINE INPUT BUFFER HEADER 
0249 0131                    LINBUF    RMB  LBUFMX+1       BASIC LINE INPUT BUFFER 
0250 022c                    STRBUF    RMB  41             STRING BUFFER 
0251                                                        
0252 0255                    PROGST    RMB  1              START OF PROGRAM SPACE 
0253                         
0254                         *         INTERRUPT VECTORS                 
0255                                   ;ORG  $FFF2           
0256                         ;SWI3      RMB  2               
0257                         ;SWI2      RMB  2               
0258                         ;FIRQ      RMB  2               
0259                         ;IRQ       RMB  2               
0260                         ;SWI       RMB  2               
0261                         ;NMI       RMB  2               
0262                         ;RESETV    RMB  2               
0263                                                                                      
0264                         ;	----------------------------------------------------------------------------------------------------
0265 8000                              ORG  $8000
0266 8000 41 54              		  fcc "AT"				;	automatic cartidge		
0267 8002 20 00                        bra  RESVEC
0268                         ;	----------------------------------------------------------------------------------------------------
0269                         		  
0270                         ;POLCAT    FDB  KEYIN          GET A KEYSTROKE 
0271                         ;CHROUT    FDB  PUTCHR         OUTPUT A CHARACTER 
0272                         *                              
0273                         RESVEC                         
0274 8004 10 ce 02 2c        LA00E     LDS  #LINBUF+LBUFMX+1 SET STACK TO TOP OF LINE INPUT BUFFER 
0275 8008 86 15              INITACIA  LDA  #21            DIV16 CLOCK -> 7372800 / 4 / 16 = 115200 
0276 800a b7 d0 00                     STA  UCTRL           
0277 800d 96 6e                        LDA  RSTFLG         GET WARM START FLAG 
0278 800f 81 55                        CMPA #$55           IS IT A WARM START? 
0279 8011 26 0a                        BNE  BACDST         NO - D0 A COLD START 
0280 8013 9e 6f                        LDX  RSTVEC         WARM START VECTOR 
0281 8015 a6 84                        LDA  ,X             GET FIRST BYTE OF WARM START ADDR 
0282 8017 81 12                        CMPA #$12           IS IT NOP? 
0283 8019 26 02                        BNE  BACDST         NO - DO A COLD START 
0284 801b 6e 84                        JMP  ,X             YES, G0 THERE 
0285                                                        
0286                         * COLD START ENTRY                      
0287                                                        
0288 801d 8e 02 56           BACDST    LDX  #PROGST+1      POINT X TO CLEAR 1ST 1K OF RAM 
0289 8020 6f 83              LA077     CLR  ,--X           MOVE POINTER DOWN TWO-CLEAR BYTE 
0290 8022 30 01                        LEAX 1,X            ADVANCE POINTER ONE 
0291 8024 26 fa                        BNE  LA077          KEEP GOING IF NOT AT BOTTOM OF PAGE 0 
0292 8026 8e 02 55                     LDX  #PROGST        SET TO START OF PROGRAM SPACE 
0293 8029 6f 80                        CLR  ,X+            CLEAR 1ST BYTE OF BASIC PROGRAM 
0294 802b 9f 19                        STX  TXTTAB         BEGINNING OF BASIC PROGRAM 
0295                         		  
0296                         ;	LFD: Size of RAM available
0297 802d a6 89 00 80        LA084:    LDA  128,X            LOOK FOR END
0298 8031 43                           COMA                * COMPLEMENT IT AND PUT IT BACK
0299 8032 a7 89 00 80                  STA  128,X            * INTO SYSTEM MEMORY
0300 8036 a1 89 00 80                  CMPA 128,X            IS IT RAM?
0301 803a 26 08                        BNE  LA093          BRANCH IF NOT (ROM, BAD RAM OR NO RAM)
0302 803c 30 88 7f                     LEAX 127,X            MOVE POINTER UP ONE
0303 803f 63 88 7f                     COM  127,X            RE-COMPLEMENT TO RESTORE BYTE
0304 8042 20 e9                        BRA  LA084          KEEP LOOKING FOR END OF RAM 
0305                         		  
0306                         LA093:    ;ldy	#$7FFF			;	LFD: top of RedBoard RAM
0307 8044 9f 71              		  STX  TOPRAM         SAVE ABSOLUTE TOP OF RAM 
0308 8046 9f 27                        STX  MEMSIZ         SAVE TOP OF STRING SPACE 
0309 8048 9f 23                        STX  STRTAB         SAVE START OF STRING VARIABLES 
0310 804a 30 89 ff 38                  LEAX -200,X         CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES 
0311 804e 9f 21                        STX  FRETOP         SAVE START OF STRING SPACE 
0312 8050 1f 14                        TFR  X,S            PUT STACK THERE 
0313 8052 8e 80 a4                     LDX  #LA10D         POINT X TO ROM SOURCE DATA 
0314 8055 ce 00 76                     LDU  #LPTCFW        POINT U TO RAM DESTINATION (WAS #CMPMID) 
0315 8058 c6 12                        LDB  #18            MOVE 18 BYTES (WAS 28) 
0316 805a bd 81 c9                     JSR  LA59A          MOVE 18 BYTES FROM ROM TO RAM 
0317 805d ce 00 9d                     LDU  #IRQVEC        POINT U TO NEXT RAM DESTINATION 
0318 8060 c6 18                        LDB  #24            MOVE 24 MORE BYTES (WAS 30) 
0319 8062 bd 81 c9                     JSR  LA59A          MOVE 24 BYTES FROM ROM TO RAM 
0320 8065 ae 14                        LDX  -12,X          POINT X TO SYNTAX ERROR ADDRESS 
0321 8067 af 43              LA0B6     STX  3,U            * SET EXBAS COMMAND INTERPRETATION 
0322 8069 af 48                        STX  8,U            * HANDLERS TO SYNTAX ERROR 
0323 806b 8e 00 dd                     LDX  #RVEC2         POINT X TO START OF RAM VECTORS 
0324 806e cc 39 2a                     LDD  #$392A         SET UP TO SAVE 42 (WAS 75) RTS’ 
0325 8071 a7 80              LA0C0     STA  ,X+            FILL THE RAM VECTORS WITH RTS’ 
0326 8073 5a                           DECB                * DECREMENT COUNTER AND 
0327 8074 26 fb                        BNE  LA0C0          * BRANCH IF NOT DONE 
0328 8076 b7 01 2e                     STA  LINHDR-1       PUT RTS IN LINHDR-1 
0329 8079 bd 84 ff                     JSR  LAD19          G0 DO A ‘NEW’ 
0330                         * EXTENDED BASIC INITIALISATION                      
0331 807c 8e 00 c9                      LDX    #USR0          =INITIALIZE ADDRESS OF START OF   
0332 807f 9f 83                         STX    USRADR         =USR JUMP TABLE   
0333                         * INITIALIZE THE USR CALLS TO ‘FC ERROR’                        
0334 8081 ce 8c 37                      LDU    #LB44A         ADDRESS OF ‘FC ERROR’ ROUTINE   
0335 8084 c6 0a                         LDB    #10            10 USR CALLS IN EX BASIC   
0336 8086 ef 81              L8031      STU    ,X++           STORE ‘FC’ ERROR AT USR ADDRESSES   
0337 8088 5a                            DECB                   FINISHED ALL 10?   
0338 8089 26 fb                         BNE    L8031          NO   
0339                                                         
0340 808b 8e 80 cd                     LDX  #LA147-1       POINT X TO COLOR BASIC COPYRIGHT MESSAGE 
0341 808e bd 91 5f                     JSR  LB99C          PRINT ‘COLOR BASIC’ 
0342 8091 8e 80 9c                     LDX  #BAWMST        WARM START ADDRESS 
0343 8094 9f 6f                        STX  RSTVEC         SAVE IT 
0344 8096 86 55                        LDA  #$55           WARM START FLAG 
0345 8098 97 6e                        STA  RSTFLG         SAVE IT 
0346 809a 20 04                        BRA  LA0F3          GO TO BASIC’S MAIN LOOP 
0347 809c 12                 BAWMST    NOP  NOP REQ’D FOR WARM START  
0348 809d bd 85 19                     JSR  LAD33          DO PART OF A NEW 
0349 80a0 7e 84 64           LA0F3     JMP  LAC73          GO TO MAIN LOOP OF BASIC 
0350                         *                              
0351                         * FIRQ SERVICE ROUTINE                      
0352                         BFRQSV                         
0353 80a3 3b                           RTI                  
0354                         *                              
0355                         * THESE BYTES ARE MOVED TO ADDRESSES $8F - $AA THE DIRECT PAGE                      
0356 80a4 10                 LA10D     FCB  16             TAB FIELD WIDTH 
0357 80a5 70                           FCB  112            LAST TAB ZONE 
0358 80a6 84                           FCB  132            PRINTER WIDTH 
0359 80a7 00                           FCB  0              LINE PRINTER POSITION 
0360 80a8 8c 37                        FDB  LB44A          ARGUMENT OF EXEC COMMAND - SET TO ‘FC’ ERROR 
0361                         * LINE INPUT ROUTINE                      
0362 80aa 0c 7d                        INC  CHARAD+1        
0363 80ac 26 02                        BNE  LA123           
0364 80ae 0c 7c                        INC  CHARAD          
0365 80b0 b6 00 00           LA123     LDA  >0000           
0366 80b3 7e 81 db                     JMP  BROMHK          
0367                         *                              
0368                                                        
0369 80b6 7e 81 da                     JMP  BIRQSV         IRQ SERVICE 
0370 80b9 7e 80 a3                     JMP  BFRQSV         FIRQ SERVICE 
0371 80bc 7e 8c 37                     JMP  LB44A          USR ADDRESS FOR 8K BASIC (INITIALIZED TO ‘FC’ ERROR) 
0372 80bf 80                           FCB  $80            *RANDOM SEED 
0373 80c0 4f c7                        FDB  $4FC7          *RANDON SEED OF MANTISSA 
0374 80c2 52 59                        FDB  $5259          *.811635157 
0375                         * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE                      
0376 80c4 37                 LA13D     FCB  55             55 BASIC COMMANDS 
0377 80c5 82 3a              LA13E     FDB  LAA66          POINTS TO RESERVED WORDS 
0378 80c7 83 5e              LA140     FDB  LAB67          POINTS TO JUMP TABLE FOR COMMANDS 
0379 80c9 1d                 LA142     FCB  29             29 BASIC SECONDARY COMMANDS 
0380 80ca 82 f1              LA143     FDB  LAB1A          POINTS TO SECONDARY FUNCTION RESERVED WORDS 
0381 80cc 81 eb              LA145     FDB  LAA29          POINTS TO SECONDARY FUNCTION JUMP TABLE 
0382                         * COPYRIGHT MESSAGES                      
0383 80ce 36 38 30 39 20 45  LA147     FCC  "6809 EXTENDED BASIC"  
     58 54 45 4e 44 45
     44 20 42 41 53 49
     43
0384 80e1 0d                           FCB  CR              
0385 80e2 28 43 29 20 31 39            FCC  "(C) 1982 BY MICROSOFT"  
     38 32 20 42 59 20
     4d 49 43 52 4f 53
     4f 46 54
0386 80f7 0d 0d              LA156     FCB  CR,CR           
0387                                                        
0388                                                        
0389 80f9 00                 LA165     FCB  $00             
0390                                                        
0391 80fa 8d 03              LA171     BSR  LA176          GET A CHARACTER FROM CONSOLE IN 
0392 80fc 84 7f                        ANDA #$7F           MASK OFF BIT 7 
0393 80fe 39                           RTS                  
0394                                                        
0395                         * CONSOLE IN                      
0396                         LA176                          
0397                                                        
0398 80ff 8d 03              LA1B5     BSR  KEYIN          GO CHECK KEYBOARD 
0399 8101 27 fc                        BEQ  LA1B5          LOOP IF NO KEY DOWN 
0400 8103 39                 LA1BF     RTS                  
0401                         *                              
0402                         * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY                      
0403                         * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.                      
0404                         *                              
0405                         LA1C1                          
0406                         KEYIN                          
0407 8104 b6 d0 00           RDACIA    LDA  USTAT           
0408 8107 85 01                        BITA #1              
0409 8109 27 06                        BEQ  NOCHAR          
0410 810b b6 d0 01                     LDA  RECEV           
0411 810e 84 7f                        ANDA #$7F            
0412 8110 39                           RTS                  
0413 8111 4f                 NOCHAR    CLRA                 
0414 8112 39                           RTS                  
0415                                                        
0416                                                        
0417                         * CONSOLE OUT                      
0418 8113 8d 24              PUTCHR    BSR  WAITACIA        
0419 8115 34 02                        PSHS A               
0420 8117 81 0d                        CMPA #CR            IS IT CARRIAGE RETURN? 
0421 8119 27 0b                        BEQ  NEWLINE        YES 
0422 811b b7 d0 01                     STA  TRANS           
0423 811e 0c 79                        INC  LPTPOS         INCREMENT CHARACTER COUNTER 
0424 8120 96 79                        LDA  LPTPOS         CHECK FOR END OF LINE PRINTER LINE 
0425 8122 91 78                        CMPA LPTWID         AT END OF LINE PRINTER LINE? 
0426 8124 25 10                        BLO  PUTEND         NO 
0427 8126 0f 79              NEWLINE   CLR  LPTPOS         RESET CHARACTER COUNTER 
0428 8128 8d 0f                        BSR  WAITACIA        
0429 812a 86 0d                        LDA  #13             
0430 812c b7 d0 01                     STA  TRANS           
0431 812f 8d 08                        BSR  WAITACIA        
0432 8131 86 0a                        LDA  #10            DO LINEFEED AFTER CR 
0433 8133 b7 d0 01                     STA  TRANS           
0434 8136 35 02              PUTEND    PULS A               
0435 8138 39                           RTS                  
0436                                                        
0437 8139 34 02              WAITACIA  PSHS A               
0438 813b b6 d0 00           WRWAIT    LDA  USTAT           
0439 813e 85 02                        BITA #2              
0440 8140 27 f9                        BEQ  WRWAIT          
0441 8142 35 02                        PULS A               
0442 8144 39                           RTS                  
0443 8145 9d dd              LA35F     JSR  RVEC2          HOOK INTO RAM 
0444 8147 34 16                        PSHS X,B,A          SAVE REGISTERS 
0445 8149 9e 76                        LDX  LPTCFW         TAB FIELD WIDTH AND TAB ZONE 
0446 814b dc 78                        LDD  LPTWID         PRINTER WIDTH AND POSITION 
0447 814d 9f 6a              LA37C     STX  DEVCFW         SAVE TAB FIELD WIDTH AND ZONE 
0448 814f d7 6c                        STB  DEVPOS         SAVE PRINT POSITION 
0449 8151 97 6d                        STA  DEVWID         SAVE PRINT WIDTH 
0450 8153 35 96                        PULS A,B,X,PC       RESTORE REGISTERS 
0451                                                        
0452                         * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC                      
0453                         * EXIT WITH BREAK KEY: CARRY = 1                      
0454                         * EXIT WITH ENTER KEY: CARRY = 0                      
0455                         LA38D                          
0456 8155 9d e9              LA390     JSR  RVEC12         HOOK INTO RAM 
0457 8157 0f 73                        CLR  IKEYIM         RESET BREAK CHECK KEY TEMP KEY STORAGE 
0458 8159 8e 01 32                     LDX  #LINBUF+1      INPUT LINE BUFFER 
0459 815c c6 01                        LDB  #1             ACCB CHAR COUNTER: SET TO 1 TO ALLOW A 
0460                         *         BACKSPACE AS FIRST CHARACTER  
0461 815e bd 80 fa           LA39A     JSR  LA171          GO GET A CHARACTER FROM CONSOLE IN 
0462 8161 81 08                        CMPA #BS            BACKSPACE 
0463 8163 26 07                        BNE  LA3B4          NO 
0464 8165 5a                           DECB                YES - DECREMENT CHAR COUNTER 
0465 8166 27 ed                        BEQ  LA390          BRANCH IF BACK AT START OF LINE AGAIN 
0466 8168 30 1f                        LEAX -1,X           DECREMENT BUFFER POINTER 
0467 816a 20 34                        BRA  LA3E8          ECHO CHAR TO SCREEN 
0468 816c 81 15              LA3B4     CMPA #$15           SHIFT RIGHT ARROW? 
0469 816e 26 0a                        BNE  LA3C2          NO 
0470                         * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE                      
0471 8170 5a                 LA3B8     DECB                DEC CHAR CTR 
0472 8171 27 e2                        BEQ  LA390          GO BACK TO START IF CHAR CTR = 0 
0473 8173 86 08                        LDA  #BS            BACKSPACE? 
0474 8175 bd 81 13                     JSR  PUTCHR         SEND TO CONSOLE OUT (SCREEN) 
0475 8178 20 f6                        BRA  LA3B8          KEEP GOING 
0476 817a 81 03              LA3C2     CMPA #3             BREAK KEY? 
0477 817c 1a 01                        ORCC #1             SET CARRY FLAG 
0478 817e 27 05                        BEQ  LA3CD          BRANCH IF BREAK KEY DOWN 
0479 8180 81 0d              LA3C8     CMPA #CR            ENTER KEY? 
0480 8182 26 0d                        BNE  LA3D9          NO 
0481 8184 4f                 LA3CC     CLRA                CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY 
0482 8185 34 01              LA3CD     PSHS CC             SAVE CARRY FLAG 
0483 8187 bd 91 1e                     JSR  LB958          SEND CR TO SCREEN 
0484 818a 6f 84                        CLR  ,X             MAKE LAST BYTE IN INPUT BUFFER = 0 
0485 818c 8e 01 31                     LDX  #LINBUF        RESET INPUT BUFFER POINTER 
0486 818f 35 81                        PULS CC,PC          RESTORE CARRY FLAG 
0487                                                        
0488                         * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER                      
0489 8191 81 20              LA3D9     CMPA #$20           IS IT CONTROL CHAR? 
0490 8193 25 c9                        BLO  LA39A          BRANCH IF CONTROL CHARACTER 
0491 8195 81 7b                        CMPA #'z'+1          * 
0492 8197 24 c5                        BCC  LA39A          * IGNORE IF > LOWER CASE Z 
0493 8199 c1 fa                        CMPB #LBUFMX        HAVE 250 OR MORE CHARACTERS BEEN ENTERED? 
0494 819b 24 c1                        BCC  LA39A          YES, IGNORE ANY MORE 
0495 819d a7 80                        STA  ,X+            PUT IT IN INPUT BUFFER 
0496 819f 5c                           INCB                INCREMENT CHARACTER COUNTER 
0497 81a0 bd 81 13           LA3E8     JSR  PUTCHR         ECHO IT TO SCREEN 
0498 81a3 20 b9                        BRA  LA39A          GO SET SOME MORE 
0499                                                        
0500                                                        
0501                                                        
0502                                                        
0503                                                        
0504                         * EXEC                         
0505 81a5 27 05              EXEC      BEQ  LA545          BRANCH IF NO ARGUMENT 
0506 81a7 bd 8f 2e                     JSR  LB73D          EVALUATE ARGUMENT - ARGUMENT RETURNED IN X 
0507 81aa 9f 7a                        STX  EXECJP         STORE X TO EXEC JUMP ADDRESS 
0508 81ac 6e 9f 00 7a        LA545     JMP  [EXECJP]       GO DO IT 
0509                                                        
0510                         * BREAK CHECK                      
0511 81b0 9d e6              LA549     JSR  RVEC11         HOOK INTO RAM 
0512 81b2 7e 85 e6                     JMP  LADEB          GO DO BREAK KEY CHECK 
0513                                                        
0514                                                        
0515                         * INKEY$                       
0516 81b5 96 73              INKEY     LDA  IKEYIM         WAS A KEY DOWN IN THE BREAK CHECK? 
0517 81b7 26 03                        BNE  LA56B          YES 
0518 81b9 bd 81 04                     JSR  KEYIN          GO GET A KEY 
0519 81bc 0f 73              LA56B     CLR  IKEYIM         CLEAR INKEY RAM IMAGE 
0520 81be 97 53                        STA  FPA0+3         STORE THE KEY IN FPA0 
0521 81c0 10 26 0c b8                  LBNE LB68F          CONVERT FPA0+3 TO A STRING 
0522 81c4 97 56                        STA  STRDES         SET LENGTH OF STRING = 0 IF NO KEY DOWN 
0523 81c6 7e 8e 88                     JMP  LB69B          PUT A NULL STRING ONTO THE STRING STACK 
0524                                                        
0525                                                        
0526                         * MOVE ACCB BYTES FROM (X) TO (U)                      
0527 81c9 a6 80              LA59A     LDA  ,X+            GET BYTE FROM X 
0528 81cb a7 c0                        STA  ,U+            STORE IT AT U 
0529 81cd 5a                           DECB                MOVED ALL BYTES? 
0530 81ce 26 f9                        BNE  LA59A          NO 
0531 81d0 39                 LA5A1     RTS                  
0532                                                        
0533 81d1 39                 LA5C4     RTS                  
0534                                                        
0535                         ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE                      
0536                         ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS                      
0537                         ** FOLLOWING THE END OF THE NAME                      
0538 81d2 bd a4 b9           LA5C7     JSR  GETCCH         GET CURRENT INPUT CHAR FROM BASIC LINE 
0539 81d5 27 fa              LA5C9     BEQ  LA5C4          RETURN IF END OF LINE 
0540 81d7 7e 8a 5f                     JMP  LB277          SYNTAX ERROR IF ANY MORE CHARACTERS 
0541                                                        
0542                                                        
0543                         * IRQ SERVICE                      
0544                         BIRQSV                         
0545 81da 3b                 LA9C5     RTI  RETURN FROM INTERRUPT  
0546                                                        
0547                         *                              
0548                         * SET CARRY IF NUMERIC - RETURN WITH                      
0549                         * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END                      
0550                         * OF BASIC LINE OR SUB LINE                      
0551 81db 81 3a              BROMHK    CMPA #'9'+1          IS THIS CHARACTER >=(ASCII 9)+1? 
0552 81dd 24 0b                        BHS  LAA28          BRANCH IF > 9; Z SET IF = COLON 
0553 81df 81 20                        CMPA #SPACE         SPACE? 
0554 81e1 26 03                        BNE  LAA24          NO - SET CARRY IF NUMERIC 
0555 81e3 7e a4 b3                     JMP  GETNCH         IF SPACE, GET NECT CHAR (IGNORE SPACES) 
0556 81e6 80 30              LAA24     SUBA #'0'            * SET CARRY IF 
0557 81e8 80 d0                        SUBA #-'0'           * CHARACTER > ASCII 0 
0558 81ea 39                 LAA28     RTS                  
0559                         *                              
0560                         * DISPATCH TABLE FOR SECONDARY FUNCTIONS                      
0561                         * TOKENS ARE PRECEEDED BY $FF TOKEN #               
0562 81eb 94 3d              LAA29     FDB  SGN            SGN 
0563 81ed 94 b1                        FDB  INT            INT 
0564 81ef 94 56                        FDB  ABS            ABS 
0565 81f1 01 12                        FDB  $0112          USR 
0566 81f3 96 e7                        FDB  RND            RND 
0567 81f5 97 3c                        FDB  SIN            SIN 
0568 81f7 8f 41                        FDB  PEEK           PEEK 
0569 81f9 8e 6e                        FDB  LEN            LEN 
0570 81fb 8c ea                        FDB  STR            STR$ 
0571 81fd 8f 06                        FDB  VAL            VAL 
0572 81ff 8e 8d                        FDB  ASC            ASC 
0573 8201 8e 79                        FDB  CHR            CHR$ 
0574 8203 98 2c                        FDB    ATN            ATN   
0575 8205 97 f4                        FDB    COS            COS   
0576 8207 97 fd                        FDB    TAN            TAN   
0577 8209 99 6e                        FDB    EXP            EXP   
0578 820b 99 a0                        FDB    FIX            FIX   
0579 820d 98 c2                        FDB    LOG            LOG   
0580 820f 9b 28                        FDB    POS            POS   
0581 8211 98 fc                        FDB    SQR            SQR   
0582 8213 a0 12                        FDB    HEXDOL         HEX$ 
0583 8215 8e 98                        FDB  LEFT           LEFT$ 
0584 8217 8e b5                        FDB  RIGHT          RIGHT$ 
0585 8219 8e bc                        FDB  MID            MID$ 
0586 821b 81 b5                        FDB  INKEY          INKEY$ 
0587 821d 8c db                        FDB  MEM            MEM 
0588 821f 9b 30                        FDB   VARPT           VARPTR 
0589 8221 9b f1                        FDB   INSTR           INSTR   
0590 8223 9b c1                        FDB  STRING         STRING$ 
0591                                                        
0592                                                        
0593                         *                              
0594                                                        
0595                                                        
0596                                                        
0597                                                        
0598                                                        
0599                                                        
0600                                                        
0601                         *                              
0602 8225 79                 LAA51     FCB  $79             
0603 8226 91 88                        FDB  LB9C5          + 
0604 8228 79                           FCB  $79             
0605 8229 91 7f                        FDB  LB9BC          - 
0606 822b 7b                           FCB  $7B             
0607 822c 92 8f                        FDB  LBACC          * 
0608 822e 7b                           FCB  $7B             
0609 822f 93 54                        FDB  LBB91          / 
0610 8231 7f                           FCB  $7F             
0611 8232 99 05                        FDB  L8489          EXPONENTIATION 
0612 8234 50                           FCB  $50             
0613 8235 8a ba                        FDB  LB2D5          AND 
0614 8237 46                           FCB  $46             
0615 8238 8a b9                        FDB  LB2D4          OR 
0616                         *                              
0617                         * THIS IS THE RESERVED WORD TABLE                      
0618                         *         TOKEN #               
0619 823a 46 4f              LAA66     FCC  "FO"           80 
0620 823c d2                           FCB  $80+'R'         
0621 823d 47                           FCC  "G"            81 
0622 823e cf                           FCB  $80+'O'         
0623 823f 52 45                        FCC  "RE"           82 
0624 8241 cd                           FCB  $80+'M'         
0625 8242 a7                           FCB  ''+$80         83 
0626                                                        
0627 8243 45 4c 53                     FCC  "ELS"          84 
0628 8246 c5                           FCB  $80+'E'         
0629 8247 49                           FCC  "I"            85 
0630 8248 c6                           FCB  $80+'F'         
0631 8249 44 41 54                     FCC  "DAT"          86 
0632 824c c1                           FCB  $80+'A'         
0633 824d 50 52 49 4e                  FCC  "PRIN"         87 
0634 8251 d4                           FCB  $80+'T'         
0635 8252 4f                           FCC  "O"            88 
0636 8253 ce                           FCB  $80+'N'         
0637 8254 49 4e 50 55                  FCC  "INPU"         89 
0638 8258 d4                           FCB  $80+'T'         
0639 8259 45 4e                        FCC  "EN"           8A 
0640 825b c4                           FCB  $80+'D'         
0641 825c 4e 45 58                     FCC  "NEX"          8B 
0642 825f d4                           FCB  $80+'T'         
0643 8260 44 49                        FCC  "DI"           8C 
0644 8262 cd                           FCB  $80+'M'         
0645 8263 52 45 41                     FCC  "REA"          8D 
0646 8266 c4                           FCB  $80+'D'         
0647 8267 52 55                        FCC  "RU"           8E 
0648 8269 ce                           FCB  $80+'N'         
0649 826a 52 45 53 54 4f 52            FCC  "RESTOR"       8F 
0650 8270 c5                           FCB  $80+'E'         
0651 8271 52 45 54 55 52               FCC  "RETUR"        90 
0652 8276 ce                           FCB  $80+'N'         
0653 8277 53 54 4f                     FCC  "STO"          91 
0654 827a d0                           FCB  $80+'P'         
0655 827b 50 4f 4b                     FCC  "POK"          92 
0656 827e c5                           FCB  $80+'E'         
0657 827f 43 4f 4e                     FCC  "CON"          93 
0658 8282 d4                           FCB  $80+'T'         
0659 8283 4c 49 53                     FCC  "LIS"          94 
0660 8286 d4                           FCB  $80+'T'         
0661 8287 43 4c 45 41                  FCC  "CLEA"         95 
0662 828b d2                           FCB  $80+'R'         
0663 828c 4e 45                        FCC  "NE"           96 
0664 828e d7                           FCB  $80+'W'         
0665 828f 54 52 4f                     FCC  "TRO"          97 
0666 8292 ce                           FCB  $80+'N'         
0667 8293 54 52 4f 46                  FCC  "TROF"         98 
0668 8297 c6                           FCB  $80+'F'         
0669 8298 44 45                        FCC  "DE"           99 
0670 829a cc                           FCB  $80+'L'         
0671 829b 44 45                        FCC  "DE"           9A 
0672 829d c6                           FCB  $80+'F'         
0673 829e 4c 49 4e                     FCC  "LIN"          9B 
0674 82a1 c5                           FCB  $80+'E'         
0675 82a2 52 45 4e 55                  FCC  "RENU"         9C 
0676 82a6 cd                           FCB  $80+'M'         
0677 82a7 45 44 49                     FCC  "EDI"          9D 
0678 82aa d4                           FCB  $80+'T'         
0679 82ab 43 4c                        FCC  "CL"           9E 
0680 82ad d3                           FCB  $80+'S'         
0681 82ae 4d 4f 54 4f                  FCC  "MOTO"         9F 
0682 82b2 d2                           FCB  $80+'R'         
0683 82b3 53 4f 55 4e                  FCC  "SOUN"         A0 
0684 82b7 c4                           FCB  $80+'D'         
0685 82b8 41 55 44 49                  FCC  "AUDI"         A1 
0686 82bc cf                           FCB  $80+'O'         
0687 82bd 45 58 45                     FCC  "EXE"          A2 
0688 82c0 c3                           FCB  $80+'C'         
0689 82c1 53 4b 49 50                  FCC  "SKIP"         A3 
0690 82c5 c6                           FCB  $80+'F'         
0691 82c6 54 41 42                     FCC  "TAB"          A4 
0692 82c9 a8                           FCB  $80+'('         
0693 82ca 54                           FCC  "T"            A5 
0694 82cb cf                           FCB  $80+'O'         
0695 82cc 53 55                        FCC  "SU"           A6 
0696 82ce c2                           FCB  $80+'B'         
0697 82cf 54 48 45                     FCC  "THE"          A7 
0698 82d2 ce                           FCB  $80+'N'         
0699 82d3 4e 4f                        FCC  "NO"           A8 
0700 82d5 d4                           FCB  $80+'T'         
0701 82d6 53 54 45                     FCC  "STE"          A9 
0702 82d9 d0                           FCB  $80+'P'         
0703 82da 4f 46                        FCC  "OF"           AA 
0704 82dc c6                           FCB  $80+'F'         
0705 82dd ab                           FCB  '++$80         AB 
0706 82de ad                           FCB  '-+$80         AC 
0707 82df aa                           FCB  '*+$80         AD 
0708 82e0 af                           FCB  '/+$80         AE 
0709 82e1 de                           FCB  '^+$80         AF 
0710 82e2 41 4e                        FCC  "AN"           B0 
0711 82e4 c4                           FCB  $80+'D'         
0712 82e5 4f                           FCC  "O"            B1 
0713 82e6 d2                           FCB  $80+'R'         
0714 82e7 be                           FCB  '>+$80         B2 
0715 82e8 bd                           FCB  '=+$80         B3 
0716 82e9 bc                           FCB  '<+$80         B4 
0717 82ea 46                           FCC  "F"            B5 
0718 82eb ce                           FCB  $80+'N'         
0719 82ec 55 53 49 4e                  FCC  "USIN"         B6 
0720 82f0 c7                           FCB  $80+'G'         
0721                         *                              
0722                                                        
0723                         * TOKEN #                      
0724 82f1 53 47              LAB1A     FCC  "SG"           80 
0725 82f3 ce                           FCB  $80+'N'         
0726 82f4 49 4e                        FCC  "IN"           81 
0727 82f6 d4                           FCB  $80+'T'         
0728 82f7 41 42                        FCC  "AB"           82 
0729 82f9 d3                           FCB  $80+'S'         
0730 82fa 55 53                        FCC  "US"           83 
0731 82fc d2                           FCB  $80+'R'         
0732 82fd 52 4e                        FCC  "RN"           84 
0733 82ff c4                           FCB  $80+'D'         
0734 8300 53 49                        FCC  "SI"           85 
0735 8302 ce                           FCB  $80+'N'         
0736 8303 50 45 45                     FCC  "PEE"          86 
0737 8306 cb                           FCB  $80+'K'         
0738 8307 4c 45                        FCC  "LE"           87 
0739 8309 ce                           FCB  $80+'N'         
0740 830a 53 54 52                     FCC  "STR"          88 
0741 830d a4                           FCB  $80+'$'         
0742 830e 56 41                        FCC  "VA"           89 
0743 8310 cc                           FCB  $80+'L'         
0744 8311 41 53                        FCC  "AS"           8A 
0745 8313 c3                           FCB  $80+'C'         
0746 8314 43 48 52                     FCC  "CHR"          8B 
0747 8317 a4                           FCB  $80+'$'         
0748 8318 41 54                        FCC   "AT"           8C 
0749 831a ce                           FCB  $80+'N'         
0750 831b 43 4f                        FCC   "CO"           8D 
0751 831d d3                           FCB  $80+'S'         
0752 831e 54 41                        FCC   "TA"           8E 
0753 8320 ce                           FCB  $80+'N'         
0754 8321 45 58                        FCC   "EX"           8F 
0755 8323 d0                           FCB  $80+'P'         
0756 8324 46 49                        FCC   "FI"           90 
0757 8326 d8                           FCB  $80+'X'         
0758 8327 4c 4f                        FCC   "LO"           91 
0759 8329 c7                           FCB  $80+'G'         
0760 832a 50 4f                        FCC   "PO"           92 
0761 832c d3                           FCB  $80+'S'         
0762 832d 53 51                        FCC   "SQ"           93 
0763 832f d2                           FCB  $80+'R'         
0764 8330 48 45 58                     FCC   "HEX"          94 
0765 8333 a4                           FCB  $80+'$'         
0766 8334 4c 45 46 54                  FCC  "LEFT"         95 
0767 8338 a4                           FCB  $80+'$'         
0768 8339 52 49 47 48 54               FCC  "RIGHT"        96 
0769 833e a4                           FCB  $80+'$'         
0770 833f 4d 49 44                     FCC  "MID"          97 
0771 8342 a4                           FCB  $80+'$'         
0772 8343 49 4e 4b 45 59               FCC  "INKEY"        98 
0773 8348 a4                           FCB  $80+'$'         
0774 8349 4d 45                        FCC  "ME"           99 
0775 834b cd                           FCB  $80+'M'         
0776 834c 56 41 52 50 54               FCC   "VARPT"        9A 
0777 8351 d2                           FCB  $80+'R'         
0778 8352 49 4e 53 54                  FCC   "INST"         9B 
0779 8356 d2                           FCB  $80+'R'         
0780 8357 53 54 52 49 4e 47            FCC  "STRING"       9C 
0781 835d a4                           FCB  $80+'$'         
0782                                                        
0783                                                        
0784                         *                              
0785                         * DISPATCH TABLE FOR COMMANDS TOKEN #               
0786 835e 85 2d              LAB67     FDB  FOR            FOR 
0787 8360 86 7b                        FDB  GO             GO 
0788 8362 86 da                        FDB  REM            REM 
0789 8364 86 da                        FDB  REM            REM 
0790 8366 86 da                        FDB  REM            ELSE 
0791 8368 87 0b                        FDB  IF             IF 
0792 836a 86 d7                        FDB  DATA           DATA 
0793 836c 90 df                        FDB  PRINT          PRINT 
0794 836e 87 3d                        FDB  ON             ON 
0795 8370 87 ee                        FDB  INPUT          INPUT 
0796 8372 85 fd                        FDB  END            END 
0797 8374 88 d8                        FDB  NEXT           NEXT 
0798 8376 8b 33                        FDB  DIM            DIM 
0799 8378 88 28                        FDB  READ           READ 
0800 837a 86 6d                        FDB  RUN            RUN 
0801 837c 85 df                        FDB  RESTOR         RESTORE 8F 
0802 837e 86 b7                        FDB  RETURN         RETURN 
0803 8380 86 02                        FDB  STOP           STOP 
0804 8382 8f 48                        FDB  POKE           POKE 
0805 8384 86 27                        FDB  CONT           CONTINUE93 
0806 8386 8f 4f                        FDB  LIST           LIST 
0807 8388 86 38                        FDB  CLEAR          CLEAR 
0808 838a 84 fd                        FDB  NEW            NEW 
0809 838c 9b 23                        FDB  TRON           CLOAD 
0810 838e 9b 24                        FDB  TROFF          CSAVE 
0811 8390 9d aa                        FDB  DEL            OPEN 
0812 8392 9c ea                        FDB  DEF            CLOSE 
0813 8394 a4 aa                        FDB  LINE           LLIST 
0814 8396 9e 37                        FDB  RENUM          SET 
0815 8398 99 af                        FDB  EDIT           RESET 
0816 839a 86 da                        FDB  REM            CLS 
0817 839c 86 da                        FDB  REM            MOTOR 
0818 839e 86 da                        FDB  REM            SOUND 
0819 83a0 86 da                        FDB  REM            AUDIO 
0820 83a2 81 a5                        FDB  EXEC           EXEC 
0821 83a4 86 da                        FDB  REM            SKIPF 
0822                         *                              
0823                         * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY                      
0824 83a6 4e 46              LABAF     FCC  "NF"           0 
0825 83a8 53 4e                        FCC  "SN"           1 
0826 83aa 52 47                        FCC  "RG"           2 
0827 83ac 4f 44                        FCC  "OD"           3 
0828 83ae 46 43                        FCC  "FC"           4 
0829 83b0 4f 56                        FCC  "OV"           5 
0830 83b2 4f 4d                        FCC  "OM"           6 
0831 83b4 55 4c                        FCC  "UL"           7 
0832 83b6 42 53                        FCC  "BS"           8 
0833 83b8 44 44                        FCC  "DD"           9 
0834 83ba 2f 30                        FCC  "/0"           10 DIVISION BY ZERO 
0835 83bc 49 44                        FCC  "ID"           11 ILLEGAL DIRECT STATEMENT 
0836 83be 54 4d                        FCC  "TM"           12 TYPE MISMATCH 
0837 83c0 4f 53                        FCC  "OS"           13 OUT OF STRING SPACE 
0838 83c2 4c 53                        FCC  "LS"           14 STRING TOO LONG 
0839 83c4 53 54                        FCC  "ST"           15 STRING FORMULA TOO COMPLEX 
0840 83c6 43 4e                        FCC  "CN"           16 CAN'T CONTINUE 
0841 83c8 46 44                        FCC  "FD"           17 BAD FILE DATA 
0842 83ca 41 4f                        FCC  "AO"           18 FILE ALREADY OPEN 
0843 83cc 44 4e                        FCC  "DN"           19 DEVICE NUMBER ERROR 
0844 83ce 49 4f                        FCC  "IO"           20 I/O ERROR 
0845 83d0 46 4d                        FCC  "FM"           21 BAD FILE MODE 
0846 83d2 4e 4f                        FCC  "NO"           22 FILE NOT OPEN 
0847 83d4 49 45                        FCC  "IE"           23 INPUT PAST END OF FILE 
0848 83d6 44 53                        FCC  "DS"           24 DIRECT STATEMENT IN FILE 
0849                         * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC                      
0850                                                        
0851 83d8 55 46              L890B     FCC  "UF"           25 UNDEFINED FUNCTION (FN) CALL 
0852 83da 4e 45              L890D     FCC  "NE"           26 FILE NOT FOUND 
0853                                                        
0854 83dc 20 45 52 52 4f 52  LABE1     FCC  " ERROR"        
0855 83e2 00                           FCB  $00             
0856 83e3 20 49 4e 20        LABE8     FCC  " IN "          
0857 83e7 00                           FCB  $00             
0858 83e8 0d                 LABED     FCB  CR              
0859 83e9 4f 4b              LABEE     FCC  "OK"            
0860 83eb 0d 00                        FCB  CR,$00          
0861 83ed 0d                 LABF2     FCB  CR              
0862 83ee 42 52 45 41 4b               FCC  "BREAK"         
0863 83f3 00                           FCB  $00             
0864                         * SEARCH THE STACK FOR ‘GOSUB/RETURN’ OR ‘FOR/NEXT’ DATA.                      
0865                         * THE ‘FOR/NEXT’ INDEX VARIABLE DESCRIPTOR ADDRESS BEING                      
0866                         * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18                      
0867                         * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES                      
0868                         * WITH AN $A6 LEADER BYTE. THE  FIRST NON "FOR/NEXT" DATA  
0869                         * IS CONSIDERED ‘GOSUB/RETURN’                      
0870 83f4 30 64              LABF9     LEAX 4,S            POINT X TO 3RD ADDRESS ON STACK - IGNORE THE 
0871                         *         FIRST TWO RETURN ADDRESSES ON THE STACK  
0872 83f6 c6 12              LABFB     LDB  #18            18 BYTES SAVED ON STACK FOR EACH ‘FOR’ LOOP 
0873 83f8 9f 0f                        STX  TEMPTR         SAVE POINTER 
0874 83fa a6 84                        LDA  ,X             GET 1ST BYTE 
0875 83fc 80 80                        SUBA #$80           * CHECK FOR TYPE OF STACK JUMP FOUND 
0876 83fe 26 15                        BNE  LAC1A          * BRANCH IF NOT ‘FOR/NEXT’ 
0877 8400 ae 01                        LDX  1,X            = GET INDEX VARIABLE DESCRIPTOR 
0878 8402 9f 11                        STX  TMPTR1         = POINTER AND SAVE IT IN TMPTR1 
0879 8404 9e 3b                        LDX  VARDES         GET INDEX VARIABLE BEING SEARCHED FOR 
0880 8406 27 09                        BEQ  LAC16          BRANCH IF DEFAULT INDEX VARIABLE - USE THE 
0881                         *                             FIRST ‘FOR/NEXT’ DATA FOUND ON STACK 
0882                         *                             IF NO INDEX VARIABLE AFTER ‘NEXT’ 
0883 8408 9c 11                        CMPX TMPTR1         DOES THE STACK INDEX MATCH THE ONE 
0884                         *                             BEING SEARCHED FOR? 
0885 840a 27 09                        BEQ  LAC1A          YES 
0886 840c 9e 0f                        LDX  TEMPTR         * RESTORE INITIAL POINTER, ADD 
0887 840e 3a                           ABX                 * 18 TO IT AND LOOK FOR 
0888 840f 20 e5                        BRA  LABFB          * NEXT BLOCK OF DATA 
0889 8411 9e 11              LAC16     LDX  TMPTR1         = GET 1ST INDEX VARIABLE FOUND AND 
0890 8413 9f 3b                        STX  VARDES         = SAVE AS ‘NEXT’ INDEX 
0891 8415 9e 0f              LAC1A     LDX  TEMPTR         POINT X TO START OF ‘FOR/NEXT’ DATA 
0892 8417 4d                           TSTA                SET ZERO FLAG IF ‘FOR/NEXT’ DATA 
0893 8418 39                           RTS                  
0894                         * CHECK FOR MEMORY SPACE FOR NEW TOP OF                      
0895                         * ARRAYS AND MOVE ARRAYS TO NEW LOCATION                      
0896 8419 8d 17              LAC1E     BSR  LAC37          ACCD = NEW BOTTOM OF FREE RAM - IS THERE 
0897                         *                             ROOM FOR THE STACK? 
0898                         * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND                      
0899                         * SAVE FINAL VALUE OF U IN V45                      
0900 841b de 41              LAC20     LDU  V41            POINT U TO DESTINATION ADDRESS (V41) 
0901 841d 33 41                        LEAU 1,U            ADD ONE TO U - COMPENSATE FOR FIRST PSHU 
0902 841f 9e 43                        LDX  V43            POINT X TO SOURCE ADDRESS (V43) 
0903 8421 30 01                        LEAX 1,X            ADD ONE - COMPENSATE FOR FIRST LDA ,X 
0904 8423 a6 82              LAC28     LDA  ,-X            GRAB A BYTE FROM SOURCE 
0905 8425 36 02                        PSHU A              MOVE IT TO DESTINATION 
0906 8427 9c 47                        CMPX V47            DONE? 
0907 8429 26 f8                        BNE  LAC28          NO - KEEP MOVING BYTES 
0908 842b df 45                        STU  V45            SAVE FINAL DESTINATION ADDRESS 
0909 842d 39                 LAC32     RTS                  
0910                         * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB                      
0911                         * BYTES IN FREE RAM - OM ERROR IF NOT                      
0912 842e 4f                 LAC33     CLRA                * ACCD CONTAINS NUMBER OF EXTRA 
0913 842f 58                           ASLB                * BYTES TO PUT ON STACK 
0914 8430 d3 1f                        ADDD ARYEND         END OF PROGRAM AND VARIABLES 
0915 8432 c3 00 3a           LAC37     ADDD #STKBUF        ADD STACK BUFFER - ROOM FOR STACK? 
0916 8435 25 08                        BCS  LAC44          BRANCH IF GREATER THAN $FFFF 
0917 8437 10 df 17                     STS  BOTSTK         CURRENT NEW BOTTOM OF STACK STACK POINTER 
0918 843a 10 93 17                     CMPD BOTSTK         ARE WE GOING TO BE BELOW STACK? 
0919 843d 25 ee                        BCS  LAC32          YES - NO ERROR 
0920 843f c6 0c              LAC44     LDB  #6*2           OUT OF MEMORY ERROR 
0921                                                        
0922                         * ERROR SERVICING ROUTINE                      
0923 8441 9d ef              LAC46     JSR  RVEC16         HOOK INTO RAM 
0924 8443 9d f2                        JSR  RVEC17         HOOK INTO RAM 
0925 8445 bd 85 19                     JSR  LAD33          RESET STACK, STRING STACK, CONTINUE POINTER 
0926 8448 bd 91 22                     JSR  LB95C          SEND A CR TO SCREEN 
0927 844b bd 91 72                     JSR  LB9AF          SEND A ‘?‘ TO SCREEN 
0928 844e 8e 83 a6                     LDX  #LABAF         POINT TO ERROR TABLE 
0929 8451 3a                 LAC60     ABX                 ADD MESSAGE NUMBER OFFSET 
0930 8452 8d 32                        BSR  LACA0          * GET TWO CHARACTERS FROM X AND 
0931 8454 8d 30                        BSR  LACA0          * SEND TO CONSOLE OUT (SCREEN) 
0932 8456 8e 83 db                     LDX  #LABE1-1       POINT TO "ERROR" MESSAGE 
0933 8459 bd 91 5f           LAC68     JSR  LB99C          PRINT MESSAGE POINTED TO BY X 
0934 845c 96 68                        LDA  CURLIN         GET CURRENT LINE NUMBER (CURL IN) 
0935 845e 4c                           INCA                TEST FOR DIRECT MODE 
0936 845f 27 03                        BEQ  LAC73          BRANCH IF DIRECT MODE 
0937 8461 bd 95 8d                     JSR  LBDC5          PRINT ‘IN ****‘ 
0938                                                        
0939                         * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE                      
0940 8464 bd 91 22           LAC73     JSR  LB95C          MOVE CURSOR TO START OF LINE 
0941 8467 8e 83 e8                     LDX  #LABED         POINT X TO ‘OK’, CR MESSAGE 
0942 846a bd 91 5f                     JSR  LB99C          PRINT ‘OK’, CR 
0943 846d bd 81 55           LAC7C     JSR  LA390          GO GET AN INPUT LINE 
0944 8470 ce ff ff                     LDU  #$FFFF         THE LINE NUMBER FOR DIRECT MODE IS $FFFF 
0945 8473 df 68                        STU  CURLIN         SAVE IT IN CURLIN 
0946 8475 25 f6                        BCS  LAC7C          BRANCH IF LINE INPUT TERMINATED BY BREAK 
0947 8477 9f 7c                        STX  CHARAD         SAVE (X) AS CURRENT INPUT POINTER - THIS WILL 
0948                         *         ENABLE THE ‘LIVE KEYBOARD’ (DIRECT) MODE. THE  
0949                         *         LINE JUST ENTERED WILL BE INTERPRETED  
0950 8479 bd a4 b3                     JSR  GETNCH         GET NEXT CHARACTER FROM BASIC 
0951 847c 27 ef                        BEQ  LAC7C          NO LINE INPUT - GET ANOTHER LINE 
0952 847e 25 0b                        BCS  LACA5          BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE 
0953                         *         THE  STATEMENT ENTERED, SO THIS STATEMENT  
0954                         *         WILL BE MERGED INTO THE BASIC PROGRAM  
0955 8480 bd 90 09                     JSR  LB821          GO CRUNCH LINE 
0956 8483 7e 85 aa                     JMP  LADC0          GO EXECUTE THE STATEMENT (LIVE KEYBOARD) 
0957                         *                              
0958 8486 a6 80              LACA0     LDA  ,X+            GET A CHARACTER 
0959 8488 7e 91 74                     JMP  LB9B1          SEND TO CONSOLE OUT 
0960                         * TAKE A LINE FROM THE LINE INPUT BUFFER                      
0961                         * AND INSERT IT INTO THE BASIC PROGRAM                      
0962 848b bd 87 65           LACA5     JSR  LAF67          CONVERT LINE NUMBER TO BINARY 
0963 848e 9e 2b              LACA8     LDX  BINVAL         GET CONVERTED LINE NUMBER 
0964 8490 bf 01 2f                     STX  LINHDR         STORE IT IN LINE INPUT HEADER 
0965 8493 bd 90 09                     JSR  LB821          GO CRUNCH THE LINE 
0966 8496 d7 03                        STB  TMPLOC         SAVE LINE LENGTH 
0967 8498 8d 4d                        BSR  LAD01          FIND OUT WHERE TO INSERT LINE 
0968 849a 25 12                        BCS  LACC8          BRANCH IF LINE NUMBER DOES NOT ALREADY EXIST 
0969 849c dc 47                        LDD  V47            GET ABSOLUTE ADDRESS OF LINE NUMBER 
0970 849e a3 84                        SUBD ,X             SUBTRACT ADDRESS OF NEXT LINE NUMBER 
0971 84a0 d3 1b                        ADDD VARTAB         * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE 
0972 84a2 dd 1b                        STD  VARTAB         * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM 
0973 84a4 ee 84                        LDU  ,X             POINT U TO ADDRESS OF NEXT LINE NUMBER 
0974                         * DELETE OLD LINE FROM BASIC PROGRAM                      
0975 84a6 37 02              LACC0     PULU A              GET A BYTE FROM WHAT’S LEFT OF PROGRAM 
0976 84a8 a7 80                        STA  ,X+            MOVE IT DOWN 
0977 84aa 9c 1b                        CMPX VARTAB         COMPARE TO END OF BASIC PROGRAM 
0978 84ac 26 f8                        BNE  LACC0          BRANCH IF NOT AT END 
0979 84ae b6 01 31           LACC8     LDA  LINBUF         * CHECK TO SEE IF THERE IS A LINE IN 
0980 84b1 27 1c                        BEQ  LACE9          * THE BUFFER AND BRANCH IF NONE 
0981 84b3 dc 1b                        LDD  VARTAB         = SAVE CURRENT END OF 
0982 84b5 dd 43                        STD  V43            = PROGRAM IN V43 
0983 84b7 db 03                        ADDB TMPLOC         * ADD LENGTH OF CRUNCHED LINE, 
0984 84b9 89 00                        ADCA #0             * PROPOGATE CARRY AND SAVE NEW END 
0985 84bb dd 41                        STD  V41            * OF PROGRAM IN V41 
0986 84bd bd 84 19                     JSR  LAC1E          = MAKE SURE THERE’S ENOUGH RAM FOR THIS 
0987                         *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE  
0988 84c0 ce 01 2d                     LDU  #LINHDR-2      POINT U TO LINE TO BE INSERTED 
0989 84c3 37 02              LACDD     PULU A              GET A BYTE FROM NEW LINE 
0990 84c5 a7 80                        STA  ,X+            INSERT IT IN PROGRAM 
0991 84c7 9c 45                        CMPX V45            * COMPARE TO ADDRESS OF END OF INSERTED 
0992 84c9 26 f8                        BNE  LACDD          * LINE AND BRANCH IF NOT DONE 
0993 84cb 9e 41                        LDX  V41            = GET AND SAVE 
0994 84cd 9f 1b                        STX  VARTAB         = END OF PROGRAM 
0995 84cf 8d 36              LACE9     BSR  LAD21          RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE 
0996 84d1 8d 02                        BSR  LACEF          ADJUST START OF NEXT LINE ADDRESSES 
0997 84d3 20 98                        BRA  LAC7C          REENTER BASIC’S INPUT LOOP 
0998                         * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM                      
0999 84d5 9e 19              LACEF     LDX  TXTTAB         POINT X TO START OF PROGRAM 
1000 84d7 ec 84              LACF1     LDD  ,X             GET ADDRESS OF NEXT LINE 
1001 84d9 27 21                        BEQ  LAD16          RETURN IF END OF PROGRAM 
1002 84db 33 04                        LEAU 4,X            POINT U TO START OF BASIC TEXT IN LINE 
1003 84dd a6 c0              LACF7     LDA  ,U+            * SKIP THROUGH THE LINE UNTIL A 
1004 84df 26 fc                        BNE  LACF7          * ZERO (END OF LINE) IS FOUND 
1005 84e1 ef 84                        STU  ,X             SAVE THE NEW START OF NEXT LINE ADDRESS 
1006 84e3 ae 84                        LDX  ,X             POINT X TO START OF NEXT LINE 
1007 84e5 20 f0                        BRA  LACF1          KEEP GOING 
1008                         *                              
1009                         * FIND A LINE NUMBER IN THE BASIC PROGRAM                      
1010                         * RETURN WITH CARRY SET IF NO MATCH FOUND                      
1011 84e7 dc 2b              LAD01     LDD  BINVAL         GET THE LINE NUMBER TO FIND 
1012 84e9 9e 19                        LDX  TXTTAB         BEGINNING OF PROGRAM 
1013 84eb ee 84              LAD05     LDU  ,X             GET ADDRESS OF NEXT LINE NUMBER 
1014 84ed 27 09                        BEQ  LAD12          BRANCH IF END OF PROG 
1015 84ef 10 a3 02                     CMPD 2,X            IS IT A MATCH? 
1016 84f2 23 06                        BLS  LAD14          CARRY SET IF LOWER; CARRY CLEAR IF MATCH 
1017 84f4 ae 84                        LDX  ,X             X = ADDRESS OF NEXT LINE 
1018 84f6 20 f3                        BRA  LAD05          KEEP LOOPING FOR LINE NUMBER 
1019 84f8 1a 01              LAD12     ORCC #1             SET CARRY FLAG 
1020 84fa 9f 47              LAD14     STX  V47            SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER 
1021                         *                             WHERE IT SHOULD HAVE BEEN 
1022 84fc 39                 LAD16     RTS                  
1023                                                        
1024                         * NEW                          
1025 84fd 26 fb              NEW       BNE  LAD14          BRANCH IF ARGUMENT GIVEN 
1026 84ff 9e 19              LAD19     LDX  TXTTAB         GET START OF BASIC 
1027 8501 6f 80                        CLR  ,X+            * PUT 2 ZERO BYTES THERE - ERASE 
1028 8503 6f 80                        CLR  ,X+            * THE BASIC PROGRAM 
1029 8505 9f 1b                        STX  VARTAB         AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM 
1030 8507 9e 19              LAD21     LDX  TXTTAB         GET START OF BASIC 
1031 8509 bd 86 b2                     JSR  LAEBB          PUT INPUT POINTER ONE BEFORE START OF BASIC 
1032                         * ERASE ALL VARIABLES                      
1033 850c 9e 27              LAD26     LDX  MEMSIZ         * RESET START OF STRING VARIABLES 
1034 850e 9f 23                        STX  STRTAB         * TO TOP OF STRING SPACE 
1035 8510 bd 85 df                     JSR  RESTOR         RESET ‘DATA’ POINTER TO START OF BASIC 
1036 8513 9e 1b                        LDX  VARTAB         * GET START OF VARIABLES AND USE IT 
1037 8515 9f 1d                        STX  ARYTAB         * TO RESET START OF ARRAYS 
1038 8517 9f 1f                        STX  ARYEND         RESET END OF ARRAYS 
1039 8519 8e 01 07           LAD33     LDX  #STRSTK        * RESET STRING STACK POINTER TO 
1040 851c 9f 0b                        STX  TEMPPT         * BOTTOM OF STRING STACK 
1041 851e ae e4                        LDX  ,S             GET RETURN ADDRESS OFF STACK 
1042 8520 10 de 21                     LDS  FRETOP         RESTORE STACK POINTER 
1043 8523 6f e2                        CLR  ,-S            PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF 
1044                         *                             FOR/NEXT DATA FROM THE STACK 
1045 8525 0f 2d                        CLR  OLDPTR         RESET ‘CONT’ ADDRESS SO YOU 
1046 8527 0f 2e                        CLR  OLDPTR+1       ‘CAN’T CONTINUE’ 
1047 8529 0f 08                        CLR  ARYDIS         CLEAR THE ARRAY DISABLE FLAG 
1048 852b 6e 84                        JMP  ,X             RETURN TO CALLING ROUTINE - THIS IS NECESSARY 
1049                         *                             SINCE THE STACK WAS RESET 
1050                         *                              
1051                         * FOR                          
1052                         *                              
1053                         * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR                      
1054                         * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE                      
1055                         * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);                      
1056                         *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;  
1057                         *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;  
1058                         * 9-13=FP VALUE OF ‘TO’ PARAMETER;                      
1059                         * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END                      
1060                         *         OF   THE LINE CONTAINING THE ‘FOR’ STATEMENT  
1061 852d 86 80              FOR       LDA  #$80           * SAVE THE DISABLE ARRAY FLAG IN VO8 
1062 852f 97 08                        STA  ARYDIS         * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY 
1063 8531 bd 87 88                     JSR  LET            SET INDEX VARIABLE TO INITIAL VALUE 
1064 8534 bd 83 f4                     JSR  LABF9          SEARCH THE STACK FOR ‘FOR/NEXT’ DATA 
1065 8537 32 62                        LEAS 2,S            PURGE RETURN ADDRESS OFF OF THE STACK 
1066 8539 26 04                        BNE  LAD59          BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED 
1067 853b 9e 0f                        LDX  TEMPTR         GET (ADDRESS + 18) OF MATCHED ‘FOR/NEXT’ DATA 
1068 853d 32 85                        LEAS B,X            MOVE THE STACK POINTER TO THE BEGINNING OF THE 
1069                         * MATCHED ‘FOR/NEXT’ DATA SO THE NEW DATA WILL                      
1070                         * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY                      
1071                         * ALL OF THE ‘RETURN’ AND ‘FOR/NEXT’ DATA BELOW                      
1072                         * THIS POINT ON THE STACK                      
1073 853f c6 09              LAD59     LDB  #$09           * CHECK FOR ROOM FOR 18 BYTES 
1074 8541 bd 84 2e                     JSR  LAC33          * IN FREE RAM 
1075 8544 bd 86 df                     JSR  LAEE8          GET ADDR OF END OF SUBLINE IN X 
1076 8547 dc 68                        LDD  CURLIN         GET CURRENT LINE NUMBER 
1077 8549 34 16                        PSHS X,B,A          SAVE LINE ADDR AND LINE NUMBER ON STACK 
1078 854b c6 a5                        LDB  #$A5           TOKEN FOR ‘TO’ 
1079 854d bd 8a 56                     JSR  LB26F          SYNTAX CHECK FOR ‘TO’ 
1080 8550 bd 89 25                     JSR  LB143          ‘TM’ ERROR IF INDEX VARIABLE SET TO STRING 
1081 8553 bd 89 23                     JSR  LB141          EVALUATE EXPRESSION 
1082                         *                              
1083 8556 d6 54                        LDB  FP0SGN         GET FPA0 MANTISSA SIGN 
1084 8558 ca 7f                        ORB  #$7F           FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA 
1085 855a d4 50                        ANDB FPA0           PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA 
1086 855c d7 50                        STB  FPA0           SAVE THE PACKED HIGH ORDER MANTISSA 
1087 855e 10 8e 85 65                  LDY  #LAD7F         LOAD FOLLOWING ADDRESS INTO Y AS A RETURN 
1088 8562 7e 89 ce                     JMP  LB1EA          ADDRESS - PUSH FPA0 ONTO THE STACK 
1089 8565 8e 92 88           LAD7F     LDX  #LBAC5         POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE) 
1090 8568 bd 93 d7                     JSR  LBC14          MOVE (X) TO FPA0 
1091 856b bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
1092 856e 81 a9                        CMPA #$A9           STEP TOKEN 
1093 8570 26 06                        BNE  LAD90          BRANCH IF NO ‘STEP’ VALUE 
1094 8572 bd a4 b3                     JSR  GETNCH         GET A CHARACTER FROM BASIC 
1095 8575 bd 89 23                     JSR  LB141          EVALUATE NUMERIC EXPRESSION 
1096 8578 bd 94 30           LAD90     JSR  LBC6D          CHECK STATUS OF FPA0 
1097 857b bd 89 ca                     JSR  LB1E6          SAVE STATUS AND FPA0 ON THE STACK 
1098 857e dc 3b                        LDD  VARDES         * GET DESCRIPTOR POINTER FOR THE ‘STEP’ 
1099 8580 34 06                        PSHS B,A            * VARIABLE AND SAVE IT ON THE STACK 
1100 8582 86 80                        LDA  #$80           = GET THE ‘FOR’ FLAG AND 
1101 8584 34 02                        PSHS A              = SAVE IT ON THE STACK 
1102                         *                              
1103                         * MAIN COMMAND INTERPRETATION LOOP                      
1104 8586 9d fb              LAD9E     JSR  RVEC20         HOOK INTO RAM 
1105 8588 bd 97 b4                     JSR  XVEC20          
1106 858b 1c af                        ANDCC #$AF           ENABLE IRQ,FIRQ 
1107 858d 8d 57                        BSR  LADEB          CHECK FOR KEYBOARD BREAK 
1108 858f 9e 7c                        LDX  CHARAD         GET BASIC’S INPUT POINTER 
1109 8591 9f 2f                        STX  TINPTR         SAVE IT 
1110 8593 a6 80                        LDA  ,X+            GET CURRENT INPUT CHAR & MOVE POINTER 
1111 8595 27 07                        BEQ  LADB4          BRANCH IF END OF LINE 
1112 8597 81 3a                        CMPA #':'            CHECK FOR LINE SEPARATOR 
1113 8599 27 0f                        BEQ  LADC0          BRANCH IF COLON 
1114 859b 7e 8a 5f           LADB1     JMP  LB277          ‘SYNTAX ERROR’-IF NOT LINE SEPARATOR 
1115 859e a6 81              LADB4     LDA  ,X++           GET MS BYTE OF ADDRESS OF NEXT BASIC LINE 
1116 85a0 97 00                        STA  ENDFLG         SAVE IN STOP/END FLAG - CAUSE A STOP IF 
1117                         *         NEXT LINE ADDRESS IS < $8000; CAUSE  
1118                         *         AN   END IF ADDRESS > $8000  
1119 85a2 27 6a                        BEQ  LAE15          BRANCH TO ‘STOP’ - END OF PROGRAM 
1120 85a4 ec 80                        LDD  ,X+            GET CURRENT LINE NUMBER 
1121 85a6 dd 68                        STD  CURLIN         SAVE IN CURLIN 
1122 85a8 9f 7c                        STX  CHARAD         SAVE ADDRESS OF FIRST BYTE OF LINE 
1123 85aa bd a4 b3           LADC0     JSR  GETNCH         GET A CHARACTER FROM BASIC 
1124 85ad 8d 02                        BSR  LADC6          GO PROCESS COMMAND 
1125 85af 20 d5                        BRA  LAD9E          GO BACK TO MAIN LOOP 
1126 85b1 27 32              LADC6     BEQ  LADEA          RETURN IF END OF LINE (RTS - was BEQ LAE40) 
1127 85b3 4d                           TSTA                CHECK FOR TOKEN - BIT 7 SET (NEGATIVE) 
1128 85b4 10 2a 01 d0                  LBPL LET            BRANCH IF NOT A TOKEN - GO DO A ‘LET’ WHICH 
1129                         *                             IS THE ‘DEFAULT’ TOKEN FOR MICROSOFT BASIC 
1130 85b8 81 ff                        CMPA #$FF           SECONDARY TOKEN 
1131 85ba 27 17                        BEQ  SECTOK          
1132 85bc 81 a3                        CMPA #$A3           SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC 
1133 85be 22 0b                        BHI  LADDC          BRANCH IF > A BASIC COMMAND 
1134 85c0 9e ae                        LDX  COMVEC+3       GET ADDRESS OF BASIC’S COMMAND TABLE 
1135 85c2 48                 LADD4     ASLA                X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7 
1136 85c3 1f 89                        TFR  A,B            SAVE COMMAND OFFSET IN ACCB 
1137 85c5 3a                           ABX                 NON X POINTS TO COMMAND JUMP ADDR 
1138 85c6 bd a4 b3                     JSR  GETNCH         GET AN INPUT CHAR 
1139                         *                              
1140                         * HERE IS WHERE WE BRANCH TO DO A ‘COMMAND’                      
1141 85c9 6e 94                        JMP  [,X]           GO DO A COMMAND 
1142 85cb 81 b4              LADDC     CMPA #$B4           $B4 IS HIGHEST BASIC TOKEN 
1143 85cd 23 cc                        BLS  LADB1          ‘SYNTAX ERROR’ IF NON-EXECUTABLE TOKEN 
1144 85cf 6e 9f 00 b8                  JMP  [COMVEC+13]    JUMP TO AN EX BAS COMMAND 
1145                         SECTOK                         
1146 85d3 bd a4 b3                     JSR  GETNCH         GET AN INPUT CHAR 
1147 85d6 81 97                        CMPA #$97           TOKEN FOR "MID$" 
1148 85d8 10 27 15 6c                  LBEQ L86D6          PROCESS MID$ REPLACEMENT 
1149 85dc 7e 8a 5f                     JMP  LB277          SYNTAX ERROR 
1150                                                        
1151                         *                              
1152                         * RESTORE                      
1153 85df 9e 19              RESTOR    LDX  TXTTAB         BEGINNING OF PROGRAM ADDRESS 
1154 85e1 30 1f                        LEAX -1,X           MOVE TO ONE BYTE BEFORE PROGRAM 
1155 85e3 9f 33              LADE8     STX  DATPTR         SAVE NEW DATA POINTER 
1156 85e5 39                 LADEA     RTS                  
1157                         *                              
1158                         * BREAK CHECK                      
1159 85e6 bd 81 04           LADEB     JSR  LA1C1          GET A KEYSTROKE ENTRY 
1160 85e9 27 0a                        BEQ  LADFA          RETURN IF NO INPUT 
1161 85eb 81 03              LADF0     CMPA #3             CONTROL C? (BREAK) 
1162 85ed 27 13                        BEQ  STOP           YES 
1163 85ef 81 13                        CMPA #$13           CONTROL S? (PAUSE) 
1164 85f1 27 03                        BEQ  LADFB          YES 
1165 85f3 97 73                        STA  IKEYIM         SAVE KEYSTROKE IN INKEY IMAGE 
1166 85f5 39                 LADFA     RTS                  
1167 85f6 bd 81 04           LADFB     JSR  KEYIN          GET A KEY 
1168 85f9 27 fb                        BEQ  LADFB          BRANCH IF NO KEY DOWN 
1169 85fb 20 ee                        BRA  LADF0          CONTINUE - DO A BREAK CHECK 
1170                         *                              
1171                         * END                          
1172 85fd bd a4 b9           END       JSR  GETCCH         GET CURRENT INPUT CHAR 
1173 8600 20 02                        BRA  LAE0B           
1174                         *                              
1175                         * STOP                         
1176 8602 1a 01              STOP      ORCC #$01           SET CARRY FLAG 
1177 8604 26 31              LAE0B     BNE  LAE40          BRANCH IF ARGUMENT EXISTS 
1178 8606 9e 7c                        LDX  CHARAD         * SAVE CURRENT POSITION OF 
1179 8608 9f 2f                        STX  TINPTR         * BASIC’S INPUT POINTER 
1180 860a 06 00              LAE11     ROR  ENDFLG         ROTATE CARRY INTO BIT 7 OF STOP/END FLAG 
1181 860c 32 62                        LEAS 2,S            PURGE RETURN ADDRESS OFF STACK 
1182 860e 9e 68              LAE15     LDX  CURLIN         GET CURRENT LINE NUMBER 
1183 8610 8c ff ff                     CMPX #$FFFF         DIRECT MODE? 
1184 8613 27 06                        BEQ  LAE22          YES 
1185 8615 9f 29                        STX  OLDTXT         SAVE CURRENT LINE NUMBER 
1186 8617 9e 2f                        LDX  TINPTR         * GET AND SAVE CURRENT POSITION 
1187 8619 9f 2d                        STX  OLDPTR         * OF BASIC’S INPUT POINTER 
1188                         LAE22                          
1189 861b 8e 83 ec                     LDX  #LABF2-1       POINT TO CR, ‘BREAK’ MESSAGE 
1190 861e 0d 00                        TST  ENDFLG         CHECK STOP/END FLAG 
1191 8620 10 2a fe 40                  LBPL LAC73          BRANCH TO MAIN LOOP OF BASIC IF END 
1192 8624 7e 84 59                     JMP  LAC68          PRINT ‘BREAK AT ####’ AND GO TO 
1193                         *                             BASIC’S MAIN LOOP IF ‘STOP’ 
1194                                                        
1195                         * CONT                         
1196 8627 26 0e              CONT      BNE  LAE40          RETURN IF ARGUMENT GIVEN 
1197 8629 c6 20                        LDB  #2*16          ‘CAN’T CONTINUE’ ERROR 
1198 862b 9e 2d                        LDX  OLDPTR         GET CONTINUE ADDRESS (INPUT POINTER) 
1199 862d 10 27 fe 10                  LBEQ LAC46          ‘CN’ ERROR IF CONTINUE ADDRESS = 0 
1200 8631 9f 7c                        STX  CHARAD         RESET BASIC’S INPUT POINTER 
1201 8633 9e 29                        LDX  OLDTXT         GET LINE NUMBER 
1202 8635 9f 68                        STX  CURLIN         RESET CURRENT LINE NUMBER 
1203 8637 39                 LAE40     RTS                  
1204                         *                              
1205                         * CLEAR                        
1206 8638 27 2d              CLEAR     BEQ  LAE6F          BRANCH IF NO ARGUMENT 
1207 863a bd 8b d2                     JSR  LB3E6          EVALUATE ARGUMENT 
1208 863d 34 06                        PSHS B,A            SAVE AMOUNT OF STRING SPACE ON STACK 
1209 863f 9e 27                        LDX  MEMSIZ         GET CURRENT TOP OF CLEARED SPACE 
1210 8641 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
1211 8644 27 0c                        BEQ  LAE5A          BRANCH IF NO NEW TOP OF CLEARED SPACE 
1212 8646 bd 8a 54                     JSR  LB26D          SYNTAX CHECK FOR COMMA 
1213 8649 bd 8f 2e                     JSR  LB73D          EVALUATE EXPRESSlON; RETURN VALUE IN X 
1214 864c 30 1f                        LEAX -1,X           X = TOP OF CLEARED SPACE 
1215 864e 9c 71                        CMPX TOPRAM         COMPARE TO TOP OF RAM 
1216 8650 22 18                        BHI  LAE72          ‘OM’ ERROR IF > TOP OF RAM 
1217 8652 1f 10              LAE5A     TFR  X,D            ACCD = TOP OF CLEARED SPACE 
1218 8654 a3 e1                        SUBD ,S++           SUBTRACT OUT AMOUNT OF CLEARED SPACE 
1219 8656 25 12                        BCS  LAE72          ‘OM’ ERROR IF FREE MEM < 0 
1220 8658 1f 03                        TFR  D,U            U = BOTTOM OF CLEARED SPACE 
1221 865a 83 00 3a                     SUBD #STKBUF        SUBTRACT OUT STACK BUFFER 
1222 865d 25 0b                        BCS  LAE72          ‘OM’ ERROR IF FREE MEM < 0 
1223 865f 93 1b                        SUBD VARTAB         SUBTRACT OUT START OF VARIABLES 
1224 8661 25 07                        BCS  LAE72          ‘OM’ ERROR IF FREE MEM < 0 
1225 8663 df 21                        STU  FRETOP         SAVE NEW BOTTOM OF CLEARED SPACE 
1226 8665 9f 27                        STX  MEMSIZ         SAVE NEW TOP OF CLEARED SPACE 
1227 8667 7e 85 0c           LAE6F     JMP  LAD26          ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC 
1228 866a 7e 84 3f           LAE72     JMP  LAC44          ‘OM’ ERROR 
1229                         *                              
1230                         * RUN                          
1231 866d 9d f5              RUN       JSR  RVEC18         HOOK INTO RAM 
1232 866f bd a4 b9                     JSR  GETCCH         * GET CURRENT INPUT CHARACTER 
1233 8672 10 27 fe 91                  LBEQ LAD21          * IF NO LINE NUMBER 
1234 8676 bd 85 0c                     JSR  LAD26          ERASE ALL VARIABLES 
1235 8679 20 1a                        BRA  LAE9F          ‘GOTO’ THE RUN ADDRESS 
1236                         *                              
1237                         * GO                           
1238 867b 1f 89              GO        TFR  A,B            SAVE INPUT CHARACTER IN ACCB 
1239 867d bd a4 b3           LAE88     JSR  GETNCH         GET A CHARACTER FROM BASIC 
1240 8680 c1 a5                        CMPB #$A5           ‘TO’ TOKEN 
1241 8682 27 16                        BEQ  LAEA4          BRANCH IF GOTO 
1242 8684 c1 a6                        CMPB #$A6           ‘SUB’ TOKEN 
1243 8686 26 46                        BNE  LAED7          ‘SYNTAX ERROR’ IF NEITHER 
1244 8688 c6 03                        LDB  #3             =ROOM FOR 6 
1245 868a bd 84 2e                     JSR  LAC33          =BYTES ON STACK? 
1246 868d de 7c                        LDU  CHARAD         * SAVE CURRENT BASIC INPUT POINTER, LINE 
1247 868f 9e 68                        LDX  CURLIN         * NUMBER AND SUB TOKEN ON STACK 
1248 8691 86 a6                        LDA  #$A6           * 
1249 8693 34 52                        PSHS U,X,A          * 
1250 8695 8d 03              LAE9F     BSR  LAEA4          GO DO A ‘GOTO’ 
1251 8697 7e 85 86                     JMP  LAD9E          JUMP BACK TO BASIC’S MAIN LOOP 
1252                         * GOTO                         
1253 869a bd a4 b9           LAEA4     JSR  GETCCH         GET CURRENT INPUT CHAR 
1254 869d bd 87 65                     JSR  LAF67          GET LINE NUMBER TO BINARY IN BINVAL 
1255 86a0 8d 40                        BSR  LAEEB          ADVANCE BASIC’S POINTER TO END OF LINE 
1256 86a2 30 01                        LEAX $01,X          POINT TO START OF NEXT LINE 
1257 86a4 dc 2b                        LDD  BINVAL         GET THE LINE NUMBER TO RUN 
1258 86a6 10 93 68                     CMPD CURLIN         COMPARE TO CURRENT LINE NUMBER 
1259 86a9 22 02                        BHI  LAEB6          IF REO’D LINE NUMBER IS > CURRENT LINE NUMBER, 
1260                         *              DON’T START LOOKING FROM  
1261                         *              START OF PROGRAM  
1262 86ab 9e 19                        LDX  TXTTAB         BEGINNING OF PROGRAM 
1263 86ad bd 84 eb           LAEB6     JSR  LAD05          GO FIND A LINE NUMBER 
1264 86b0 25 17                        BCS  LAED2          ‘UNDEFINED LINE NUMBER’ 
1265 86b2 30 1f              LAEBB     LEAX -1,X           MOVE BACK TO JUST BEFORE START OF LINE 
1266 86b4 9f 7c                        STX  CHARAD         RESET BASIC’S INPUT POINTER 
1267 86b6 39                 LAEBF     RTS                  
1268                         *                              
1269                         * RETURN                       
1270 86b7 26 fd              RETURN    BNE  LAEBF          EXIT ROUTINE IF ARGUMENT GIVEN 
1271 86b9 86 ff                        LDA  #$FF           * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF 
1272 86bb 97 3b                        STA  VARDES         * VARDES WHICH WILL CAUSE ‘FOR/NEXT’ DATA ON THE 
1273                         *              STACK TO BE IGNORED  
1274 86bd bd 83 f4                     JSR  LABF9          CHECK FOR RETURN DATA ON THE STACK 
1275 86c0 1f 14                        TFR  X,S            RESET STACK POINTER - PURGE TWO RETURN ADDRESSES 
1276                         *              FROM THE STACK  
1277 86c2 81 26                        CMPA #$A6-$80       SUB TOKEN - $80 
1278 86c4 27 0b                        BEQ  LAEDA          BRANCH IF ‘RETURN’ FROM SUBROUTINE 
1279 86c6 c6 04                        LDB  #2*2           ERROR #2 ‘RETURN WITHOUT GOSUB’ 
1280 86c8 8c                           FCB  SKP2           SKIP TWO BYTES 
1281 86c9 c6 0e              LAED2     LDB  #7*2           ERROR #7 ‘UNDEFINED LINE NUMBER’ 
1282 86cb 7e 84 41                     JMP  LAC46          JUMP TO ERROR HANDLER 
1283 86ce 7e 8a 5f           LAED7     JMP  LB277          ‘SYNTAX ERROR’ 
1284 86d1 35 52              LAEDA     PULS A,X,U          * RESTORE VALUES OF CURRENT LINE NUMBER AND 
1285 86d3 9f 68                        STX  CURLIN         * BASIC’S INPUT POINTER FOR THIS SUBROUTINE 
1286 86d5 df 7c                        STU  CHARAD         * AND LOAD ACCA WITH SUB TOKEN ($A6) 
1287                         *                              
1288                         * DATA                         
1289 86d7 8d 06              DATA      BSR  LAEE8          MOVE INPUT POINTER TO END OF SUBLINE OR LINE 
1290 86d9 8c                           FCB  SKP2           SKIP 2 BYTES 
1291                                                        
1292                         * REM, ELSE                      
1293                         ELSE                           
1294 86da 8d 06              REM       BSR  LAEEB          MOVE INPUT POINTER TO END OF LINE 
1295 86dc 9f 7c                        STX  CHARAD         RESET BASIC’S INPUT POINTER 
1296 86de 39                 LAEE7     RTS                  
1297                         * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE                      
1298 86df c6 3a              LAEE8     LDB  #':'            COLON = SUBLINE TERMINATOR CHARACTER 
1299 86e1 86                 LAEEA     FCB  SKP1LD         SKPILD SKIP ONE BYTE; LDA #$5F 
1300                         * ADVANCE BASIC’S INPUT POINTER TO END OF                      
1301                         * LINE - RETURN ADDRESS OF END OF LINE+1 IN X                      
1302 86e2 5f                 LAEEB     CLRB                0 = LINE TERMINATOR CHARACTER 
1303 86e3 d7 01                        STB  CHARAC         TEMP STORE PRIMARY TERMINATOR CHARACTER 
1304 86e5 5f                           CLRB                0 (END OF LINE) = ALTERNATE TERM. CHAR. 
1305 86e6 9e 7c                        LDX  CHARAD         LOAD X W/BASIC’S INPUT POINTER 
1306 86e8 1f 98              LAEF1     TFR  B,A            * CHANGE TERMINATOR CHARACTER 
1307 86ea d6 01                        LDB  CHARAC         * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR 
1308                         *         IN   CHARAC          
1309 86ec 97 01                        STA  CHARAC         SWAP PRIMARY AND SECONDARY TERMINATORS 
1310 86ee a6 84              LAEF7     LDA  ,X             GET NEXT INPUT CHARACTER 
1311 86f0 27 ec                        BEQ  LAEE7          RETURN IF 0 (END OF LINE) 
1312 86f2 34 04                        PSHS B              SAVE TERMINATOR ON STACK 
1313 86f4 a1 e0                        CMPA ,S+            COMPARE TO INPUT CHARACTER 
1314 86f6 27 e6                        BEQ  LAEE7          RETURN IF EQUAL 
1315 86f8 30 01                        LEAX 1,X            MOVE POINTER UP ONE 
1316 86fa 81 22                        CMPA #'"'            CHECK FOR DOUBLE QUOTES 
1317 86fc 27 ea                        BEQ  LAEF1          BRANCH IF " - TOGGLE TERMINATOR CHARACTERS 
1318 86fe 4c                           INCA                * CHECK FOR $FF AND BRANCH IF 
1319 86ff 26 02                        BNE  LAF0C          * NOT SECONDARY TOKEN 
1320 8701 30 01                        LEAX 1,X            MOVE INPUT POINTER 1 MORE IF SECONDARY 
1321 8703 81 86              LAF0C     CMPA #$85+1         TOKEN FOR IF? 
1322 8705 26 e7                        BNE  LAEF7          NO - GET ANOTHER INPUT CHARACTER 
1323 8707 0c 04                        INC  IFCTR          INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY 
1324                         *                             ‘IF’ STATEMENTS ARE NESTED IN ONE LINE 
1325 8709 20 e3                        BRA  LAEF7          GET ANOTHER INPUT CHARACTER 
1326                                                        
1327                         * IF                           
1328 870b bd 89 23           IF        JSR  LB141          EVALUATE NUMERIC EXPRESSION 
1329 870e bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
1330 8711 81 81                        CMPA #$81           TOKEN FOR GO 
1331 8713 27 05                        BEQ  LAF22          TREAT ‘GO’ THE SAME AS ‘THEN’ 
1332 8715 c6 a7                        LDB  #$A7           TOKEN FOR THEN 
1333 8717 bd 8a 56                     JSR  LB26F          DO A SYNTAX CHECK ON ACCB 
1334 871a 96 4f              LAF22     LDA  FP0EXP         CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO 
1335 871c 26 15                        BNE  LAF39          BRANCH IF CONDITION TRUE 
1336 871e 0f 04                        CLR  IFCTR          CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT 
1337                         *                             TO SEARCH FOR IN NESTED ‘IF’ LOOPS 
1338 8720 8d b5              LAF28     BSR  DATA           MOVE BASIC’S POINTER TO END OF SUBLINE 
1339 8722 4d                           TSTA                * CHECK TO SEE IF END OF LINE OR SUBLINE 
1340 8723 27 b9                        BEQ  LAEE7          * AND RETURN IF END OF LINE 
1341 8725 bd a4 b3                     JSR  GETNCH         GET AN INPUT CHARACTER FROM BASIC 
1342 8728 81 84                        CMPA #$84           TOKEN FOR ELSE 
1343 872a 26 f4                        BNE  LAF28          IGNORE ALL DATA EXCEPT ‘ELSE’ UNTIL 
1344                         *                             END OF LINE (ZERO BYTE) 
1345 872c 0a 04                        DEC  IFCTR          CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE 
1346 872e 2a f0                        BPL  LAF28          BRANCH TO SEARCH ANOTHER SUBLINE FOR ‘ELSE’ 
1347 8730 bd a4 b3                     JSR  GETNCH         GET AN INPUT CHARACTER FROM BASIC 
1348 8733 bd a4 b9           LAF39     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
1349 8736 10 25 ff 60                  LBCS LAEA4          BRANCH TO ‘GOTO’ IF NUMERIC CHARACTER 
1350 873a 7e 85 b1                     JMP  LADC6          RETURN TO MAIN INTERPRETATION LOOP 
1351                                                        
1352                         * ON                           
1353 873d bd 8e fa           ON        JSR  LB70B          EVALUATE EXPRESSION 
1354 8740 c6 81                        LDB  #$81           TOKEN FOR GO 
1355 8742 bd 8a 56                     JSR  LB26F          SYNTAX CHECK FOR GO 
1356 8745 34 02                        PSHS A              SAVE NEW TOKEN (TO,SUB) 
1357 8747 81 a6                        CMPA #$A6           TOKEN FOR SUB? 
1358 8749 27 06                        BEQ  LAF54          YES 
1359 874b 81 a5                        CMPA #$A5           TOKEN FOR TO? 
1360 874d 10 26 ff 7d        LAF52     LBNE  LAED7          ‘SYNTAX’ ERROR IF NOT ‘SUB’ OR ‘TO’ 
1361 8751 0a 53              LAF54     DEC  FPA0+3         DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS 
1362                         *                             IS THE ARGUMENT OF THE ‘ON’ STATEMENT 
1363 8753 26 05                        BNE  LAF5D          BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER 
1364 8755 35 04                        PULS B              GET BACK THE TOKEN FOLLOWING ‘GO’ 
1365 8757 7e 86 7d                     JMP  LAE88          GO DO A ‘GOTO’ OR ‘GOSUB’ 
1366 875a bd a4 b3           LAF5D     JSR  GETNCH         GET A CHARACTER FROM BASIC 
1367 875d 8d 06                        BSR  LAF67          CONVERT BASIC LINE NUMBER TO BINARY 
1368 875f 81 2c                        CMPA #','            IS CHARACTER FOLLOWING LINE NUMBER A COMMA? 
1369 8761 27 ee                        BEQ  LAF54          YES 
1370 8763 35 84                        PULS B,PC           IF NOT, FALL THROUGH TO NEXT COMMAND 
1371 8765 9e 74              LAF67     LDX  ZERO           DEFAULT LINE NUMBER OF ZERO 
1372 8767 9f 2b                        STX  BINVAL         SAVE IT IN BINVAL 
1373                         *                              
1374                         * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL                      
1375                         *                              
1376 8769 24 62              LAF6B     BCC  LAFCE          RETURN IF NOT NUMERIC CHARACTER 
1377 876b 80 30                        SUBA #'0'            MASK OFF ASCII 
1378 876d 97 01                        STA  CHARAC         SAVE DIGIT IN VO1 
1379 876f dc 2b                        LDD  BINVAL         GET ACCUMULATED LINE NUMBER VALUE 
1380 8771 81 18                        CMPA #24            LARGEST LINE NUMBER IS $F9FF (63999) - 
1381                         *         (24*256+255)*10+9                 
1382 8773 22 d8                        BHI  LAF52          ‘SYNTAX’ ERROR IF TOO BIG 
1383                         * MULT ACCD X 10                      
1384 8775 58                           ASLB                * 
1385 8776 49                           ROLA                * TIMES 2 
1386 8777 58                           ASLB                = 
1387 8778 49                           ROLA                = TIMES 4 
1388 8779 d3 2b                        ADDD BINVAL         ADD 1 = TIMES 5 
1389 877b 58                           ASLB                * 
1390 877c 49                           ROLA                * TIMES 10 
1391 877d db 01                        ADDB CHARAC         ADD NEXT DIGIT 
1392 877f 89 00                        ADCA #0             PROPAGATE CARRY 
1393 8781 dd 2b                        STD  BINVAL         SAVE NEW ACCUMULATED LINE NUMBER 
1394 8783 bd a4 b3                     JSR  GETNCH         GET NEXT CHARACTER FROM BASIC 
1395 8786 20 e1                        BRA  LAF6B          LOOP- PROCESS NEXT DIGIT 
1396                         *                              
1397                         * LET (EXBAS)                      
1398                         * EVALUATE A NON-TOKEN EXPRESSION                      
1399                         * TARGET = REPLACEMENT                      
1400 8788 bd 8b 3d           LET       JSR  LB357          FIND TARGET VARIABLE DESCRIPTOR 
1401 878b 9f 3b                        STX  VARDES         SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION 
1402 878d c6 b3                        LDB  #$B3           TOKEN FOR "=" 
1403 878f bd 8a 56                     JSR  LB26F          DO A SYNTAX CHECK FOR ‘=‘ 
1404 8792 96 06                        LDA  VALTYP         * GET VARIABLE TYPE AND 
1405 8794 34 02                        PSHS A              * SAVE ON THE STACK 
1406 8796 bd 89 38                     JSR  LB156          EVALUATE EXPRESSION 
1407 8799 35 02                        PULS A              * REGET VARIABLE TYPE OF 1ST EXPRESSION AND 
1408 879b 46                           RORA                * SET CARRY IF STRING 
1409 879c bd 89 2a                     JSR  LB148          TYPE CHECK-TM ERROR IF VARIABLE TYPES ON 
1410                         *                             BOTH SIDES OF EQUALS SIGN NOT THE SAME 
1411 879f 10 27 0c 53                  LBEQ LBC33          GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC 
1412                         * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT                      
1413                         * FPA0+2 INTO THE STRING SPACE. TRANSFER THE                      
1414                         * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES                      
1415                         * DON’T MOVE THE STRING IF IT IS ALREADY IN THE                      
1416                         * STRING SPACE. REMOVE DESCRIPTOR FROM STRING                      
1417                         * STACK IF IT IS LAST ONE ON THE STACK                      
1418 87a3 9e 52              LAFA4     LDX  FPA0+2         POINT X TO DESCRIPTOR OF REPLACEMENT STRING 
1419 87a5 dc 21                        LDD  FRETOP         LOAD ACCD WITH START OF STRING SPACE 
1420 87a7 10 a3 02                     CMPD 2,X            IS THE STRING IN STRING SPACE? 
1421 87aa 24 11                        BCC  LAFBE          BRANCH IF IT’S NOT IN THE STRING SPACE 
1422 87ac 9c 1b                        CMPX VARTAB         COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES 
1423 87ae 25 0d                        BCS  LAFBE          BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES 
1424 87b0 e6 84              LAFB1     LDB  ,X             GET LENGTH OF REPLACEMENT STRING 
1425 87b2 bd 8c fa                     JSR  LB50D          RESERVE ACCB BYTES OF STRING SPACE 
1426 87b5 9e 4d                        LDX  V4D            GET DESCRIPTOR ADDRESS BACK 
1427 87b7 bd 8e 30                     JSR  LB643          MOVE STRING INTO STRING SPACE 
1428 87ba 8e 00 56                     LDX  #STRDES        POINT X TO TEMP STRING DESCRIPTOR ADDRESS 
1429 87bd 9f 4d              LAFBE     STX  V4D            SAVE STRING DESCRIPTOR ADDRESS IN V4D 
1430 87bf bd 8e 62                     JSR  LB675          REMOVE STRING DESCRIPTOR IF LAST ONE 
1431                         *              ON STRING STACK  
1432 87c2 de 4d                        LDU  V4D            POINT U TO REPLACEMENT DESCRIPTOR ADDRESS 
1433 87c4 9e 3b                        LDX  VARDES         GET TARGET DESCRIPTOR ADDRESS 
1434 87c6 37 26                        PULU A,B,Y          GET LENGTH AND START OF REPLACEMENT STRING 
1435 87c8 a7 84                        STA  ,X             * SAVE STRING LENGTH AND START IN 
1436 87ca 10 af 02                     STY  2,X            * TARGET DESCRIPTOR LOCATION 
1437 87cd 39                 LAFCE     RTS                  
1438                                                        
1439 87ce 3f 52 45 44 4f     LAFCF     FCC  "?REDO"        ?REDO MESSAGE 
1440 87d3 0d 00                        FCB  CR,$00          
1441                                                        
1442                         LAFD6                          
1443 87d5 7e 84 41           LAFDC     JMP  LAC46          JMP TO ERROR HANDLER 
1444 87d8 96 09              LAFDF     LDA  INPFLG         = GET THE INPUT FLAG AND BRANCH 
1445 87da 27 07                        BEQ  LAFEA          = IF ‘INPUT’ 
1446 87dc 9e 31                        LDX  DATTXT         * GET LINE NUMBER WHERE THE ERROR OCCURRED 
1447 87de 9f 68                        STX  CURLIN         * AND USE IT AS THE CURRENT LINE NUMBER 
1448 87e0 7e 8a 5f                     JMP  LB277          ‘SYNTAX ERROR’ 
1449 87e3 8e 87 cd           LAFEA     LDX  #LAFCF-1       * POINT X TO ‘?REDO’ AND PRINT 
1450 87e6 bd 91 5f                     JSR  LB99C          * IT ON THE SCREEN 
1451 87e9 9e 2f                        LDX  TINPTR         = GET THE SAVED ABSOLUTE ADDRESS OF 
1452 87eb 9f 7c                        STX  CHARAD         = INPUT POINTER AND RESTORE IT 
1453 87ed 39                           RTS                  
1454                         *                              
1455                         * INPUT                        
1456 87ee c6 16              INPUT     LDB  #11*2          ‘ID’ ERROR 
1457 87f0 9e 68                        LDX  CURLIN         GET CURRENT LINE NUMBER 
1458 87f2 30 01                        LEAX 1,X            ADD ONE 
1459 87f4 27 df                        BEQ  LAFDC          ‘ID’ ERROR BRANCH IF DIRECT MODE 
1460 87f6 8d 01                        BSR  LB00F          GET SOME INPUT DATA - WAS LB002 
1461 87f8 39                           RTS                  
1462 87f9 81 22              LB00F     CMPA #'"'            CHECK FOR PROMPT STRING DELIMITER 
1463 87fb 26 0b                        BNE  LB01E          BRANCH IF NO PROMPT STRING 
1464 87fd bd 8a 2b                     JSR  LB244          PUT PROMPT STRING ON STRING STACK 
1465 8800 c6 3b                        LDB  #';'            * 
1466 8802 bd 8a 56                     JSR  LB26F          * DO A SYNTAX CHECK FOR SEMICOLON 
1467 8805 bd 91 62                     JSR  LB99F          PRINT MESSAGE TO CONSOLE OUT 
1468 8808 8e 01 31           LB01E     LDX  #LINBUF        POINT TO BASIC’S LINE BUFFER 
1469 880b 6f 84                        CLR  ,X             CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA 
1470                         *              IN LINE BUFFER  
1471 880d 8d 06                        BSR  LB02F          INPUT A STRING TO LINE BUFFER 
1472 880f c6 2c                        LDB  #','            * INSERT A COMMA AT THE END 
1473 8811 e7 84                        STB  ,X             * OF THE LINE INPUT BUFFER 
1474 8813 20 16                        BRA  LB049           
1475                         * FILL BASIC’S LINE INPUT BUFFER CONSOLE IN                      
1476 8815 bd 91 72           LB02F     JSR  LB9AF          SEND A "?" TO CONSOLE OUT 
1477 8818 bd 91 6f                     JSR  LB9AC          SEND A ‘SPACE’ TO CONSOLE OUT 
1478 881b bd 81 55           LB035     JSR  LA390          GO READ IN A BASIC LINE 
1479 881e 24 05                        BCC  LB03F          BRANCH IF ENTER KEY ENDED ENTRY 
1480 8820 32 64                        LEAS 4,S            PURGE TWO RETURN ADDRESSES OFF THE STACK 
1481 8822 7e 86 0a                     JMP  LAE11          GO DO A ‘STOP’ IF BREAK KEY ENDED LINE ENTRY 
1482 8825 c6 2e              LB03F     LDB  #2*23          ‘INPUT PAST END OF FILE’ ERROR 
1483 8827 39                           RTS                  
1484                         *                              
1485                         * READ                         
1486 8828 9e 33              READ      LDX  DATPTR         GET ‘READ’ START ADDRESS 
1487 882a 86                           FCB  SKP1LD         SKIP ONE BYTE - LDA #*$4F 
1488 882b 4f                 LB049     CLRA                ‘INPUT’ ENTRY POINT: INPUT FLAG = 0 
1489 882c 97 09                        STA  INPFLG         SET INPUT FLAG; 0 = INPUT: <> 0 = READ 
1490 882e 9f 35                        STX  DATTMP         SAVE ‘READ’ START ADDRESS/’INPUT’ BUFFER START 
1491 8830 bd 8b 3d           LB04E     JSR  LB357          EVALUATE A VARIABLE 
1492 8833 9f 3b                        STX  VARDES         SAVE DESCRIPTOR ADDRESS 
1493 8835 9e 7c                        LDX  CHARAD         * GET BASIC’S INPUT POINTER 
1494 8837 9f 2b                        STX  BINVAL         * AND SAVE IT 
1495 8839 9e 35                        LDX  DATTMP         GET ‘READ’ ADDRESS START/’INPUT’ BUFFER POINTER 
1496 883b a6 84                        LDA  ,X             GET A CHARACTER FROM THE BASIC PROGRAM 
1497 883d 26 0b                        BNE  LB069          BRANCH IF NOT END OF LINE 
1498 883f 96 09                        LDA  INPFLG         * CHECK INPUT FLAG AND BRANCH 
1499 8841 26 56                        BNE  LB0B9          * IF LOOKING FOR DATA (READ) 
1500                         * NO DATA IN ‘INPUT’ LINE BUFFER AND/OR INPUT                      
1501                         * NOT COMING FROM SCREEN                      
1502 8843 9d e3                        JSR  RVEC10         HOOK INTO RAM IF ‘INPUT’ 
1503 8845 bd 91 72                     JSR  LB9AF          SEND A '?' TO CONSOLE OUT 
1504 8848 8d cb                        BSR  LB02F          FILL INPUT BUFFER FROM CONSOLE IN 
1505 884a 9f 7c              LB069     STX  CHARAD         RESET BASIC’S INPUT POINTER 
1506 884c bd a4 b3                     JSR  GETNCH         GET A CHARACTER FROM BASIC 
1507 884f d6 06                        LDB  VALTYP         * CHECK VARIABLE TYPE AND 
1508 8851 27 23                        BEQ  LB098          * BRANCH IF NUMERIC 
1509                         * READ/INPUT A STRING VARIABLE                      
1510 8853 9e 7c                        LDX  CHARAD         LOAD X WITH CURRENT BASIC INPUT POINTER 
1511 8855 97 01                        STA  CHARAC         SAVE CURRENT INPUT CHARACTER 
1512 8857 81 22                        CMPA #'"'            CHECK FOR STRING DELIMITER 
1513 8859 27 0e                        BEQ  LB08B          BRANCH IF STRING DELIMITER 
1514 885b 30 1f                        LEAX -1,X           BACK UP POINTER 
1515 885d 4f                           CLRA                * ZERO = END OF LINE CHARACTER 
1516 885e 97 01                        STA  CHARAC         * SAVE AS TERMINATOR 
1517 8860 bd 81 45                     JSR  LA35F          SET UP PRINT PARAMETERS 
1518 8863 86 3a                        LDA  #':'            END OF SUBLINE CHARACTER 
1519 8865 97 01                        STA  CHARAC         SAVE AS TERMINATOR I 
1520 8867 86 2c                        LDA  #','            COMMA 
1521 8869 97 02              LB08B     STA  ENDCHR         SAVE AS TERMINATOR 2 
1522 886b bd 8d 0b                     JSR  LB51E          STRIP A STRING FROM THE INPUT BUFFER 
1523 886e bd 8a 30                     JSR  LB249          MOVE INPUT POINTER TO END OF STRING 
1524 8871 bd 87 a3                     JSR  LAFA4          PUT A STRING INTO THE STRING SPACE IF NECESSARY 
1525 8874 20 06                        BRA  LB09E          CHECK FOR ANOTHER DATA ITEM 
1526                         * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM                      
1527 8876 bd 94 d5           LB098     JSR  LBD12          CONVERT AN ASCII STRING TO FP NUMBER 
1528 8879 bd 93 f6                     JSR  LBC33          PACK FPA0 AND STORE IT IN ADDRESS IN VARDES - 
1529                         *                             INPUT OR READ DATA ITEM 
1530 887c bd a4 b9           LB09E     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
1531 887f 27 06                        BEQ  LB0A8          BRANCH IF END OF LINE 
1532 8881 81 2c                        CMPA #','            CHECK FOR A COMMA 
1533 8883 10 26 ff 4e                  LBNE LAFD6          BAD FILE DATA' ERROR OR RETRY 
1534 8887 9e 7c              LB0A8     LDX  CHARAD         * GET CURRENT INPUT 
1535 8889 9f 35                        STX  DATTMP         * POINTER (USED AS A DATA POINTER) AND SAVE IT 
1536 888b 9e 2b                        LDX  BINVAL         * RESET INPUT POINTER TO INPUT OR 
1537 888d 9f 7c                        STX  CHARAD         * READ STATEMENT 
1538 888f bd a4 b9                     JSR  GETCCH         GET CURRENT CHARACTER FROM BASIC 
1539 8892 27 21                        BEQ  LB0D5          BRANCH IF END OF LINE - EXIT COMMAND 
1540 8894 bd 8a 54                     JSR  LB26D          SYNTAX CHECK FOR COMMA 
1541 8897 20 97                        BRA  LB04E          GET ANOTHER INPUT OR READ ITEM 
1542                         * SEARCH FROM ADDRESS IN X FOR                      
1543                         * 1ST OCCURENCE OF THE TOKEN FOR DATA                      
1544 8899 9f 7c              LB0B9     STX  CHARAD         RESET BASIC’S INPUT POINTER 
1545 889b bd 86 df                     JSR  LAEE8          SEARCH FOR END OF CURRENT LINE OR SUBLINE 
1546 889e 30 01                        LEAX 1,X            MOVE X ONE PAST END OF LINE 
1547 88a0 4d                           TSTA                CHECK FOR END OF LINE 
1548 88a1 26 0a                        BNE  LB0CD          BRANCH IF END OF SUBLINE 
1549 88a3 c6 06                        LDB  #2*3           ‘OUT OF DATA’ ERROR 
1550 88a5 ee 81                        LDU  ,X++           GET NEXT 2 CHARACTERS 
1551 88a7 27 41                        BEQ  LB10A          ‘OD’ ERROR IF END OF PROGRAM 
1552 88a9 ec 81                        LDD  ,X++           GET BASIC LINE NUMBER AND 
1553 88ab dd 31                        STD  DATTXT         SAVE IT IN DATTXT 
1554 88ad a6 84              LB0CD     LDA  ,X             GET AN INPUT CHARACTER 
1555 88af 81 86                        CMPA #$86           DATA TOKEN? 
1556 88b1 26 e6                        BNE  LB0B9          NO — KEEP LOOKING 
1557 88b3 20 95                        BRA  LB069          YES 
1558                         * EXIT READ AND INPUT COMMANDS                      
1559 88b5 9e 35              LB0D5     LDX  DATTMP         GET DATA POINTER 
1560 88b7 d6 09                        LDB  INPFLG         * CHECK INPUT FLAG 
1561 88b9 10 26 fd 26                  LBNE LADE8          * SAVE NEW DATA POINTER IF READ 
1562 88bd a6 84                        LDA  ,X             = CHECK NEXT CHARACTER IN ‘INPUT’ BUFFER 
1563 88bf 27 06                        BEQ  LB0E7          = 
1564 88c1 8e 88 c7                     LDX  #LB0E8-1       POINT X TO ‘?EXTRA IGNORED’ 
1565 88c4 7e 91 5f                     JMP  LB99C          PRINT THE MESSAGE 
1566 88c7 39                 LB0E7     RTS                  
1567                                                        
1568 88c8 3f 45 58 54 52 41  LB0E8     FCC  "?EXTRA IGNORED" ?EXTRA IGNORED MESSAGE 
     20 49 47 4e 4f 52
     45 44
1569                                                        
1570                                                        
1571 88d6 0d 00                        FCB  CR,$00          
1572                                                        
1573                         * NEXT                         
1574 88d8 26 04              NEXT      BNE  LB0FE          BRANCH IF ARGUMENT GIVEN 
1575 88da 9e 74                        LDX  ZERO           X = 0: DEFAULT FOR NO ARGUMENT 
1576 88dc 20 03                        BRA  LB101           
1577 88de bd 8b 3d           LB0FE     JSR  LB357          EVALUATE AN ALPHA EXPRESSION 
1578 88e1 9f 3b              LB101     STX  VARDES         SAVE VARIABLE DESCRIPTOR POINTER 
1579 88e3 bd 83 f4                     JSR  LABF9          GO SCAN FOR ‘FOR/NEXT’ DATA ON STACK 
1580 88e6 27 04                        BEQ  LB10C          BRANCH IF DATA FOUND 
1581 88e8 c6 00                        LDB  #0             ‘NEXT WITHOUT FOR’ ERROR (SHOULD BE CLRB) 
1582 88ea 20 49              LB10A     BRA  LB153          PROCESS ERROR 
1583 88ec 1f 14              LB10C     TFR  X,S            POINT S TO START OF ‘FOR/NEXT’ DATA 
1584 88ee 30 03                        LEAX 3,X            POINT X TO FP VALUE OF STEP 
1585 88f0 bd 93 d7                     JSR  LBC14          COPY A FP NUMBER FROM (X) TO FPA0 
1586 88f3 a6 68                        LDA  8,S            GET THE DIRECTION OF STEP 
1587 88f5 97 54                        STA  FP0SGN         SAVE IT AS THE SIGN OF FPA0 
1588 88f7 9e 3b                        LDX  VARDES         POINT (X) TO INDEX VARIABLE DESCRIPTOR 
1589 88f9 bd 91 85                     JSR  LB9C2          ADD (X) TO FPA0 (STEP TO INDEX) 
1590 88fc bd 93 f6                     JSR  LBC33          PACK FPA0 AND STORE IT IN ADDRESS 
1591                         *                             CONTAINED IN VARDES 
1592 88ff 30 69                        LEAX 9,S            POINT (X) TO TERMINAL VALUE OF INDEX 
1593 8901 bd 94 59                     JSR  LBC96          COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX 
1594 8904 e0 68                        SUBB 8,S            ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF 
1595                         *                             STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR 
1596                         *                             STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE 
1597 8906 27 0c                        BEQ  LB134          BRANCH IF ‘FOR/NEXT’ LOOP DONE 
1598 8908 ae 6e                        LDX  14,S           * GET LINE NUMBER AND 
1599 890a 9f 68                        STX  CURLIN         * BASIC POINTER OF 
1600 890c ae e8 10                     LDX  16,S           * STATEMENT FOLLOWING THE 
1601 890f 9f 7c                        STX  CHARAD         * PROPER FOR STATEMENT 
1602 8911 7e 85 86           LB131     JMP  LAD9E          JUMP BACK TO COMMAND INTEPR. LOOP 
1603 8914 32 e8 12           LB134     LEAS 18,S           PULL THE ‘FOR-NEXT’ DATA OFF THE STACK 
1604 8917 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
1605 891a 81 2c                        CMPA #','            CHECK FOR ANOTHER ARGUMENT 
1606 891c 26 f3                        BNE  LB131          RETURN IF NONE 
1607 891e bd a4 b3                     JSR  GETNCH         GET NEXT CHARACTER FROM BASIC 
1608 8921 8d bb                        BSR  LB0FE          BSR SIMULATES A CALL TO ‘NEXT’ FROM COMMAND LOOP 
1609                                                        
1610                                                        
1611 8923 8d 13              LB141     BSR  LB156          EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC 
1612 8925 1c fe              LB143     ANDCC #$FE           CLEAR CARRY FLAG 
1613 8927 7d                 LB145     FCB  $7D            OP CODE OF TST $1A01 - SKIP TWO BYTES (DO 
1614                         *              NOT CHANGE CARRY FLAG)  
1615 8928 1a 01              LB146     ORCC #1             SET CARRY 
1616                                                        
1617                         * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR                      
1618                         * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR                      
1619                         * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP                      
1620                         * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC                      
1621                         * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.                      
1622 892a 0d 06              LB148     TST  VALTYP         TEST TYPE FLAG; DO NOT CHANGE CARRY 
1623 892c 25 03                        BCS  LB14F          BRANCH IF STRING 
1624 892e 2a 97                        BPL  LB0E7          RETURN ON PLUS 
1625 8930 8c                           FCB  SKP2           SKIP 2 BYTES - ‘TM’ ERROR 
1626 8931 2b 94              LB14F     BMI  LB0E7          RETURN ON MINUS 
1627 8933 c6 18                        LDB  #12*2          ‘TYPE M1SMATCH’ ERROR 
1628 8935 7e 84 41           LB153     JMP  LAC46          PROCESS ERROR 
1629                         * EVALUATE EXPRESSION                      
1630 8938 8d 70              LB156     BSR  LB1C6          BACK UP INPUT POINTER 
1631 893a 4f                 LB158     CLRA                END OF OPERATION PRECEDENCE FLAG 
1632 893b 8c                           FCB  SKP2           SKIP TWO BYTES 
1633 893c 34 04              LB15A     PSHS B              SAVE FLAG (RELATIONAL OPERATOR FLAG) 
1634 893e 34 02                        PSHS A              SAVE FLAG (PRECEDENCE FLAG) 
1635 8940 c6 01                        LDB  #1             * 
1636 8942 bd 84 2e                     JSR  LAC33          * SEE IF ROOM IN FREE RAM FOR (B) WORDS 
1637 8945 bd 8a 07                     JSR  LB223          GO EVALUATE AN EXPRESSION 
1638 8948 0f 3f                        CLR  TRELFL         RESET RELATIONAL OPERATOR FLAG 
1639 894a bd a4 b9           LB168     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
1640                         * CHECK FOR RELATIONAL OPERATORS                      
1641 894d 80 b2              LB16A     SUBA #$B2           TOKEN FOR > 
1642 894f 25 14                        BCS  LB181          BRANCH IF LESS THAN RELATIONAL OPERATORS 
1643 8951 81 03                        CMPA #3             * 
1644 8953 24 10                        BCC  LB181          * BRANCH IF GREATER THAN RELATIONAL OPERATORS 
1645 8955 81 01                        CMPA #1             SET CARRY IF ‘>‘ 
1646 8957 49                           ROLA                CARRY TO BIT 0 
1647 8958 98 3f                        EORA TRELFL         * CARRY SET IF 
1648 895a 91 3f                        CMPA TRELFL         * TRELFL = ACCA 
1649 895c 25 65                        BCS  LB1DF          BRANCH IF SYNTAX ERROR : == << OR >> 
1650 895e 97 3f                        STA  TRELFL         BIT 0: >, BIT 1 =, BIT 2: < 
1651 8960 bd a4 b3                     JSR  GETNCH         GET AN INPUT CHARACTER 
1652 8963 20 e8                        BRA  LB16A          CHECK FOR ANOTHER RELATIONAL OPERATOR 
1653                         *                              
1654 8965 d6 3f              LB181     LDB  TRELFL         GET RELATIONAL OPERATOR FLAG 
1655 8967 26 33                        BNE  LB1B8          BRANCH IF RELATIONAL COMPARISON 
1656 8969 10 24 00 6b                  LBCC LB1F4          BRANCH IF > RELATIONAL OPERATOR 
1657 896d 8b 07                        ADDA #7             SEVEN ARITHMETIC/LOGICAL OPERATORS 
1658 896f 24 67                        BCC  LB1F4          BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR 
1659 8971 99 06                        ADCA VALTYP         ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER 
1660 8973 10 27 04 85                  LBEQ LB60F          BRANCH IF VALTYP = FF, AND ACCA = ‘+‘ TOKEN - 
1661                         *                             CONCATENATE TWO STRINGS 
1662 8977 89 ff                        ADCA #-1            RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER 
1663 8979 34 02                        PSHS A              * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2 
1664 897b 48                           ASLA                * THEN ADD THE STORED STACK DATA = MULTIPLY 
1665 897c ab e0                        ADDA ,S+            * X 3; 3 BYTE/TABLE ENTRY 
1666 897e 8e 82 25                     LDX  #LAA51         JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS 
1667 8981 30 86                        LEAX A,X            POINT X TO PROPER TABLE 
1668 8983 35 02              LB19F     PULS A              GET PRECEDENCE FLAG FROM STACK 
1669 8985 a1 84                        CMPA ,X             COMPARE TO CURRENT OPERATOR 
1670 8987 24 55                        BCC  LB1FA          BRANCH IF STACK OPERATOR > CURRENT OPERATOR 
1671 8989 8d 9a                        BSR  LB143          ‘TM’ ERROR IF VARIABLE TYPE = STRING 
1672                                                        
1673                         * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.                      
1674 898b 34 02              LB1A7     PSHS A              SAVE PRECEDENCE FLAG 
1675 898d 8d 29                        BSR  LB1D4          PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK 
1676 898f 9e 3d                        LDX  RELPTR         GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR 
1677                         *                             LAST CALCULATED OPERATION 
1678 8991 35 02                        PULS A              GET PRECEDENCE FLAG OF PREVIOUS OPERATION 
1679 8993 26 1d                        BNE  LB1CE          BRANCH IF NOT END OF OPERATION 
1680 8995 4d                           TSTA                CHECK TYPE OF PRECEDENCE FLAG 
1681 8996 10 27 00 6a                  LBEQ LB220          BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION 
1682 899a 20 4b                        BRA  LB203          EVALUATE AN OPERATION 
1683                                                        
1684 899c 08 06              LB1B8     ASL  VALTYP         BIT 7 OF TYPE FLAG TO CARRY 
1685 899e 59                           ROLB                SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0 
1686 899f 8d 09                        BSR  LB1C6          MOVE THE INPUT POINTER BACK ONE 
1687 89a1 8e 89 af                     LDX  #LB1CB         POINT X TO RELATIONAL COMPARISON JUMP TABLE 
1688 89a4 d7 3f                        STB  TRELFL         SAVE RELATIONAL COMPARISON DATA 
1689 89a6 0f 06                        CLR  VALTYP         SET VARIABLE TYPE TO NUMERIC 
1690 89a8 20 d9                        BRA  LB19F          PERFORM OPERATION OR SAVE ON STACK 
1691                                                        
1692 89aa 9e 7c              LB1C6     LDX  CHARAD         * GET BASIC’S INPUT POINTER AND 
1693 89ac 7e 86 b2                     JMP  LAEBB          * MOVE IT BACK ONE 
1694                         * RELATIONAL COMPARISON JUMP TABLE                      
1695 89af 64                 LB1CB     FCB  $64            RELATIONAL COMPARISON FLAG 
1696 89b0 8a d9              LB1CC     FDB  LB2F4          JUMP ADDRESS 
1697                                                        
1698 89b2 a1 84              LB1CE     CMPA ,X             COMPARE PRECEDENCE OF LAST DONE OPERATION TO 
1699                         *         NEXT TO BE DONE OPERATION  
1700 89b4 24 31                        BCC  LB203          EVALUATE OPERATION IF LOWER PRECEDENCE 
1701 89b6 20 d3                        BRA  LB1A7          PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE 
1702                                                        
1703                         * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR                      
1704 89b8 ec 01              LB1D4     LDD  1,X            GET ADDRESS OF OPERATOR ROUTINE 
1705 89ba 34 06                        PSHS B,A            SAVE IT ON THE STACK 
1706 89bc 8d 08                        BSR  LB1E2          PUSH FPA0 ONTO STACK 
1707 89be d6 3f                        LDB  TRELFL         GET BACK RELATIONAL OPERATOR FLAG 
1708 89c0 16 ff 79                     LBRA LB15A          EVALUATE ANOTHER EXPRESSION 
1709 89c3 7e 8a 5f           LB1DF     JMP  LB277          ‘SYNTAX ERROR’ 
1710                         * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT      
1711                         * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA  
1712                         * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA  
1713 89c6 d6 54              LB1E2     LDB  FP0SGN         GET SIGN OF FPA0 MANTISSA 
1714 89c8 a6 84                        LDA  ,X             GET PRECEDENCE CODE TO ACCA 
1715 89ca 35 20              LB1E6     PULS Y              GET RETURN ADDRESS FROM STACK & PUT IT IN Y 
1716 89cc 34 04                        PSHS B              SAVE ACCB ON STACK 
1717 89ce d6 4f              LB1EA     LDB  FP0EXP         * PUSH FPA0 ONTO THE STACK 
1718 89d0 9e 50                        LDX  FPA0           * 
1719 89d2 de 52                        LDU  FPA0+2         * 
1720 89d4 34 54                        PSHS U,X,B          * 
1721 89d6 6e a4                        JMP  ,Y             JUMP TO ADDRESS IN Y 
1722                                                        
1723                         * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ‘)‘ OR END OF LINE                      
1724 89d8 9e 74              LB1F4     LDX  ZERO           POINT X TO DUMMY VALUE (ZERO) 
1725 89da a6 e0                        LDA  ,S+            GET PRECEDENCE FLAG FROM STACK 
1726 89dc 27 26                        BEQ  LB220          BRANCH IF END OF EXPRESSION 
1727 89de 81 64              LB1FA     CMPA #$64           * CHECK FOR RELATIONAL COMPARISON FLAG 
1728 89e0 27 03                        BEQ  LB201          * AND BRANCH IF RELATIONAL COMPARISON 
1729 89e2 bd 89 25                     JSR  LB143          ‘TM’ ERROR IF VARIABLE TYPE = STRING 
1730 89e5 9f 3d              LB201     STX  RELPTR         SAVE POINTER TO OPERATOR ROUTINE 
1731 89e7 35 04              LB203     PULS B              GET RELATIONAL OPERATOR FLAG FROM STACK 
1732 89e9 81 5a                        CMPA #$5A           CHECK FOR ‘NOT’ OPERATOR 
1733 89eb 27 19                        BEQ  LB222          RETURN IF ‘NOT’ - NO RELATIONAL COMPARISON 
1734 89ed 81 7d                        CMPA #$7D           CHECK FOR NEGATION (UNARY) FLAG 
1735 89ef 27 15                        BEQ  LB222          RETURN IF NEGATION - NO RELATIONAL COMPARISON 
1736                                                        
1737                         * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES                      
1738                         * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH                      
1739                         * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR                      
1740                         * TO EVALUATING ROUTINE.                      
1741 89f1 54                           LSRB                = ROTATE VALTYP BIT INTO CARRY 
1742 89f2 d7 0a                        STB  RELFLG         = FLAG AND SAVE NEW RELFLG 
1743 89f4 35 52                        PULS A,X,U          * PULL A FP VALUE OFF OF THE STACK 
1744 89f6 97 5c                        STA  FP1EXP         * AND SAVE IT IN FPA1 
1745 89f8 9f 5d                        STX  FPA1           * 
1746 89fa df 5f                        STU  FPA1+2         * 
1747 89fc 35 04                        PULS B              = GET MANTISSA SIGN AND 
1748 89fe d7 61                        STB  FP1SGN         = SAVE IT IN FPA1 
1749 8a00 d8 54                        EORB FP0SGN         EOR IT WITH FPA1 MANTISSA SIGN 
1750 8a02 d7 62                        STB  RESSGN         SAVE IT IN RESULT SIGN BYTE 
1751 8a04 d6 4f              LB220     LDB  FP0EXP         GET EXPONENT OF FPA0 
1752 8a06 39                 LB222     RTS                  
1753                                                        
1754 8a07 9d ec              LB223     JSR  RVEC15         HOOK INTO RAM 
1755 8a09 bd 9c bd                     JSR  XVEC15          
1756 8a0c 0f 06                        CLR  VALTYP         INITIALIZE TYPE FLAG TO NUMERIC 
1757 8a0e bd a4 b3                     JSR  GETNCH         GET AN INPUT CHAR 
1758 8a11 24 03                        BCC  LB22F          BRANCH IF NOT NUMERIC 
1759 8a13 7e 94 d5           LB22C     JMP  LBD12          CONVERT ASCII STRING TO FLOATING POINT - 
1760                         *         RETURN RESULT IN FPA0  
1761                         * PROCESS A NON NUMERIC FIRST CHARACTER                      
1762 8a16 bd 8b 8d           LB22F     JSR  LB3A2          SET CARRY IF NOT ALPHA 
1763 8a19 24 51                        BCC  LB284          BRANCH IF ALPHA CHARACTER 
1764 8a1b 81 2e                        CMPA #'.'            IS IT ‘.‘ (DECIMAL POINT)? 
1765 8a1d 27 f4                        BEQ  LB22C          CONVERT ASCII STRING TO FLOATING POINT 
1766 8a1f 81 ac                        CMPA #$AC           MINUS TOKEN 
1767 8a21 27 41                        BEQ  LB27C          YES - GO PROCESS THE MINUS OPERATOR 
1768 8a23 81 ab                        CMPA #$AB           PLUS TOKEN 
1769 8a25 27 e0                        BEQ  LB223          YES - GET ANOTHER CHARACTER 
1770 8a27 81 22                        CMPA #'"'            STRING DELIMITER? 
1771 8a29 26 0a                        BNE  LB24E          NO 
1772 8a2b 9e 7c              LB244     LDX  CHARAD         CURRENT BASIC POINTER TO X 
1773 8a2d bd 8d 05                     JSR  LB518          SAVE STRING ON STRING STACK 
1774 8a30 9e 64              LB249     LDX  COEFPT         * GET ADDRESS OF END OF STRING AND 
1775 8a32 9f 7c                        STX  CHARAD         * PUT BASIC’S INPUT POINTER THERE 
1776 8a34 39                           RTS                  
1777 8a35 81 a8              LB24E     CMPA #$A8           NOT TOKEN? 
1778 8a37 26 0d                        BNE  LB25F          NO 
1779                         * PROCESS THE NOT OPERATOR                      
1780 8a39 86 5a                        LDA  #$5A           ‘NOT’ PRECEDENCE FLAG 
1781 8a3b bd 89 3c                     JSR  LB15A          PROCESS OPERATION FOLLOWING ‘NOT’ 
1782 8a3e bd 8b d9                     JSR  INTCNV         CONVERT FPA0 TO INTEGER IN ACCD 
1783 8a41 43                           COMA                * ‘NOT’ THE INTEGER 
1784 8a42 53                           COMB                * 
1785 8a43 7e 8c e1                     JMP  GIVABF         CONVERT ACCD TO FLOATING POINT (FPA0) 
1786 8a46 4c                 LB25F     INCA                CHECK FOR TOKENS PRECEEDED BY $FF 
1787 8a47 27 2f                        BEQ  LB290          IT WAS PRECEEDED BY $FF 
1788 8a49 8d 06              LB262     BSR  LB26A          SYNTAX CHECK FOR A ‘(‘ 
1789 8a4b bd 89 38                     JSR  LB156          EVALUATE EXPRESSIONS WITHIN PARENTHESES AT 
1790                         *         HIGHEST PRECEDENCE      
1791 8a4e c6 29              LB267     LDB  #')'            SYNTAX CHECK FOR ‘)‘ 
1792 8a50 8c                           FCB  SKP2           SKIP 2 BYTES 
1793 8a51 c6 28              LB26A     LDB  #'('            SYNTAX CHECK FOR ‘(‘ 
1794 8a53 8c                           FCB  SKP2           SKIP 2 BYTES 
1795 8a54 c6 2c              LB26D     LDB  #','            SYNTAX CHECK FOR COMMA 
1796 8a56 e1 9f 00 7c        LB26F     CMPB [CHARAD]       * COMPARE ACCB TO CURRENT INPUT 
1797 8a5a 26 03                        BNE  LB277          * CHARACTER - SYNTAX ERROR IF NO MATCH 
1798 8a5c 7e a4 b3                     JMP  GETNCH         GET A CHARACTER FROM BASIC 
1799 8a5f c6 02              LB277     LDB  #2*1           SYNTAX ERROR 
1800 8a61 7e 84 41                     JMP  LAC46          JUMP TO ERROR HANDLER 
1801                                                        
1802                         * PROCESS THE MINUS (UNARY) OPERATOR                      
1803 8a64 86 7d              LB27C     LDA  #$7D           MINUS (UNARY) PRECEDENCE FLAG 
1804 8a66 bd 89 3c                     JSR  LB15A          PROCESS OPERATION FOLLOWING ‘UNARY’ NEGATION 
1805 8a69 7e 96 b1                     JMP  LBEE9          CHANGE SIGN OF FPA0 MANTISSA 
1806                                                        
1807                         * EVALUATE ALPHA EXPRESSION                      
1808 8a6c bd 8b 3d           LB284     JSR  LB357          FIND THE DESCRIPTOR ADDRESS OF A VARIABLE 
1809 8a6f 9f 52              LB287     STX  FPA0+2         SAVE DESCRIPTOR ADDRESS IN FPA0 
1810 8a71 96 06                        LDA  VALTYP         TEST VARIABLE TYPE 
1811 8a73 26 91                        BNE  LB222          RETURN IF STRING 
1812 8a75 7e 93 d7                     JMP  LBC14          COPY A FP NUMBER FROM (X) TO FPA0 
1813                                                        
1814                         * EVALUATING A SECONDARY TOKEN                      
1815 8a78 bd a4 b3           LB290     JSR  GETNCH         GET AN INPUT CHARACTER (SECONDARY TOKEN) 
1816 8a7b 1f 89                        TFR  A,B            SAVE IT IN ACCB 
1817 8a7d 58                           ASLB                X2 & BET RID OF BIT 7 
1818 8a7e bd a4 b3                     JSR  GETNCH         GET ANOTHER INPUT CHARACTER 
1819 8a81 c1 38                        CMPB #2*28          29 SECONDARY FUNCTIONS - 1 
1820 8a83 23 04                        BLS  LB29F          BRANCH IF COLOR BASIC TOKEN 
1821 8a85 6e 9f 00 bd                  JMP  [COMVEC+18]    JUMP TO EXBAS SECONDARY TOKEN HANDLER 
1822 8a89 34 04              LB29F     PSHS B              SAVE TOKEN OFFSET ON STACK 
1823 8a8b c1 2a                        CMPB #2*21          CHECK FOR NUMERIC ARGUMENT TOKEN 
1824 8a8d 25 1e                        BCS  LB2C7          DO SECONDARIES HEX$ OR LESS 
1825 8a8f c1 30                        CMPB #2*24          * 
1826 8a91 24 1c                        BCC  LB2C9          * DO SECONDARIES $92 (INKEY$) OR > 
1827 8a93 8d bc                        BSR  LB26A          SYNTAX CHECK FOR A ‘(‘ 
1828 8a95 a6 e4                        LDA  ,S             GET TOKEN NUMBER 
1829                         * DO SECONDARIES $8E, $8F, $90 (LEFT$, RIGHT$, MID$)                      
1830 8a97 bd 89 38                     JSR  LB156          EVALUATE FIRST STRING IN ARGUMENT 
1831 8a9a 8d b8                        BSR  LB26D          SYNTAX CHECK FOR A COMMA 
1832 8a9c bd 89 28                     JSR  LB146          ‘TM’ ERROR IF NUMERIC VARiABLE 
1833 8a9f 35 02                        PULS A              GET TOKEN OFFSET FROM STACK 
1834 8aa1 de 52                        LDU  FPA0+2         POINT U TO STRING DESCRIPTOR 
1835 8aa3 34 42                        PSHS U,A            SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS 
1836 8aa5 bd 8e fa                     JSR  LB70B          EVALUATE FIRST NUMERIC ARGUMENT 
1837 8aa8 35 02                        PULS A              GET TOKEN OFFSET FROM STACK 
1838 8aaa 34 06                        PSHS B,A            SAVE TOKEN OFFSET AND NUMERIC ARGUMENT 
1839 8aac 8e                           FCB  $8E            OP CODE OF LDX# - SKlP 2 BYTES 
1840 8aad 8d 9a              LB2C7     BSR  LB262          SYNTAX CHECK FOR A ‘(‘ 
1841 8aaf 35 04              LB2C9     PULS B              GET TOKEN OFFSET 
1842 8ab1 9e b3                        LDX  COMVEC+8       GET SECONDARY FUNCTION JUMP TABLE ADDRESS 
1843 8ab3 3a                 LB2CE     ABX                 ADD IN COMMAND OFFSET 
1844                         *                              
1845                         * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION                      
1846 8ab4 ad 94                        JSR  [,X]           GO DO AN SECONDARY FUNCTION 
1847 8ab6 7e 89 25                     JMP  LB143          ‘TM’ ERROR IF VARIABLE TYPE = STRING 
1848                                                        
1849                         * LOGICAL OPERATOR ‘OR’ JUMPS HERE                      
1850 8ab9 86                 LB2D4     FCB  SKP1LD         SKIP ONE BYTE - ‘OR’ FLAG = $4F 
1851                                                        
1852                         * LOGICAL OPERATOR ‘AND’ JUMPS HERE                      
1853 8aba 4f                 LB2D5     CLRA                AND FLAG = 0 
1854 8abb 97 03                        STA  TMPLOC         AND/OR FLAG 
1855 8abd bd 8b d9                     JSR  INTCNV         CONVERT FPA0 INTO AN INTEGER IN ACCD 
1856 8ac0 dd 01                        STD  CHARAC         TEMP SAVE ACCD 
1857 8ac2 bd 94 0d                     JSR  LBC4A          MOVE FPA1 TO FPA0 
1858 8ac5 bd 8b d9                     JSR  INTCNV         CONVERT FPA0 INTO AN INTEGER IN ACCD 
1859 8ac8 0d 03                        TST  TMPLOC         CHECK AND/OR FLAG 
1860 8aca 26 06                        BNE  LB2ED          BRANCH IF OR 
1861 8acc 94 01                        ANDA CHARAC         * ‘AND’ ACCD WITH FPA0 INTEGER 
1862 8ace d4 02                        ANDB ENDCHR         * STORED IN ENDCHR 
1863 8ad0 20 04                        BRA  LB2F1          CONVERT TO FP 
1864 8ad2 9a 01              LB2ED     ORA  CHARAC         * ‘OR’ ACCD WITH FPA0 INTEGER 
1865 8ad4 da 02                        ORB  ENDCHR         * STORED IN CHARAC 
1866 8ad6 7e 8c e1           LB2F1     JMP  GIVABF         CONVERT THE VALUE IN ACCD INTO A FP NUMBER 
1867                                                        
1868                         * RELATIONAL COMPARISON PROCESS HANDLER                      
1869 8ad9 bd 89 2a           LB2F4     JSR  LB148          ‘TM’ ERROR IF TYPE MISMATCH 
1870 8adc 26 10                        BNE  LB309          BRANCH IF STRING VARIABLE 
1871 8ade 96 61                        LDA  FP1SGN         * ‘PACK’ THE MANTISSA 
1872 8ae0 8a 7f                        ORA  #$7F           * SIGN OF FPA1 INTO 
1873 8ae2 94 5d                        ANDA FPA1           * BIT 7 OF THE 
1874 8ae4 97 5d                        STA  FPA1           * MANTISSA MS BYTE 
1875 8ae6 8e 00 5c                     LDX  #FP1EXP        POINT X TO FPA1 
1876 8ae9 bd 94 59                     JSR  LBC96          COMPARE FPA0 TO FPA1 
1877 8aec 20 36                        BRA  LB33F          CHECK TRUTH OF RELATIONAL COMPARISON 
1878                                                        
1879                         * RELATIONAL COMPARISON OF STRINGS                      
1880 8aee 0f 06              LB309     CLR  VALTYP         SET VARIABLE TYPE TO NUMERIC 
1881 8af0 0a 3f                        DEC  TRELFL         REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE 
1882                         *                             DESIRED RELATIONAL COMPARISON DATA 
1883 8af2 bd 8e 44                     JSR  LB657          GET LENGTH AND ADDRESS OF STRING WHOSE 
1884                         *                             DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0 
1885 8af5 d7 56                        STB  STRDES         * SAVE LENGTH AND ADDRESS IN TEMPORARY 
1886 8af7 9f 58                        STX  STRDES+2       * DESCRIPTOR (STRING B) 
1887 8af9 9e 5f                        LDX  FPA1+2         = RETURN LENGTH AND ADDRESS OF STRING 
1888 8afb bd 8e 46                     JSR  LB659          = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2 
1889 8afe 96 56                        LDA  STRDES         LOAD ACCA WITH LENGTH OF STRING B 
1890 8b00 34 04                        PSHS B              SAVE LENGTH A ON STACK 
1891 8b02 a0 e0                        SUBA ,S+            SUBTRACT LENGTH A FROM LENGTH B 
1892 8b04 27 07                        BEQ  LB328          BRANCH IF STRINGS OF EQUAL LENGTH 
1893 8b06 86 01                        LDA  #1             TRUE FLAG 
1894 8b08 24 03                        BCC  LB328          TRUE IF LENGTH B > LENGTH A 
1895 8b0a d6 56                        LDB  STRDES         LOAD ACCB WITH LENGTH B 
1896 8b0c 40                           NEGA                SET FLAG = FALSE (1FF) 
1897 8b0d 97 54              LB328     STA  FP0SGN         SAVE TRUE/FALSE FLAG 
1898 8b0f de 58                        LDU  STRDES+2       POINT U TO START OF STRING 
1899 8b11 5c                           INCB                COMPENSATE FOR THE DECB BELOW 
1900                         * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING                      
1901 8b12 5a                 LB32D     DECB                DECREMENT SHORTER STRING LENGTH 
1902 8b13 26 04                        BNE  LB334          BRANCH IF ALL OF STRING NOT COMPARED 
1903 8b15 d6 54                        LDB  FP0SGN         GET TRUE/FALSE FLAB 
1904 8b17 20 0b                        BRA  LB33F          CHECK TRUTH OF RELATIONAL COMPARISON 
1905 8b19 a6 80              LB334     LDA  ,X+            GET A BYTE FROM STRING A 
1906 8b1b a1 c0                        CMPA ,U+            COMPARE TO STRING B 
1907 8b1d 27 f3                        BEQ  LB32D          CHECK ANOTHER CHARACTER IF = 
1908 8b1f c6 ff                        LDB  #$FF           FALSE FLAG IF STRING A > B 
1909 8b21 24 01                        BCC  LB33F          BRANCH IF STRING A > STRING B 
1910 8b23 50                           NEGB                SET FLAG = TRUE 
1911                                                        
1912                         * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0                      
1913 8b24 cb 01              LB33F     ADDB #1             CONVERT $FF,0,1 TO 0,1,2 
1914 8b26 59                           ROLB                NOW IT’S 1,2,4 FOR > = < 
1915 8b27 d4 0a                        ANDB RELFLG         ‘AND’ THE ACTUAL COMPARISON WITH THE DESIRED - 
1916                         COMPARISON                      
1917 8b29 27 02                        BEQ  LB348          BRANCH IF FALSE (NO MATCHING BITS) 
1918 8b2b c6 ff                        LDB  #$FF           TRUE FLAG 
1919 8b2d 7e 94 3f           LB348     JMP  LBC7C          CONVERT ACCB INTO FP NUMBER IN FPA0 
1920                                                        
1921                         * DIM                          
1922 8b30 bd 8a 54           LB34B     JSR  LB26D          SYNTAX CHECK FOR COMMA 
1923 8b33 c6 01              DIM       LDB  #1             DIMENSION FLAG 
1924 8b35 8d 0a                        BSR  LB35A          SAVE ARRAY SPACE FOR THIS VARIABLE 
1925 8b37 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
1926 8b3a 26 f4                        BNE  LB34B          KEEP DIMENSIONING IF NOT END OF LINE 
1927 8b3c 39                           RTS                  
1928                         * EVALUATE A VARIABLE - RETURN X AND                      
1929                         * VARPTR POINTING TO VARIABLE DESCRIPTOR                      
1930                         * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO                      
1931                         * BYTES ARE THE VARIABLE NAME AND THE NEXT 5                      
1932                         * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE                      
1933                         * FIRST BYTE OF VARlABLE NAME IS SET, THE                      
1934                         * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF                      
1935                         * THE SECOND BYTE OF VARIABLE NAME IS SET, THE                      
1936                         * VARIABLE IS A STRING, OTHERWISE THE VARIABLE                      
1937                         * IS NUMERIC.                      
1938                         * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS                      
1939                         * INSERTED INTO THE VARIABLE SPACE                      
1940 8b3d 5f                 LB357     CLRB                DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY 
1941 8b3e bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
1942 8b41 d7 05              LB35A     STB  DIMFLG         SAVE ARRAY FLAG 
1943                         * ENTRY POINT FOR DEF FN VARIABLE SEARCH                      
1944 8b43 97 37              LB35C     STA  VARNAM         SAVE INPUT CHARACTER 
1945 8b45 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
1946 8b48 8d 43                        BSR  LB3A2          SET CARRY IF NOT ALPHA 
1947 8b4a 10 25 ff 11                  LBCS LB277          SYNTAX ERROR IF NOT ALPHA 
1948 8b4e 5f                           CLRB                DEFAULT 2ND VARIABLE CHARACTER TO ZERO 
1949 8b4f d7 06                        STB  VALTYP         SET VARIABLE TYPE TO NUMERIC 
1950 8b51 bd a4 b3                     JSR  GETNCH         GET ANOTHER CHARACTER FROM BASIC 
1951 8b54 25 04                        BCS  LB371          BRANCH IF NUMERIC (2ND CHARACTER IN 
1952                         *                             VARIABLE MAY BE NUMERIC) 
1953 8b56 8d 35                        BSR  LB3A2          SET CARRY IF NOT ALPHA 
1954 8b58 25 0b                        BCS  LB37B          BRANCH IF NOT ALPHA 
1955 8b5a 1f 89              LB371     TFR  A,B            SAVE 2ND CHARACTER IN ACCB 
1956                         * READ INPUT CHARACTERS UNTIL A NON ALPHA OR                      
1957                         * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS                      
1958                         * IN VARIABLE NAME AFTER THE 1ST TWO                      
1959 8b5c bd a4 b3           LB373     JSR  GETNCH         GET AN INPUT CHARACTER 
1960 8b5f 25 fb                        BCS  LB373          BRANCH IF NUMERIC 
1961 8b61 8d 2a                        BSR  LB3A2          SET CARRY IF NOT ALPHA 
1962 8b63 24 f7                        BCC  LB373          BRANCH IF ALPHA 
1963 8b65 81 24              LB37B     CMPA #'$'            CHECK FOR A STRING VARIABLE 
1964 8b67 26 07                        BNE  LB385          BRANCH IF IT IS NOT A STRING 
1965 8b69 03 06                        COM  VALTYP         SET VARIABLE TYPE TO STRING 
1966 8b6b cb 80                        ADDB #$80           SET BIT 7 OF 2ND CHARACTER (STRING) 
1967 8b6d bd a4 b3                     JSR  GETNCH         GET AN INPUT CHARACTER 
1968 8b70 d7 38              LB385     STB  VARNAM+1       SAVE 2ND CHARACTER IN VARNAM+1 
1969 8b72 9a 08                        ORA  ARYDIS         OR IN THE ARRAY DISABLE FLAG - IF = $80, 
1970                         *              DON’T SEARCH FOR VARIABLES IN THE ARRAYS  
1971 8b74 80 28                        SUBA #'('            IS THIS AN ARRAY VARIABLE? 
1972 8b76 10 27 00 76                  LBEQ LB404          BRANCH IF IT IS 
1973 8b7a 0f 08                        CLR  ARYDIS         RESET THE ARRAY DISABLE FLAG 
1974 8b7c 9e 1b                        LDX  VARTAB         POINT X TO THE START OF VARIABLES 
1975 8b7e dc 37                        LDD  VARNAM         GET VARIABLE IN QUESTION 
1976 8b80 9c 1d              LB395     CMPX ARYTAB         COMPARE X TO THE END OF VARIABLES 
1977 8b82 27 12                        BEQ  LB3AB          BRANCH IF END OF VARIABLES 
1978 8b84 10 a3 81                     CMPD ,X++           * COMPARE VARIABLE IN QUESTION TO CURRENT 
1979 8b87 27 3e                        BEQ  LB3DC          * VARIABLE AND BRANCH IF MATCH 
1980 8b89 30 05                        LEAX 5,X            = MOVE POINTER TO NEXT VARIABLE AND 
1981 8b8b 20 f3                        BRA  LB395          = KEEP LOOKING 
1982                                                        
1983                         * SET CARRY IF NOT UPPER CASE ALPHA                      
1984 8b8d 81 41              LB3A2     CMPA #'A'            * CARRY SET IF < ‘A’ 
1985 8b8f 25 04                        BCS  LB3AA          * 
1986 8b91 80 5b                        SUBA #'Z'+1          = 
1987                         *         SUBA #-('Z'+1)       = CARRY CLEAR IF <= 'Z' 
1988 8b93 80 a5                        FCB  $80,$A5         
1989 8b95 39                 LB3AA     RTS                  
1990                         * PUT A NEW VARIABLE IN TABLE OF VARIABLES                      
1991 8b96 8e 00 74           LB3AB     LDX  #ZERO          POINT X TO ZERO LOCATION 
1992 8b99 ee e4                        LDU  ,S             GET CURRENT RETURN ADDRESS 
1993 8b9b 11 83 8a 6f                  CMPU #LB287         DID WE COME FROM ‘EVALUATE ALPHA EXPR’? 
1994 8b9f 27 28                        BEQ  LB3DE          YES - RETURN A ZERO VALUE 
1995 8ba1 dc 1f                        LDD  ARYEND         * GET END OF ARRAYS ADDRESS AND 
1996 8ba3 dd 43                        STD  V43            * SAVE IT AT V43 
1997 8ba5 c3 00 07                     ADDD #7             = ADD 7 TO END OF ARRAYS (EACH 
1998 8ba8 dd 41                        STD  V41            = VARIABLE = 7 BYTES) AND SAVE AT V41 
1999 8baa 9e 1d                        LDX  ARYTAB         * GET END OF VARIABLES AND SAVE AT V47 
2000 8bac 9f 47                        STX  V47            * 
2001 8bae bd 84 19                     JSR  LAC1E          MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT 
2002                         *         TOP  OF VARIABLES    
2003 8bb1 9e 41                        LDX  V41            = GET NEW END OF ARRAYS AND SAVE IT 
2004 8bb3 9f 1f                        STX  ARYEND         = 
2005 8bb5 9e 45                        LDX  V45            * GET NEW END OF VARIABLES AND SAVE IT 
2006 8bb7 9f 1d                        STX  ARYTAB         * 
2007 8bb9 9e 47                        LDX  V47            GET OLD END OF VARIABLES 
2008 8bbb dc 37                        LDD  VARNAM         GET NEW VARIABLE NAME 
2009 8bbd ed 81                        STD  ,X++           SAVE VARIABLE NAME 
2010 8bbf 4f                           CLRA                * ZERO OUT THE FP VALUE OF THE NUMERIC 
2011 8bc0 5f                           CLRB                * VARIABLE OR THE LENGTH AND ADDRESS 
2012 8bc1 ed 84                        STD  ,X             * OF A STRING VARIABLE 
2013 8bc3 ed 02                        STD  2,X            * 
2014 8bc5 a7 04                        STA  4,X            * 
2015 8bc7 9f 39              LB3DC     STX  VARPTR         STORE ADDRESS OF VARIABLE VALUE 
2016 8bc9 39                 LB3DE     RTS                  
2017                         *                              
2018 8bca 90 80 00 00 00     LB3DF     FCB  $90,$80,$00,$00,$00 * FLOATING POINT -32768 
2019                         *                             SMALLEST SIGNED TWO BYTE INTEGER 
2020                         *                              
2021 8bcf bd a4 b3           LB3E4     JSR  GETNCH         GET AN INPUT CHARACTER FROM BASIC 
2022 8bd2 bd 89 23           LB3E6     JSR  LB141          GO EVALUATE NUMERIC EXPRESSION 
2023 8bd5 96 54              LB3E9     LDA  FP0SGN         GET FPA0 MANTISSA SIGN 
2024 8bd7 2b 5e                        BMI  LB44A          ‘FC’ ERROR IF NEGATIVE NUMBER 
2025                                                        
2026                                                        
2027 8bd9 bd 89 25           INTCNV    JSR  LB143          ‘TM’ ERROR IF STRING VARIABLE 
2028 8bdc 96 4f                        LDA  FP0EXP         GET FPA0 EXPONENT 
2029 8bde 81 90                        CMPA #$90           * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND 
2030 8be0 25 08                        BCS  LB3FE          * BRANCH IF FPA0 < 32768 
2031 8be2 8e 8b ca                     LDX  #LB3DF         POINT X TO FP VALUE OF -32768 
2032 8be5 bd 94 59                     JSR  LBC96          COMPARE -32768 TO FPA0 
2033 8be8 26 4d                        BNE  LB44A          ‘FC’ ERROR IF NOT = 
2034 8bea bd 94 8b           LB3FE     JSR  LBCC8          CONVERT FPA0 TO A TWO BYTE INTEGER 
2035 8bed dc 52                        LDD  FPA0+2         GET THE INTEGER 
2036 8bef 39                           RTS                  
2037                         * EVALUATE AN ARRAY VARIABLE                      
2038 8bf0 dc 05              LB404     LDD  DIMFLG         GET ARRAY FLAG AND VARIABLE TYPE 
2039 8bf2 34 06                        PSHS B,A            SAVE THEM ON STACK 
2040 8bf4 12                           NOP                 DEAD SPACE CAUSED BY 1.2 REVISION 
2041 8bf5 5f                           CLRB                RESET DIMENSION COUNTER 
2042 8bf6 9e 37              LB40A     LDX  VARNAM         GET VARIABLE NAME 
2043 8bf8 34 14                        PSHS X,B            SAVE VARIABLE NAME AND DIMENSION COUNTER 
2044 8bfa 8d d3                        BSR  LB3E4          EVALUATE EXPRESSION (DIMENSlON LENGTH) 
2045 8bfc 35 34                        PULS B,X,Y          PULL OFF VARIABLE NAME, DIMENSlON COUNTER, 
2046                         *                             ARRAY FLAG 
2047 8bfe 9f 37                        STX  VARNAM         SAVE VARIABLE NAME AND VARIABLE TYPE 
2048 8c00 de 52                        LDU  FPA0+2         GET DIMENSION LENGTH 
2049 8c02 34 60                        PSHS U,Y            SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE 
2050 8c04 5c                           INCB                INCREASE DIMENSION COUNTER 
2051 8c05 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
2052 8c08 81 2c                        CMPA #','            CHECK FOR ANOTHER DIMENSION 
2053 8c0a 27 ea                        BEQ  LB40A          BRANCH IF MORE 
2054 8c0c d7 03                        STB  TMPLOC         SAVE DIMENSION COUNTER 
2055 8c0e bd 8a 4e                     JSR  LB267          SYNTAX CHECK FOR A ‘)‘ 
2056 8c11 35 06                        PULS A,B            * RESTORE VARIABLE TYPE AND ARRAY 
2057 8c13 dd 05                        STD  DIMFLG         * FLAG - LEAVE DIMENSION LENGTH ON STACK 
2058 8c15 9e 1d                        LDX  ARYTAB         GET START OF ARRAYS 
2059 8c17 9c 1f              LB42A     CMPX ARYEND         COMPARE TO END OF ARRAYS 
2060 8c19 27 21                        BEQ  LB44F          BRANCH IF NO MATCH FOUND 
2061 8c1b dc 37                        LDD  VARNAM         GET VARIABLE IN QUESTION 
2062 8c1d 10 a3 84                     CMPD ,X             COMPARE TO CURRENT VARIABLE 
2063 8c20 27 06                        BEQ  LB43B          BRANCH IF = 
2064 8c22 ec 02                        LDD  2,X            GET OFFSET TO NEXT ARRAY VARIABLE 
2065 8c24 30 8b                        LEAX D,X            ADD TO CURRENT POINTER 
2066 8c26 20 ef                        BRA  LB42A          KEEP SEARCHING 
2067 8c28 c6 12              LB43B     LDB  #2*9           ‘REDIMENSIONED ARRAY’ ERROR 
2068 8c2a 96 05                        LDA  DIMFLG         * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING 
2069 8c2c 26 0b                        BNE  LB44C          * TO REDIMENSION AN ARRAY 
2070 8c2e d6 03                        LDB  TMPLOC         GET NUMBER OF DIMENSIONS IN ARRAY 
2071 8c30 e1 04                        CMPB 4,X            COMPARE TO THIS ARRAYS DIMENSIONS 
2072 8c32 27 59                        BEQ  LB4A0          BRANCH IF = 
2073 8c34 c6 10              LB447     LDB  #8*2           ‘BAD SUBSCRIPT’ 
2074 8c36 8c                           FCB  SKP2           SKIP TWO BYTES 
2075 8c37 c6 08              LB44A     LDB  #4*2           ‘ILLEGAL FUNCTION CALL’ 
2076 8c39 7e 84 41           LB44C     JMP  LAC46          JUMP TO ERROR SERVICING ROUTINE 
2077                                                        
2078                         * INSERT A NEW ARRAY INTO ARRAY VARIABLES                      
2079                         * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-                      
2080                         * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE                      
2081                         * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED                      
2082                         * AS FOLLOWS: BYTES 0,1:VARIABLE’S NAME; 2,3:TOTAL LENGTH                      
2083                         * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-                      
2084                         * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-                      
2085                         * SION 2;… 4+N,5+N:LENGTH OF DIMENSION N.                      
2086                                                        
2087 8c3c cc 00 05           LB44F     LDD  #5             * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT 
2088 8c3f dd 64                        STD  COEFPT         * 
2089 8c41 dc 37                        LDD  VARNAM         = GET NAME OF ARRAY AND SAVE IN 
2090 8c43 ed 84                        STD  ,X             = FIRST 2 BYTES OF DESCRIPTOR 
2091 8c45 d6 03                        LDB  TMPLOC         GET NUMBER OF DIMENSIONS AND SAVE IN 
2092 8c47 e7 04                        STB  4,X            * 5TH BYTE OF DESCRIPTOR 
2093 8c49 bd 84 2e                     JSR  LAC33          CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM 
2094 8c4c 9f 41                        STX  V41            TEMPORARILY SAVE DESCRIPTOR ADDRESS 
2095 8c4e c6 0b              LB461     LDB  #11            * DEFAULT DIMENSION VALUE:X(10) 
2096 8c50 4f                           CLRA                * 
2097 8c51 0d 05                        TST  DIMFLG         = CHECK ARRAY FLAG AND BRANCH IF 
2098 8c53 27 05                        BEQ  LB46D          = NOT DIMENSIONING AN ARRAY 
2099 8c55 35 06                        PULS A,B            GET DIMENSION LENGTH 
2100 8c57 c3 00 01                     ADDD #1             ADD ONE (X(0) HAS A LENGTH OF ONE) 
2101 8c5a ed 05              LB46D     STD  5,X            SAVE LENGTH OF ARRAY DIMENSION 
2102 8c5c 8d 5d                        BSR  LB4CE          MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH 
2103                         *                             OF NEW DIMENSION 
2104 8c5e dd 64                        STD  COEFPT         TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE 
2105 8c60 30 02                        LEAX 2,X            BUMP POINTER UP TWO 
2106 8c62 0a 03                        DEC  TMPLOC         * DECREMENT DIMENSION COUNTER AND BRANCH IF 
2107 8c64 26 e8                        BNE  LB461          * NOT DONE WITH ALL DIMENSIONS 
2108 8c66 9f 0f                        STX  TEMPTR         SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5) 
2109 8c68 d3 0f                        ADDD TEMPTR         ADD TOTAL SIZE OF NEW ARRAY 
2110 8c6a 10 25 f7 d1                  LBCS LAC44          ‘OM’ ERROR IF > $FFFF 
2111 8c6e 1f 01                        TFR  D,X            SAVE END OF ARRAY IN X 
2112 8c70 bd 84 32                     JSR  LAC37          MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY 
2113 8c73 83 00 35                     SUBD #STKBUF-5      SUBTRACT OUT THE (STACK BUFFER - 5) 
2114 8c76 dd 1f                        STD  ARYEND         SAVE NEW END OF ARRAYS 
2115 8c78 4f                           CLRA                ZERO = TERMINATOR BYTE 
2116 8c79 30 1f              LB48C     LEAX -1,X           * STORE TWO TERMINATOR BYTES AT 
2117 8c7b a7 05                        STA  5,X            * THE END OF THE ARRAY DESCRIPTOR 
2118 8c7d 9c 0f                        CMPX TEMPTR         * 
2119 8c7f 26 f8                        BNE  LB48C          * 
2120 8c81 9e 41                        LDX  V41            GET ADDRESS OF START OF DESCRIPTOR 
2121 8c83 96 1f                        LDA  ARYEND         GET MSB OF END OF ARRAYS; LSB ALREADY THERE 
2122 8c85 93 41                        SUBD V41            SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR 
2123 8c87 ed 02                        STD  2,X            SAVE LENGTH OF (ARRAY AND DESCRIPTOR) 
2124 8c89 96 05                        LDA  DIMFLG         * GET ARRAY FLAG AND BRANCH 
2125 8c8b 26 2d                        BNE  LB4CD          * BACK IF DIMENSIONING 
2126                         * CALCULATE POINTER TO CORRECT ELEMENT                      
2127 8c8d e6 04              LB4A0     LDB  4,X            GET THE NUMBER OF DIMENSIONS 
2128 8c8f d7 03                        STB  TMPLOC         TEMPORARILY SAVE 
2129 8c91 4f                           CLRA                * INITIALIZE POINTER 
2130 8c92 5f                           CLRB                * TO ZERO 
2131 8c93 dd 64              LB4A6     STD  COEFPT         SAVE ACCUMULATED POINTER 
2132 8c95 35 06                        PULS A,B            * PULL DIMENSION ARGUMENT OFF THE 
2133 8c97 dd 52                        STD  FPA0+2         * STACK AND SAVE IT 
2134 8c99 10 a3 05                     CMPD 5,X            COMPARE TO STORED ‘DIM’ ARGUMENT 
2135 8c9c 24 3a                        BCC  LB4EB          ‘BS’ ERROR IF > = "DIM" ARGUMENT 
2136 8c9e de 64                        LDU  COEFPT         * GET ACCUMULATED POINTER AND 
2137 8ca0 27 04                        BEQ  LB4B9          * BRANCH IF 1ST DIMENSION 
2138 8ca2 8d 17                        BSR  LB4CE          = MULTIPLY ACCUMULATED POINTER AND DIMENSION 
2139 8ca4 d3 52                        ADDD FPA0+2         = LENGTH AND ADD TO CURRENT ARGUMENT 
2140 8ca6 30 02              LB4B9     LEAX 2,X            MOVE POINTER TO NEXT DIMENSION 
2141 8ca8 0a 03                        DEC  TMPLOC         * DECREMENT DIMENSION COUNTER AND 
2142 8caa 26 e7                        BNE  LB4A6          * BRANCH IF ANY DIMENSIONS LEFT 
2143                         * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE                      
2144 8cac ed e3                        STD  ,--S            
2145 8cae 58                           ASLB                 
2146 8caf 49                           ROLA                TIMES 2 
2147 8cb0 58                           ASLB                 
2148 8cb1 49                           ROLA                TIMES 4 
2149 8cb2 e3 e1                        ADDD ,S++           TIMES 5 
2150 8cb4 30 8b                        LEAX D,X            ADD OFFSET TO START OF ARRAY 
2151 8cb6 30 05                        LEAX 5,X            ADJUST POINTER FOR SIZE OF DESCRIPTOR 
2152 8cb8 9f 39                        STX  VARPTR         SAVE POINTER TO ARRAY VALUE 
2153 8cba 39                 LB4CD     RTS                  
2154                         * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER                      
2155                         * IN COEFPT. RETURN RESULT IN ACCD, BS ERROR IF > $FFFF                      
2156 8cbb 86 10              LB4CE     LDA  #16            16 SHIFTS TO DO A MULTIPLY 
2157 8cbd 97 45                        STA  V45            SHIFT COUNTER 
2158 8cbf ec 05                        LDD  5,X            * GET SIZE OF DIMENSION 
2159 8cc1 dd 17                        STD  BOTSTK         * AND SAVE IT 
2160 8cc3 4f                           CLRA                * ZERO 
2161 8cc4 5f                           CLRB                * ACCD 
2162 8cc5 58                 LB4D8     ASLB                = SHIFT ACCB LEFT 
2163 8cc6 49                           ROLA                = ONE BIT 
2164 8cc7 25 0f                        BCS  LB4EB          BS' ERROR IF CARRY 
2165 8cc9 08 65                        ASL  COEFPT+1       * SHIFT MULTIPLICAND LEFT ONE 
2166 8ccb 09 64                        ROL  COEFPT         * BIT - ADD MULTIPLIER TO ACCUMULATOR 
2167 8ccd 24 04                        BCC  LB4E6          * IF CARRY <> 0 
2168 8ccf d3 17                        ADDD BOTSTK         ADD MULTIPLIER TO ACCD 
2169 8cd1 25 05                        BCS  LB4EB          BS' ERROR IF CARRY (>$FFFF) 
2170 8cd3 0a 45              LB4E6     DEC  V45            * DECREMENT SHIFT COUNTER 
2171 8cd5 26 ee                        BNE  LB4D8          * IF NOT DONE 
2172 8cd7 39                           RTS                  
2173 8cd8 7e 8c 34           LB4EB     JMP  LB447          BS' ERROR 
2174                         *                              
2175                         * MEM                          
2176                         * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE                      
2177                         * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK                      
2178                         * FOR WHICH MEM DOES NOT ALLOW.                      
2179                         *                              
2180 8cdb 1f 40              MEM       TFR  S,D            PUT STACK POINTER INTO ACCD 
2181 8cdd 93 1f                        SUBD ARYEND         SUBTRACT END OF ARRAYS 
2182 8cdf 21                           FCB  SKP1           SKIP ONE BYTE 
2183                         *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0                      
2184 8ce0 4f                 LB4F3     CLRA                CLEAR MS BYTE OF ACCD 
2185                         * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0                      
2186 8ce1 0f 06              GIVABF    CLR  VALTYP         SET VARIABLE TYPE TO NUMERIC 
2187 8ce3 dd 50                        STD  FPA0           SAVE ACCD IN TOP OF FACA 
2188 8ce5 c6 90                        LDB  #$90           EXPONENT REQUIRED IF THE TOP TWO BYTES 
2189                         *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0  
2190 8ce7 7e 94 45                     JMP  LBC82          CONVERT THE REST OF FPA0 TO AN INTEGER 
2191                                                        
2192                         * STR$                         
2193 8cea bd 89 25           STR       JSR  LB143          TM' ERROR IF STRING VARIABLE 
2194 8ced ce 02 2e                     LDU  #STRBUF+2      *CONVERT FP NUMBER TO ASCII STRING IN 
2195 8cf0 bd 95 a4                     JSR  LBDDC          *THE STRING BUFFER 
2196 8cf3 32 62                        LEAS 2,S            PURGE THE RETURN ADDRESS FROM THE STACK 
2197 8cf5 8e 02 2d                     LDX  #STRBUF+1      *POINT X TO STRING BUFFER AND SAVE 
2198 8cf8 20 0b                        BRA  LB518          *THE STRING IN THE STRING SPACE 
2199                         * RESERVE ACCB BYTES OF STRING SPACE. RETURN START                      
2200                         * ADDRESS IN (X) AND FRESPC                      
2201 8cfa 9f 4d              LB50D     STX  V4D            SAVE X IN V4D 
2202 8cfc 8d 5c              LB50F     BSR  LB56D          RESERVE ACCB BYTES IN STRING SPACE 
2203 8cfe 9f 58              LB511     STX  STRDES+2       SAVE NEW STRING ADDRESS 
2204 8d00 d7 56                        STB  STRDES         SAVE LENGTH OF RESERVED BLOCK 
2205 8d02 39                           RTS                  
2206 8d03 30 1f              LB516     LEAX -1,X           MOVE POINTER BACK ONE 
2207                         * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR                      
2208                         * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.                      
2209                         * THE RESULTING STRING IS STORED IN THE STRING SPACE                      
2210                         * ONLY IF THE START OF THE STRING IS <= STRBUF+2                      
2211 8d05 86 22              LB518     LDA  #'"'            * INITIALIZE 
2212 8d07 97 01                        STA  CHARAC         * TERMINATORS 
2213 8d09 97 02              LB51A     STA  ENDCHR         * TO " 
2214 8d0b 30 01              LB51E     LEAX 1,X            MOVE POINTER UP ONE 
2215 8d0d 9f 62                        STX  RESSGN         TEMPORARILY SAVE START OF STRING 
2216 8d0f 9f 58                        STX  STRDES+2       SAVE START OF STRING IN TEMP DESCRIPTOR 
2217 8d11 c6 ff                        LDB  #-1            INITIALIZE CHARACTER COUNTER TO - 1 
2218 8d13 5c                 LB526     INCB                INCREMENT CHARACTER COUNTER 
2219 8d14 a6 80                        LDA  ,X+            GET CHARACTER 
2220 8d16 27 0c                        BEQ  LB537          BRANCH IF END OF LINE 
2221 8d18 91 01                        CMPA CHARAC         * CHECK FOR TERMINATORS 
2222 8d1a 27 04                        BEQ  LB533          * IN CHARAC AND ENDCHR 
2223 8d1c 91 02                        CMPA ENDCHR         * DON’T MOVE POINTER BACK 
2224 8d1e 26 f3                        BNE  LB526          * ONE IF TERMINATOR IS "MATCHED" 
2225 8d20 81 22              LB533     CMPA #'"'            = COMPARE CHARACTER TO STRING DELIMITER 
2226 8d22 27 02                        BEQ  LB539          = & DON’T MOVE POINTER BACK IF SO 
2227 8d24 30 1f              LB537     LEAX -1,X           MOVE POINTER BACK ONE 
2228 8d26 9f 64              LB539     STX  COEFPT         SAVE END OF STRING ADDRESS 
2229 8d28 d7 56                        STB  STRDES         SAVE STRING LENGTH IN TEMP DESCRIPTOR 
2230 8d2a de 62                        LDU  RESSGN         GET INITlAL STRING START 
2231 8d2c 11 83 02 2e                  CMPU #STRBUF+2      COMPARE TO START OF STRING BUFFER 
2232 8d30 22 07              LB543     BHI  LB54C          BRANCH IF > START OF STRING BUFFER 
2233 8d32 8d c6                        BSR  LB50D          GO RESERVE SPACE FOR THE STRING 
2234 8d34 9e 62                        LDX  RESSGN         POINT X TO THE BEGINNING OF THE STRING 
2235 8d36 bd 8e 32                     JSR  LB645          MOVE (B) BYTES FROM (X) TO 
2236                         *                             [FRESPC] - MOVE STRING DATA 
2237                         * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA                      
2238                         * ON THE STRING STACK. SET VARIABLE TYPE TO STRING                      
2239 8d39 9e 0b              LB54C     LDX  TEMPPT         GET NEXT AVAILABLE STRING STACK DESCRIPTOR 
2240 8d3b 8c 01 2f                     CMPX #LINHDR        COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF 
2241 8d3e 26 05                        BNE  LB558          FORMULA O.K. 
2242 8d40 c6 1e                        LDB  #15*2          STRING FORMULA TOO COMPLEX' ERROR 
2243 8d42 7e 84 41           LB555     JMP  LAC46          JUMP TO ERROR SERVICING ROUTINE 
2244 8d45 96 56              LB558     LDA  STRDES         * GET LENGTH OF STRING AND SAVE IT 
2245                         *         STA  ,X             * IN BYTE 0 OF DESCRIPTOR 
2246 8d47 a7 00                        FCB  $A7,$00         
2247 8d49 dc 58                        LDD  STRDES+2       = GET START ADDRESS OF ACTUAL STRING 
2248 8d4b ed 02                        STD  2,X            = AND SAVE IN BYTES 2,3 OF DESCRIPTOR 
2249 8d4d 86 ff                        LDA  #$FF           * VARIABLE TYPE = STRING 
2250 8d4f 97 06                        STA  VALTYP         * SAVE IN VARIABLE TYPE FLAG 
2251 8d51 9f 0d                        STX  LASTPT         = SAVE START OF DESCRIPTOR 
2252 8d53 9f 52                        STX  FPA0+2         = ADDRESS IN LASTPT AND FPA0 
2253 8d55 30 05                        LEAX 5,X            5 BYTES/STRING DESCRIPTOR 
2254 8d57 9f 0b                        STX  TEMPPT         NEXT AVAILABLE STRING VARIABLE DESCRIPTOR 
2255 8d59 39                           RTS                  
2256                         * RESERVE ACCB BYTES IN STRING STORAGE SPACE                      
2257                         * RETURN WITH THE STARTING ADDRESS OF THE                      
2258                         * RESERVED STRING SPACE IN (X) AND FRESPC                      
2259 8d5a 0f 07              LB56D     CLR  GARBFL         CLEAR STRING REORGANIZATION FLAG 
2260 8d5c 4f                 LB56F     CLRA                * PUSH THE LENGTH OF THE 
2261 8d5d 34 06                        PSHS B,A            * STRING ONTO THE STACK 
2262 8d5f dc 23                        LDD  STRTAB         GET START OF STRING VARIABLES 
2263 8d61 a3 e0                        SUBD ,S+            SUBTRACT STRING LENGTH 
2264 8d63 10 93 21                     CMPD FRETOP         COMPARE TO START OF STRING STORAGE 
2265 8d66 25 0a                        BCS  LB585          IF BELOW START, THEN REORGANIZE 
2266 8d68 dd 23                        STD  STRTAB         SAVE NEW START OF STRING VARIABLES 
2267 8d6a 9e 23                        LDX  STRTAB         GET START OF STRING VARIABLES 
2268 8d6c 30 01                        LEAX 1,X            ADD ONE 
2269 8d6e 9f 25                        STX  FRESPC         SAVE START ADDRESS OF NEWLY RESERVED SPACE 
2270 8d70 35 84                        PULS B,PC           RESTORE NUMBER OF BYTES RESERVED AND RETURN 
2271 8d72 c6 1a              LB585     LDB  #2*13          OUT OF STRING SPACE' ERROR 
2272 8d74 03 07                        COM  GARBFL         TOGGLE REORGANIZATiON FLAG 
2273 8d76 27 ca                        BEQ  LB555          ERROR IF FRESHLY REORGANIZED 
2274 8d78 8d 04                        BSR  LB591          GO REORGANIZE STRING SPACE 
2275 8d7a 35 04                        PULS B              GET BACK THE NUMBER OF BYTES TO RESERVE 
2276 8d7c 20 de                        BRA  LB56F          TRY TO RESERVE ACCB BYTES AGAIN 
2277                         * REORGANIZE THE STRING SPACE                      
2278 8d7e 9e 27              LB591     LDX  MEMSIZ         GET THE TOP OF STRING SPACE 
2279 8d80 9f 23              LB593     STX  STRTAB         SAVE TOP OF UNORGANIZED STRING SPACE 
2280 8d82 4f                           CLRA                * ZERO OUT ACCD 
2281 8d83 5f                           CLRB                * AND RESET VARIABLE 
2282 8d84 dd 4b                        STD  V4B            * POINTER TO 0 
2283 8d86 9e 21                        LDX  FRETOP         POINT X TO START OF STRING SPACE 
2284 8d88 9f 47                        STX  V47            SAVE POINTER IN V47 
2285 8d8a 8e 01 07                     LDX  #STRSTK        POINT X TO START OF STRING DESCRIPTOR STACK 
2286 8d8d 9c 0b              LB5A0     CMPX TEMPPT         COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR 
2287 8d8f 27 04                        BEQ  LB5A8          BRANCH IF TOP OF STRING STACK 
2288 8d91 8d 32                        BSR  LB5D8          CHECK FOR STRING IN UNORGANIZED STRING SPACE 
2289 8d93 20 f8                        BRA  LB5A0          KEEP CHECKING 
2290 8d95 9e 1b              LB5A8     LDX  VARTAB         GET THE END OF BASIC PROGRAM 
2291 8d97 9c 1d              LB5AA     CMPX ARYTAB         COMPARE TO END OF VARIABLES 
2292 8d99 27 04                        BEQ  LB5B2          BRANCH IF AT TOP OF VARIABLES 
2293 8d9b 8d 22                        BSR  LB5D2          CHECK FOR STRING IN UNORGANIZED STRING SPACE 
2294 8d9d 20 f8                        BRA  LB5AA          KEEP CHECKING VARIABLES 
2295 8d9f 9f 41              LB5B2     STX  V41            SAVE ADDRESS OF THE END OF VARIABLES 
2296 8da1 9e 41              LB5B4     LDX  V41            GET CURRENT ARRAY POINTER 
2297 8da3 9c 1f              LB5B6     CMPX ARYEND         COMPARE TO THE END OF ARRAYS 
2298 8da5 27 35                        BEQ  LB5EF          BRANCH IF AT END OF ARRAYS 
2299 8da7 ec 02                        LDD  2,X            GET LENGTH OF ARRAY AND DESCRIPTOR 
2300 8da9 d3 41                        ADDD V41            * ADD TO CURRENT ARRAY POINTER 
2301 8dab dd 41                        STD  V41            * AND SAVE IT 
2302 8dad a6 01                        LDA  1,X            GET 1ST CHARACTER OF VARIABLE NAME 
2303 8daf 2a f0                        BPL  LB5B4          BRANCH IF NUMERIC ARRAY 
2304 8db1 e6 04                        LDB  4,X            GET THE NUMBER OF DIMENSIONS IN THIS ARRAY 
2305 8db3 58                           ASLB                MULTIPLY BY 2 
2306 8db4 cb 05                        ADDB #5             ADD FIVE BYTES (VARIABLE NAME, ARRAY 
2307                         *                             LENGTH, NUMBER DIMENSIONS) 
2308 8db6 3a                           ABX                 X NOW POINTS TO START OF ARRAY ELEMENTS 
2309 8db7 9c 41              LB5CA     CMPX V41            AT END OF THIS ARRAY? 
2310 8db9 27 e8                        BEQ  LB5B6          YES - CHECK FOR ANOTHER 
2311 8dbb 8d 08                        BSR  LB5D8          CHECK FOR STRING LOCATED IN 
2312                         *                             UNORGANIZED STRING SPACE 
2313 8dbd 20 f8                        BRA  LB5CA          KEEP CHECKING ELEMENTS IN THIS ARRAY 
2314 8dbf a6 01              LB5D2     LDA  1,X            GET F1RST BYTE OF VARIABLE NAME 
2315 8dc1 30 02                        LEAX 2,X            MOVE POINTER TO DESCRIPTOR 
2316 8dc3 2a 14                        BPL  LB5EC          BRANCH IF VARIABLE IS NUMERIC 
2317                         * SEARCH FOR STRING - ENTER WITH X POINTING TO                      
2318                         * THE STRING DESCRIPTOR. IF STRING IS STORED                      
2319                         * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER                      
2320                         * IN V4B AND RESET V47 TO STRING ADDRESS                      
2321 8dc5 e6 84              LB5D8     LDB  ,X             GET THE LENGTH OF THE STRING 
2322 8dc7 27 10                        BEQ  LB5EC          BRANCH IF NULL - NO STRING 
2323 8dc9 ec 02                        LDD  2,X            GET STARTING ADDRESS OF THE STRING 
2324 8dcb 10 93 23                     CMPD STRTAB         COMPARE TO THE START OF STRING VARIABLES 
2325 8dce 22 09                        BHI  LB5EC          BRANCH IF THIS STRING IS STORED IN 
2326                         *              THE STRING VARIABLES  
2327 8dd0 10 93 47                     CMPD V47            COMPARE TO START OF STRING SPACE 
2328 8dd3 23 04                        BLS  LB5EC          BRANCH IF NOT STORED IN THE STRING SPACE 
2329 8dd5 9f 4b                        STX  V4B            SAVE VARIABLE POINTER IF STORED IN STRING SPACE 
2330 8dd7 dd 47                        STD  V47            SAVE STRING STARTING ADDRESS 
2331 8dd9 30 05              LB5EC     LEAX 5,X            MOVE TO NEXT VARIABLE DESCRIPTOR 
2332 8ddb 39                 LB5EE     RTS                  
2333 8ddc 9e 4b              LB5EF     LDX  V4B            GET ADDRESS OF THE DESCRIPTOR FOR THE 
2334                         *              STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN  
2335                         *              THE UNORGANIZED STRING SPACE  
2336 8dde 27 fb                        BEQ  LB5EE          BRANCH IF NONE FOUND AND REORGANIZATION DONE 
2337 8de0 4f                           CLRA                CLEAR MS BYTE OF LENGTH 
2338 8de1 e6 84                        LDB  ,X             GET LENGTH OF STRING 
2339 8de3 5a                           DECB                SUBTRACT ONE 
2340 8de4 d3 47                        ADDD V47            ADD LENGTH OF STRING TO ITS STARTING ADDRESS 
2341 8de6 dd 43                        STD  V43            SAVE AS MOVE STARTING ADDRESS 
2342 8de8 9e 23                        LDX  STRTAB         POINT X TO THE START OF ORGANIZED STRING VARIABLES 
2343 8dea 9f 41                        STX  V41            SAVE AS MOVE ENDING ADDRESS 
2344 8dec bd 84 1b                     JSR  LAC20          MOVE STRING FROM CURRENT POSITION TO THE 
2345                         *              TOP OF UNORGANIZED STRING SPACE  
2346 8def 9e 4b                        LDX  V4B            POINT X TO STRING DESCRIPTOR 
2347 8df1 dc 45                        LDD  V45            * GET NEW STARTING ADDRESS OF STRING AND 
2348 8df3 ed 02                        STD  2,X            * SAVE IT IN DESCRIPTOR 
2349 8df5 9e 45                        LDX  V45            GET NEW TOP OF UNORGANIZED STRING SPACE 
2350 8df7 30 1f                        LEAX -1,X           MOVE POINTER BACK ONE 
2351 8df9 7e 8d 80                     JMP  LB593          JUMP BACK AND REORGANIZE SOME MORE 
2352                                                        
2353                                                        
2354 8dfc dc 52              LB60F     LDD  FPA0+2         * GET DESCRIPTOR ADDRESS OF STRING A 
2355 8dfe 34 06                        PSHS B,A            * AND SAVE IT ON THE STACK 
2356 8e00 bd 8a 07                     JSR  LB223          GET DESCRIPTOR ADDRESS OF STRING B 
2357 8e03 bd 89 28                     JSR  LB146          TM' ERROR IF NUMERIC VARIABLE 
2358 8e06 35 10                        PULS X              * POINT X TO STRING A DESCRIPTOR 
2359 8e08 9f 62                        STX  RESSGN         * ADDRESS AND SAVE IT IN RESSGN 
2360 8e0a e6 84                        LDB  ,X             GET LENGTH OF STRING A 
2361 8e0c 9e 52                        LDX  FPA0+2         POINT X TO DESCRIPTOR OF STRING B 
2362 8e0e eb 84                        ADDB ,X             ADD LENGTH OF STRING B TO STR1NG A 
2363 8e10 24 05                        BCC  LB62A          BRANCH IF LENGTH < 256 
2364 8e12 c6 1c                        LDB  #2*14          STRING TOO LONG' ERROR IF LENGTH > 255 
2365 8e14 7e 84 41                     JMP  LAC46          JUMP TO ERROR SERVICING ROUTINE 
2366 8e17 bd 8c fa           LB62A     JSR  LB50D          RESERVE ROOM IN STRING SPACE FOR NEW STRING 
2367 8e1a 9e 62                        LDX  RESSGN         GET DESCRIPTOR ADDRESS OF STRING A 
2368 8e1c e6 84                        LDB  ,X             GET LENGTH OF STRING A 
2369 8e1e 8d 10                        BSR  LB643          MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE 
2370 8e20 9e 4d                        LDX  V4D            GET DESCRIPTOR ADDRESS OF STRING B 
2371 8e22 8d 22                        BSR  LB659          GET LENGTH AND ADDRESS OF STRING B 
2372 8e24 8d 0c                        BSR  LB645          MOVE STRING B INTO REST OF RESERVED BUFFER 
2373 8e26 9e 62                        LDX  RESSGN         POINT X TO DESCRIPTOR OF STRING A 
2374 8e28 8d 1c                        BSR  LB659          DELETE STRING A IF LAST STRING ON STRING STACK 
2375 8e2a bd 8d 39                     JSR  LB54C          PUT STRING DESCRIPTOR ON THE STRING STACK 
2376 8e2d 7e 89 4a                     JMP  LB168          BRANCH BACK TO EXPRESSION EVALUATION 
2377                                                        
2378                         * MOVE (B) BYTES FROM 2,X TO FRESPC                      
2379 8e30 ae 02              LB643     LDX  2,X            POINT X TO SOURCE ADDRESS 
2380 8e32 de 25              LB645     LDU  FRESPC         POINT U TO DESTINATION ADDRESS 
2381 8e34 5c                           INCB                COMPENSATION FOR THE DECB BELOW 
2382 8e35 20 04                        BRA  LB64E          GO MOVE THE BYTES 
2383                         * MOVE B BYTES FROM (X) TO (U)                      
2384 8e37 a6 80              LB64A     LDA  ,X+            * GET A SOURCE BYTE AND MOVE IT 
2385 8e39 a7 c0                        STA  ,U+            * TO THE DESTINATION 
2386 8e3b 5a                 LB64E     DECB                DECREMENT BYTE COUNTER 
2387 8e3c 26 f9                        BNE  LB64A          BRANCH IF ALL BYTES NOT MOVED 
2388 8e3e df 25                        STU  FRESPC         SAVE ENDING ADDRESS IN FRESPC 
2389 8e40 39                           RTS                  
2390                         * RETURN LENGTH (ACCB) AND ADDRESS (X) OF                      
2391                         * STRING WHOSE DESCRIPTOR IS IN FPA0+2                      
2392                         * DELETE THE STRING IF IT IS THE LAST ONE                      
2393                         * PUT ON THE STRING STACK. REMOVE STRING FROM STRING                      
2394                         * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.                      
2395 8e41 bd 89 28           LB654     JSR  LB146          TM' ERROR IF VARIABLE TYPE = NUMERIC 
2396 8e44 9e 52              LB657     LDX  FPA0+2         GET ADDRESS OF SELECTED STRING DESCRIPTOR 
2397 8e46 e6 84              LB659     LDB  ,X             GET LENGTH OF STRING 
2398 8e48 8d 18                        BSR  LB675          * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS 
2399 8e4a 26 13                        BNE  LB672          * THE LAST ONE PUT ON THE STRING STACK AND 
2400                         *                             * BRANCH IF NOT 
2401 8e4c ae 07                        LDX  5+2,X          GET START ADDRESS OF STRING JUST REMOVED 
2402 8e4e 30 1f                        LEAX -1,X           MOVE POINTER DOWN ONE 
2403 8e50 9c 23                        CMPX STRTAB         COMPARE TO START OF STRING VARIABLES 
2404 8e52 26 08                        BNE  LB66F          BRANCH IF THIS STRING IS NOT AT THE BOTTOM 
2405                         *                             OF STRING VARIABLES 
2406 8e54 34 04                        PSHS B              SAVE LENGTH; ACCA WAS CLEARED 
2407 8e56 d3 23                        ADDD STRTAB         * ADD THE LENGTH OF THE JUST REMOVED STRING 
2408 8e58 dd 23                        STD  STRTAB         * TO THE START OF STRING VARIABLES - THIS WILL 
2409                         *                             * REMOVE THE STRING FROM THE STRING SPACE 
2410 8e5a 35 04                        PULS B              RESTORE LENGTH 
2411 8e5c 30 01              LB66F     LEAX 1,X            ADD ONE TO POINTER 
2412 8e5e 39                           RTS                  
2413 8e5f ae 02              LB672     LDX  2,X            *POINT X TO ADDRESS OF STRING NOT 
2414 8e61 39                           RTS                 *ON THE STRING STACK 
2415                         * REMOVE STRING FROM STRING STACK. ENTER WITH X                      
2416                         * POINTING TO A STRING DESCRIPTOR - DELETE THE                      
2417                         * STRING FROM STACK IF IT IS ON TOP OF THE                      
2418                         * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG                      
2419 8e62 9c 0d              LB675     CMPX LASTPT         *COMPARE TO LAST USED DESCRIPTOR ADDRESS 
2420 8e64 26 07                        BNE  LB680          *ON THE STRING STACK, RETURN IF DESCRIPTOR 
2421                         *                             *ADDRESS NOT ON THE STRING STACK 
2422 8e66 9f 0b                        STX  TEMPPT         SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE 
2423 8e68 30 1b                        LEAX -5,X           * MOVE LAST USED DESCRIPTOR BACK 5 BYTES 
2424 8e6a 9f 0d                        STX  LASTPT         * AND SAVE AS THE LAST USED DESCRIPTOR ADDR 
2425 8e6c 4f                           CLRA                SET ZERO FLAG 
2426 8e6d 39                 LB680     RTS                  
2427                                                        
2428                         * LEN                          
2429 8e6e 8d 03              LEN       BSR  LB686          POINT X TO PROPER STRING AND GET LENGTH 
2430 8e70 7e 8c e0           LB683     JMP  LB4F3          CONVERT ACCB TO FP NUMBER IN FPA0 
2431                         * POINT X TO STRING ADDRESS LOAD LENGTH INTO                      
2432                         * ACCB. ENTER WITH THE STRING DESCRIPTOR IN                      
2433                         * BOTTOM TWO BYTES OF FPA0                      
2434 8e73 8d cc              LB686     BSR  LB654          GET LENGTH AND ADDRESS OF STRING 
2435 8e75 0f 06                        CLR  VALTYP         SET VARIABLE TYPE TO NUMERIC 
2436 8e77 5d                           TSTB                SET FLAGS ACCORDING TO LENGTH 
2437 8e78 39                           RTS                  
2438                                                        
2439                         * CHR$                         
2440 8e79 bd 8e fd           CHR       JSR  LB70E          CONVERT FPA0 TO AN INTEGER IN ACCD 
2441 8e7c c6 01              LB68F     LDB  #1             * RESERVE ONE BYTE IN 
2442 8e7e bd 8d 5a                     JSR  LB56D          * THE STRING SPACE 
2443 8e81 96 53                        LDA  FPA0+3         GET ASCII STRING VALUE 
2444 8e83 bd 8c fe                     JSR  LB511          SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR 
2445 8e86 a7 84                        STA  ,X             SAVE THE STRING (IT’S ONLY ONE BYTE) 
2446 8e88 32 62              LB69B     LEAS 2,S            PURGE THE RETURN ADDRESS OFF OF THE STACK 
2447 8e8a 7e 8d 39           LB69D     JMP  LB54C          PUT TEMP DESCRIPTOR DATA ONTO STRING STACK 
2448                                                        
2449                                                        
2450 8e8d 8d 02              ASC       BSR  LB6A4          PUT 1ST CHARACTER OF STRING INTO ACCB 
2451 8e8f 20 df                        BRA  LB683          CONVERT ACCB INTO FP NUMBER IN FPA0 
2452 8e91 8d e0              LB6A4     BSR  LB686          POINT X TO STRING DESCRIPTOR 
2453 8e93 27 5f                        BEQ  LB706          FC' ERROR IF NULL STRING 
2454 8e95 e6 84                        LDB  ,X             GET FIRST BYTE OF STRING 
2455 8e97 39                           RTS                  
2456                                                        
2457                                                        
2458 8e98 8d 49              LEFT      BSR  LB6F5          GET ARGUMENTS FROM STACK 
2459 8e9a 4f                 LB6AD     CLRA                CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$ 
2460 8e9b e1 84              LB6AE     CMPB ,X             * COMPARE LENGTH PARAMETER TO LENGTH OF 
2461 8e9d 23 03                        BLS  LB6B5          * STRING AND BRANCH IF LENGTH OF STRING 
2462                         *                             >= LENGTH PARAMETER 
2463 8e9f e6 84                        LDB  ,X             USE LENGTH OF STRING OTHERWISE 
2464 8ea1 4f                           CLRA                CLEAR STRING POINTER OFFSET (0 FOR LEFT$) 
2465 8ea2 34 06              LB6B5     PSHS B,A            PUSH PARAMETERS ONTO STACK 
2466 8ea4 bd 8c fc                     JSR  LB50F          RESERVE ACCB BYTES IN THE STRING SPACE 
2467 8ea7 9e 4d                        LDX  V4D            POINT X TO STRING DESCRIPTOR 
2468 8ea9 8d 9b                        BSR  LB659          GET ADDRESS OF OLD STRING (X=ADDRESS) 
2469 8eab 35 04                        PULS B              * PULL STRING POINTER OFFSET OFF OF THE STACK 
2470 8ead 3a                           ABX                 * AND ADD IT TO STRING ADDRESS 
2471 8eae 35 04                        PULS B              PULL LENGTH PARAMETER OFF OF THE STACK 
2472 8eb0 bd 8e 32                     JSR  LB645          MOVE ACCB BYTES FROM (X) TO [FRESPC] 
2473 8eb3 20 d5                        BRA  LB69D          PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK 
2474                                                        
2475                         * RIGHT$                       
2476 8eb5 8d 2c              RIGHT     BSR  LB6F5          GET ARGUMENTS FROM STACK 
2477 8eb7 a0 84                        SUBA ,X             ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING 
2478 8eb9 40                           NEGA                NOW ACCA = LENGTH OF OLD STRING 
2479 8eba 20 df                        BRA  LB6AE          PUT NEW STRING IN THE STRING SPACE 
2480                                                        
2481                         * MID$                         
2482 8ebc c6 ff              MID       LDB  #$FF           * GET DEFAULT VALUE OF LENGTH AND 
2483 8ebe d7 53                        STB  FPA0+3         * SAVE IT IN FPA0 
2484 8ec0 bd a4 b9                     JSR  GETCCH         GET CURRENT CHARACTER FROM BASIC 
2485 8ec3 81 29                        CMPA #')'            ARGUMENT DELIMITER? 
2486 8ec5 27 05                        BEQ  LB6DE          YES - NO LENGTH PARAMETER GIVEN 
2487 8ec7 bd 8a 54                     JSR  LB26D          SYNTAX CHECK FOR COMMA 
2488 8eca 8d 2e                        BSR  LB70B          EVALUATE NUMERIC EXPRESSION (LENGTH) 
2489 8ecc 8d 15              LB6DE     BSR  LB6F5          GET ARGUMENTS FROM STACK 
2490 8ece 27 24                        BEQ  LB706          FC' ERROR IF NULL STRING 
2491 8ed0 5f                           CLRB                CLEAR LENGTH COUNTER (DEFAULT VALUE) 
2492 8ed1 4a                           DECA                *SUOTRACT ONE FROM POSITION PARAMETER (THESE 
2493 8ed2 a1 84                        CMPA ,X             *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE) 
2494                         *                             *AND COMPARE IT TO LENGTH OF OLD STRING 
2495 8ed4 24 cc                        BCC  LB6B5          IF POSITION > LENGTH OF OLD STRING, THEN NEW 
2496                         *                             STRING WILL BE A NULL STRING 
2497 8ed6 1f 89                        TFR  A,B            SAVE ABSOLUTE POSITION PARAMETER IN ACCB 
2498 8ed8 e0 84                        SUBB ,X             ACCB=POSITION-LENGTH OF OLD STRING 
2499 8eda 50                           NEGB                NOW ACCB=LENGTH OF OLDSTRING-POSITION 
2500 8edb d1 53                        CMPB FPA0+3         *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF 
2501 8edd 23 c3                        BLS  LB6B5          *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND 
2502                         * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION                      
2503                         * INSTEAD OF THE LENGTH PARAMETER                      
2504 8edf d6 53                        LDB  FPA0+3         GET LENGTH OF NEW STRING 
2505 8ee1 20 bf                        BRA  LB6B5          PUT NEW STRING IN STRING SPACE 
2506                         * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC                      
2507                         * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK                      
2508 8ee3 bd 8a 4e           LB6F5     JSR  LB267          SYNTAX CHECK FOR A ")" 
2509 8ee6 ee e4                        LDU  ,S             LOAD THE RETURN ADDRESS INTO U REGISTER 
2510 8ee8 ae 65                        LDX  5,S            * GET ADDRESS OF STRING AND 
2511 8eea 9f 4d                        STX  V4D            * SAVE IT IN V4D 
2512 8eec a6 64                        LDA  4,S            = PUT LENGTH OF STRING IN 
2513 8eee e6 64                        LDB  4,S            = BOTH ACCA AND ACCB 
2514 8ef0 32 67                        LEAS 7,S            REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK 
2515 8ef2 1f 35                        TFR  U,PC           JUMP TO ADDRESS IN U REGISTER 
2516 8ef4 7e 8c 37           LB706     JMP  LB44A          ILLEGAL FUNCTION CALL' 
2517                         * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN                      
2518                         * ACCB - 'FC' ERROR IF EXPRESSION > 255                      
2519 8ef7 bd a4 b3           LB709     JSR  GETNCH         GET NEXT BASIC INPUT CHARACTER 
2520 8efa bd 89 23           LB70B     JSR  LB141          EVALUATE A NUMERIC EXPRESSION 
2521 8efd bd 8b d5           LB70E     JSR  LB3E9          CONVERT FPA0 TO INTEGER IN ACCD 
2522 8f00 4d                           TSTA                TEST MS BYTE OF INTEGER 
2523 8f01 26 f1                        BNE  LB706          FC' ERROR IF EXPRESSION > 255 
2524 8f03 7e a4 b9                     JMP  GETCCH         GET CURRENT INPUT CHARACTER FROM BASIC 
2525                                                        
2526                         * VAL                          
2527 8f06 bd 8e 73           VAL       JSR  LB686          POINT X TO STRING ADDRESS 
2528 8f09 10 27 02 ef                  LBEQ LBA39          IF NULL STRING SET FPA0 
2529 8f0d de 7c                        LDU  CHARAD         SAVE INPUT POINTER IN REGISTER U 
2530 8f0f 9f 7c                        STX  CHARAD         POINT INPUT POINTER TO ADDRESS OF STRING 
2531 8f11 3a                           ABX  MOVE POINTER TO END OF STRING TERMINATOR  
2532 8f12 a6 84                        LDA  ,X             GET LAST BYTE OF STRING 
2533 8f14 34 52                        PSHS U,X,A          SAVE INPUT POINTER, STRING TERMINATOR 
2534                         *         ADDRESS AND CHARACTER   
2535 8f16 6f 84                        CLR  ,X             CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION 
2536 8f18 bd a4 b9                     JSR  GETCCH         GET CURRENT CHARACTER FROM BASIC 
2537 8f1b bd 94 d5                     JSR  LBD12          CONVERT AN ASCII STRING TO FLOATING POINT 
2538 8f1e 35 52                        PULS A,X,U          RESTORE CHARACTERS AND POINTERS 
2539 8f20 a7 84                        STA  ,X             REPLACE STRING TERMINATOR 
2540 8f22 df 7c                        STU  CHARAD         RESTORE INPUT CHARACTER 
2541 8f24 39                           RTS                  
2542                                                        
2543 8f25 8d 07              LB734     BSR  LB73D          * EVALUATE AN EXPRESSION, RETURN 
2544 8f27 9f 2b                        STX  BINVAL         * THE VALUE IN X; STORE IT IN BINVAL 
2545 8f29 bd 8a 54           LB738     JSR  LB26D          SYNTAX CHECK FOR A COMMA 
2546 8f2c 20 cc                        BRA  LB70B          EVALUATE EXPRESSION IN RANGE 0 <= X < 256 
2547                         * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF                      
2548                                                        
2549 8f2e bd 89 23           LB73D     JSR  LB141          EVALUATE NUMERIC EXPRESSION 
2550 8f31 96 54              LB740     LDA  FP0SGN         GET SIGN OF FPA0 MANTISSA 
2551 8f33 2b bf                        BMI  LB706          ILLEGAL FUNCTION CALL' IF NEGATIVE 
2552 8f35 96 4f                        LDA  FP0EXP         GET EXPONENT OF FPA0 
2553 8f37 81 90                        CMPA #$90           COMPARE TO LARGEST POSITIVE INTEGER 
2554 8f39 22 b9                        BHI  LB706          ILLEGAL FUNCTION CALL' IF TOO LARGE 
2555 8f3b bd 94 8b                     JSR  LBCC8          SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0 
2556 8f3e 9e 52                        LDX  FPA0+2         LOAD X WITH LOWER TWO BYTES OF FPA0 
2557 8f40 39                           RTS                  
2558                                                        
2559                         * PEEK                         
2560 8f41 8d ee              PEEK      BSR  LB740          CONVERT FPA0 TO INTEGER IN REGISTER X 
2561 8f43 e6 84                        LDB  ,X             GET THE VALUE BEING 'PEEK'ED 
2562 8f45 7e 8c e0                     JMP  LB4F3          CONVERT ACCB INTO A FP NUMBER 
2563                                                        
2564                         * POKE                         
2565 8f48 8d db              POKE      BSR  LB734          EVALUATE 2 EXPRESSIONS 
2566 8f4a 9e 2b                        LDX  BINVAL         GET THE ADDRESS TO BE 'POKE'ED 
2567 8f4c e7 84                        STB  ,X             STORE THE DATA IN THAT ADDRESS 
2568 8f4e 39                           RTS                  
2569                                                        
2570                                                        
2571                         * LIST                         
2572 8f4f 34 01              LIST      PSHS CC             SAVE ZERO FLAG ON STACK 
2573 8f51 bd 87 65                     JSR  LAF67          CONVERT DECIMAL LINE NUMBER TO BINARY 
2574 8f54 bd 84 e7                     JSR  LAD01          * FIND RAM ADDRESS OF THAT LINE NUMBER AND 
2575 8f57 9f 66                        STX  LSTTXT         * SAVE IT IN LSTTXT 
2576 8f59 35 01                        PULS CC             GET ZERO FLAG FROM STACK 
2577 8f5b 27 14                        BEQ  LB784          BRANCH IF END OF LINE 
2578 8f5d bd a4 b9                     JSR  GETCCH         GET CURRENT CHARACTER FROM BASIC 
2579 8f60 27 14                        BEQ  LB789          BRANCH IF END OF LINE 
2580 8f62 81 ac                        CMPA #$AC           MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?) 
2581 8f64 26 0a                        BNE  LB783          NO - RETURN 
2582 8f66 bd a4 b3                     JSR  GETNCH         GET NEXT CHARACTER FROM BASIC 
2583 8f69 27 06                        BEQ  LB784          BRANCH IF END OF LINE 
2584 8f6b bd 87 65                     JSR  LAF67          GET ENDING LINE NUMBER 
2585 8f6e 27 06                        BEQ  LB789          BRANCH IF LEGAL LINE NUMBER 
2586 8f70 39                 LB783 RTS                      
2587                         * LIST THE ENTIRE PROGRAM                      
2588 8f71 ce ff ff           LB784     LDU  #$FFFF         * SET THE DEFAULT ENDING LINE NUMBER 
2589 8f74 df 2b                        STU  BINVAL         * TO $FFFF 
2590 8f76 32 62              LB789     LEAS 2,S            PURGE RETURN ADDRESS FROM THE STACK 
2591 8f78 9e 66                        LDX  LSTTXT         POINT X TO STARTING LINE ADDRESS 
2592 8f7a bd 91 22           LB78D     JSR  LB95C          MOVE CURSOR TO START OF A NEW LINE 
2593 8f7d bd 81 b0                     JSR  LA549          CHECK FOR A BREAK OR PAUSE 
2594 8f80 ec 84                        LDD  ,X             GET ADDRESS OF NEXT BASIC LINE 
2595 8f82 26 03                        BNE  LB79F          BRANCH IF NOT END OF PROGRAM 
2596                         LB797                          
2597 8f84 7e 84 64                     JMP  LAC73          RETURN TO BASIC’S MAIN INPUT LOOP 
2598 8f87 9f 66              LB79F     STX  LSTTXT         SAVE NEW STARTING LINE ADDRESS 
2599 8f89 ec 02                        LDD  2,X            * GET THE LINE NUMBER OF THIS LINE AND 
2600 8f8b 10 93 2b                     CMPD BINVAL         * COMPARE IT TO ENDING LINE NUMBER 
2601 8f8e 22 f4                        BHI  LB797          EXIT IF LINE NUMBER > ENDING LINE NUMBER 
2602 8f90 bd 95 94                     JSR  LBDCC          PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL 
2603 8f93 bd 91 6f                     JSR  LB9AC          SEND A SPACE TO CONSOLE OUT 
2604 8f96 9e 66                        LDX  LSTTXT         GET RAM ADDRESS OF THIS LINE 
2605 8f98 8d 10                        BSR  LB7C2          UNCRUNCH A LINE 
2606 8f9a ae 9f 00 66                  LDX  [LSTTXT]       POINT X TO START OF NEXT LINE 
2607 8f9e ce 01 32                     LDU  #LINBUF+1      POINT U TO BUFFER FULL OF UNCRUNCHED LINE 
2608 8fa1 a6 c0              LB7B9     LDA  ,U+            GET A BYTE FROM THE BUFFER 
2609 8fa3 27 d5                        BEQ  LB78D          BRANCH IF END OF BUFFER 
2610 8fa5 bd 91 74                     JSR  LB9B1          SEND CHARACTER TO CONSOLE OUT 
2611 8fa8 20 f7                        BRA  LB7B9          GET ANOTHER CHARACTER 
2612                                                        
2613                         * UNCRUNCH A LINE INTO BASIC’S LINE INPUT BUFFER                      
2614 8faa bd 01 04           LB7C2     JSR  RVEC24         HOOK INTO RAM 
2615 8fad 30 04                        LEAX 4,X            MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER 
2616 8faf 10 8e 01 32                  LDY  #LINBUF+1      UNCRUNCH LINE INTO LINE INPUT BUFFER 
2617 8fb3 a6 80              LB7CB     LDA  ,X+            GET A CHARACTER 
2618 8fb5 27 51                        BEQ  LB820          BRANCH IF END OF LINE 
2619 8fb7 2b 15                        BMI  LB7E6          BRANCH IF IT’S A TOKEN 
2620 8fb9 81 3a                        CMPA #':'            CHECK FOR END OF SUB LINE 
2621 8fbb 26 0d                        BNE  LB7E2          BRNCH IF NOT END OF SUB LINE 
2622 8fbd e6 84                        LDB  ,X             GET CHARACTER FOLLOWING COLON 
2623 8fbf c1 84                        CMPB #$84           TOKEN FOR ELSE? 
2624 8fc1 27 f0                        BEQ  LB7CB          YES - DON’T PUT IT IN BUFFER 
2625 8fc3 c1 83                        CMPB #$83           TOKEN FOR REMARK? 
2626 8fc5 27 ec                        BEQ  LB7CB          YES - DON’T PUT IT IN BUFFER 
2627 8fc7 8c                           FCB  SKP2           SKIP TWO BYTES 
2628 8fc8 86 21              LB7E0     LDA  #'!'            EXCLAMATION POINT 
2629 8fca 8d 30              LB7E2     BSR  LB814          PUT CHARACTER IN BUFFER 
2630 8fcc 20 e5                        BRA  LB7CB          GET ANOTHER CHARACTER 
2631                                                        
2632 8fce ce 00 a1           LB7E6     LDU  #COMVEC-10     FIRST DO COMMANDS 
2633 8fd1 81 ff                        CMPA #$FF           CHECK FOR SECONDARY TOKEN 
2634 8fd3 26 04                        BNE  LB7F1          BRANCH IF NON SECONDARY TOKEN 
2635 8fd5 a6 80                        LDA  ,X+            GET SECONDARY TOKEN 
2636 8fd7 33 45                        LEAU 5,U            BUMP IT UP TO SECONDARY FUNCTIONS 
2637 8fd9 84 7f              LB7F1     ANDA #$7F           MASK OFF BIT 7 OF TOKEN 
2638 8fdb 33 4a              LB7F3     LEAU 10,U           MOVE TO NEXT COMMAND TABLE 
2639 8fdd 6d c4                        TST  ,U             IS THIS TABLE ENABLED? 
2640 8fdf 27 e7                        BEQ  LB7E0          NO - ILLEGAL TOKEN 
2641 8fe1 a0 c4                        SUBA ,U             SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER 
2642 8fe3 2a f6                        BPL  LB7F3          BRANCH IF TOKEN NOT IN THIS TABLE 
2643 8fe5 ab c4                        ADDA ,U             RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE 
2644 8fe7 ee 41                        LDU  1,U            POINT U TO COMMAND DICTIONARY TABLE 
2645 8fe9 4a                 LB801     DECA                DECREMENT TOKEN NUMBER 
2646 8fea 2b 06                        BMI  LB80A          BRANCH IF THIS IS THE CORRECT TOKEN 
2647                         * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN                      
2648 8fec 6d c0              LB804     TST  ,U+            GRAB A BYTE 
2649 8fee 2a fc                        BPL  LB804          BRANCH IF BIT 7 NOT SET 
2650 8ff0 20 f7                        BRA  LB801          GO SEE IF THIS IS THE CORRECT TOKEN 
2651 8ff2 a6 c4              LB80A     LDA  ,U             GET A CHARACTER FROM DICTIONARY TABLE 
2652 8ff4 8d 06                        BSR  LB814          PUT CHARACTER IN BUFFER 
2653 8ff6 6d c0                        TST  ,U+            CHECK FOR START OF NEXT TOKEN 
2654 8ff8 2a f8                        BPL  LB80A          BRANCH IF NOT DONE WITH THIS TOKEN 
2655 8ffa 20 b7                        BRA  LB7CB          GO GET ANOTHER CHARACTER 
2656 8ffc 10 8c 02 2b        LB814     CMPY #LINBUF+LBUFMX TEST FOR END OF LINE INPUT BUFFER 
2657 9000 24 06                        BCC  LB820          BRANCH IF AT END OF BUFFER 
2658 9002 84 7f                        ANDA #$7F           MASK OFF BIT 7 
2659 9004 a7 a0                        STA  ,Y+            * SAVE CHARACTER IN BUFFER AND 
2660 9006 6f a4                        CLR  ,Y             * CLEAR NEXT CHARACTER SLOT IN BUFFER 
2661 9008 39                 LB820     RTS                  
2662                         *                              
2663                         * CRUNCH THE LINE THAT THE INPUT POINTER IS                      
2664                         * POINTING TO INTO THE LINE INPUT BUFFER                      
2665                         * RETURN LENGTH OF CRUNCHED LINE IN ACCD                      
2666                         *                              
2667 9009 bd 01 01           LB821     JSR  RVEC23         HOOK INTO RAM 
2668 900c 9e 7c                        LDX  CHARAD         GET BASIC'S INPUT POINTER ADDRESS 
2669 900e ce 01 31                     LDU  #LINBUF        POINT X TO LINE INPUT BUFFER 
2670 9011 0f 43              LB829     CLR  V43            CLEAR ILLEGAL TOKEN FLAG 
2671 9013 0f 44                        CLR  V44            CLEAR DATA FLAG 
2672 9015 a6 80              LB82D     LDA  ,X+            GET INPUT CHAR 
2673 9017 27 21                        BEQ  LB852          BRANCH IF END OF LINE 
2674 9019 0d 43                        TST  V43            * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT 
2675 901b 27 0f                        BEQ  LB844          * PROCESSING AN ILLEGAL TOKEN 
2676 901d bd 8b 8d                     JSR  LB3A2          SET CARRY IF NOT UPPER CASE ALPHA 
2677 9020 24 18                        BCC  LB852          BRANCH IF UPPER CASE ALPHA 
2678 9022 81 30                        CMPA #'0'            * DON’T CRUNCH ASCII NUMERIC CHARACTERS 
2679 9024 25 04                        BLO  LB842          * BRANCH IF NOT NUMERIC 
2680 9026 81 39                        CMPA #'9'            * 
2681 9028 23 10                        BLS  LB852          * BRANCH IF NUMERIC 
2682                         * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC                      
2683 902a 0f 43              LB842     CLR  V43            CLEAR ILLEGAL TOKEN FLAG 
2684 902c 81 20              LB844     CMPA #SPACE         SPACE? 
2685 902e 27 0a                        BEQ  LB852          DO NOT REMOVE SPACES 
2686 9030 97 42                        STA  V42            SAVE INPUT CHARACTER AS SCAN DELIMITER 
2687 9032 81 22                        CMPA #'"'            CHECK FOR STRING DELIMITER 
2688 9034 27 38                        BEQ  LB886          BRANCH IF STRING 
2689 9036 0d 44                        TST  V44            * CHECK DATA FLAG AND BRANCH IF CLEAR 
2690 9038 27 19                        BEQ  LB86B          * DO NOT CRUNCH DATA 
2691 903a a7 c0              LB852     STA  ,U+            SAVE CHARACTER IN BUFFER 
2692 903c 27 06                        BEQ  LB85C          BRANCH IF END OF LINE 
2693 903e 81 3a                        CMPA #':'            * CHECK FOR END OF SUBLINE 
2694 9040 27 cf                        BEQ  LB829          * AND RESET FLAGS IF END OF SUBLINE 
2695 9042 20 d1              LB85A     BRA  LB82D          GO GET ANOTHER CHARACTER 
2696 9044 6f c0              LB85C     CLR  ,U+            * DOUBLE ZERO AT END OF LINE 
2697 9046 6f c0                        CLR  ,U+            * 
2698 9048 1f 30                        TFR  U,D            SAVE ADDRESS OF END OF LINE IN ACCD 
2699 904a 83 01 2f                     SUBD #LINHDR        LENGTH OF LINE IN ACCD 
2700 904d 8e 01 30                     LDX  #LINBUF-1      * SET THE INPUT POINTER TO ONE BEFORE 
2701 9050 9f 7c                        STX  CHARAD         * THE START OF THE CRUNCHED LINE 
2702 9052 39                           RTS  EXIT 'CRUNCH'   
2703 9053 81 3f              LB86B     CMPA #'?'            CHECK FOR "?" - PRINT ABBREVIATION 
2704 9055 26 04                        BNE  LB873          BRANCH IF NOT PRINT ABBREVIATION 
2705 9057 86 87                        LDA  #$87           * GET THE PRINT TOKEN AND SAVE IT 
2706 9059 20 df                        BRA  LB852          * IN BUFFER 
2707 905b 81 60              LB873     CMPA #$60            APOSTROPHE IS SAME AS REM 
2708 905d 26 13                        BNE  LB88A          BRANCH IF NOT REMARK 
2709 905f cc 3a 83                     LDD  #$3A83         COLON, REM TOKEN 
2710 9062 ed c1                        STD  ,U++           SAVE IN BUFFER 
2711 9064 0f 42              LB87C     CLR  V42            SET DELIMITER = 0 (END OF LINE) 
2712 9066 a6 80              LB87E     LDA  ,X+            SCAN TILL WE MATCH [V42] 
2713 9068 27 d0                        BEQ  LB852          BRANCH IF END OF LINE 
2714 906a 91 42                        CMPA V42            DELIMITER? 
2715 906c 27 cc                        BEQ  LB852          BRANCH OUT IF SO 
2716 906e a7 c0              LB886     STA  ,U+            DON’T CRUNCH REMARKS OR STRINGS 
2717 9070 20 f4                        BRA  LB87E          GO GET MORE STRING OR REMARK 
2718 9072 81 30              LB88A     CMPA #'0'            * LESS THAN ASCII ZERO? 
2719 9074 25 04                        BCS  LB892          * BRANCH IF SO 
2720 9076 81 3c                        CMPA #';'+1          = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON 
2721 9078 25 c0                        BCS  LB852          = AND INSERT IN BUFFER IF SO 
2722 907a 30 1f              LB892     LEAX -1,X           MOVE INPUT POINTER BACK ONE 
2723 907c 34 50                        PSHS U,X            SAVE POINTERS TO INPUT STRING, OUTPUT STRING 
2724 907e 0f 41                        CLR  V41            TOKEN FLAG 0 = COMMAND, FF = SECONDARY 
2725 9080 ce 00 a1                     LDU  #COMVEC-10     POINT U TO COMMAND INTERPRETATION 
2726                         *                             TABLE FOR BASIC - 10 
2727 9083 0f 42              LB89B     CLR  V42            INITIALIZE V42 AS TOKEN COUNTER 
2728 9085 33 4a              LB89D     LEAU 10,U           MOVE TO NEXT COMMAND INTERPRETATION TABLE 
2729 9087 a6 c4                        LDA  ,U             GET NUMBER OF COMMANDS 
2730 9089 27 31                        BEQ  LB8D4          GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE 
2731 908b 10 ae 41                     LDY  1,U            POINT Y TO COMMAND DICTIONARY TABLE 
2732 908e ae e4              LB8A6     LDX  ,S             GET POINTER TO INPUT STRING 
2733 9090 e6 a0              LB8A8     LDB  ,Y+            GET A BYTE FROM DICTIONARY TABLE 
2734 9092 e0 80                        SUBB ,X+            SUBTRACT INPUT CHARACTER 
2735 9094 27 fa                        BEQ  LB8A8          LOOP IF SAME 
2736 9096 c1 80                        CMPB #$80           LAST CHAR IN RESERVED WORD TABLE HAD 
2737                         *                             BIT 7 SET, SO IF WE HAVE $80 HERE 
2738                         *                             THEN IT IS A GOOD COMPARE 
2739 9098 26 38                        BNE  LB8EA          BRANCH IF NO MATCH - CHECK ANOTHER COMMAND 
2740 909a 32 62                        LEAS 2,S            DELETE OLD INPUT POINTER FROM STACK 
2741 909c 35 40                        PULS U              GET POINTER TO OUTPUT STRING 
2742 909e da 42                        ORB  V42            OR IN THE TABLE POSITION TO MAKE THE TOKEN 
2743                         *                             - NOTE THAT B ALREADY HAD $80 IN IT - 
2744 90a0 96 41                        LDA  V41            * CHECK TOKEN FLAG AND BRANCH 
2745 90a2 26 06                        BNE  LB8C2          * IF SECONDARY 
2746 90a4 c1 84                        CMPB #$84           IS IT ELSE TOKEN? 
2747 90a6 26 06                        BNE  LB8C6          NO 
2748 90a8 86 3a                        LDA  #':'            PUT A COLON (SUBLINE) BEFORE ELSE TOKEN 
2749 90aa ed c1              LB8C2     STD  ,U++           SECONDARY TOKENS PRECEEDED BY $FF 
2750 90ac 20 94                        BRA  LB85A          GO PROCESS MORE INPUT CHARACTERS 
2751 90ae e7 c0              LB8C6     STB  ,U+            SAVE THIS TOKEN 
2752 90b0 c1 86                        CMPB #$86           DATA TOKEN? 
2753 90b2 26 02                        BNE  LB8CE          NO 
2754 90b4 0c 44                        INC  V44            SET DATA FLAG 
2755 90b6 c1 82              LB8CE     CMPB #$82           REM TOKEN? 
2756 90b8 27 aa                        BEQ  LB87C          YES 
2757 90ba 20 86              LB8D2     BRA  LB85A          GO PROCESS MORE INPUT CHARACTERS 
2758                         * CHECK FOR A SECONDARY TOKEN                      
2759 90bc ce 00 a6           LB8D4     LDU  #COMVEC-5      NOW DO SECONDARY FUNCTIONS 
2760 90bf 03 41                        COM  V41            TOGGLE THE TOKEN FLAG 
2761 90c1 26 c0                        BNE  LB89B          BRANCH IF NOW CHECKING SECONDARY COMMANDS 
2762                                                        
2763                         * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO                      
2764                         * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN                      
2765 90c3 35 50                        PULS X,U            RESTORE INPUT AND OUTPUT POINTERS 
2766 90c5 a6 80                        LDA  ,X+            * MOVE THE FIRST CHARACTER OF AN 
2767 90c7 a7 c0                        STA  ,U+            * ILLEGAL TOKEN 
2768 90c9 bd 8b 8d                     JSR  LB3A2          SET CARRY IF NOT ALPHA 
2769 90cc 25 ec                        BCS  LB8D2          BRANCH IF NOT ALPHA 
2770 90ce 03 43                        COM  V43            SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA 
2771 90d0 20 e8                        BRA  LB8D2          PROCESS MORE INPUT CHARACTERS 
2772 90d2 0c 42              LB8EA     INC  V42            INCREMENT TOKEN COUNTER 
2773 90d4 4a                           DECA                DECR COMMAND COUNTER 
2774 90d5 27 ae                        BEQ  LB89D          GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE 
2775 90d7 31 3f                        LEAY -1,Y           MOVE POINTER BACK ONE 
2776 90d9 e6 a0              LB8F1     LDB  ,Y+            * GET TO NEXT 
2777 90db 2a fc                        BPL  LB8F1          * RESERVED WORD 
2778 90dd 20 af                        BRA  LB8A6          GO SEE IF THIS WORD IS A MATCH 
2779                                                        
2780                         * PRINT                        
2781 90df 27 3d              PRINT     BEQ  LB958          BRANCH IF NO ARGUMENT 
2782 90e1 8d 01                        BSR  LB8FE          CHECK FOR ALL PRINT OPTIONS 
2783 90e3 39                           RTS                  
2784                         LB8FE                          
2785 90e4 9d e0              LB918     JSR  RVEC9          HOOK INTO RAM 
2786 90e6 bd a0 a7                     JSR  XVEC9           
2787 90e9 27 40              LB91B     BEQ  LB965          RETURN IF END OF LINE 
2788 90eb 81 a4              LB91D     CMPA #$A4           TOKEN FOR TAB( ? 
2789 90ed 27 55                        BEQ  LB97E          YES 
2790 90ef 81 2c                        CMPA #','            COMMA? 
2791 90f1 27 39                        BEQ  LB966          YES - ADVANCE TO NEXT TAB FIELD 
2792 90f3 81 3b                        CMPA #';'            SEMICOLON? 
2793 90f5 27 62                        BEQ  LB997          YES - DO NOT ADVANCE CURSOR 
2794 90f7 bd 89 38                     JSR  LB156          EVALUATE EXPRESSION 
2795 90fa 96 06                        LDA  VALTYP         * GET VARIABLE TYPE AND 
2796 90fc 34 02                        PSHS A              * SAVE IT ON THE STACK 
2797 90fe 26 06                        BNE  LB938          BRANCH IF STRING VARIABLE 
2798 9100 bd 95 a1                     JSR  LBDD9          CONVERT FP NUMBER TO AN ASCII STRING 
2799 9103 bd 8d 03                     JSR  LB516          PARSE A STRING FROM (X-1) AND PUT 
2800                         *                             DESCRIPTOR ON STRING STACK 
2801 9106 8d 5a              LB938     BSR  LB99F          PRINT STRING POINTED TO BY X 
2802 9108 35 04                        PULS B              GET VARIABLE TYPE BACK 
2803 910a bd 81 45                     JSR  LA35F          SET UP TAB WIDTH ZONE, ETC 
2804 910d 5d                 LB949     TSTB                CHECK CURRENT PRINT POSITION 
2805 910e 26 09                        BNE  LB954          BRANCH IF NOT AT START OF LINE 
2806 9110 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
2807 9113 81 2c                        CMPA #','            COMMA? 
2808 9115 27 15                        BEQ  LB966          SKIP TO NEXT TAB FIELD 
2809 9117 8d 56                        BSR  LB9AC          SEND A SPACE TO CONSOLE OUT 
2810 9119 bd a4 b9           LB954     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
2811 911c 26 cd                        BNE  LB91D          BRANCH IF NOT END OF LINE 
2812 911e 86 0d              LB958     LDA  #CR            * SEND A CR TO 
2813 9120 20 52                        BRA  LB9B1          * CONSOLE OUT 
2814 9122 bd 81 45           LB95C     JSR  LA35F          SET UP TAB WIDTH, ZONE ETC 
2815 9125 27 f7                        BEQ  LB958          BRANCH IF WIDTH = ZERO 
2816 9127 96 6c                        LDA  DEVPOS         GET PRINT POSITION 
2817 9129 26 f3                        BNE  LB958          BRANCH IF NOT AT START OF LINE 
2818 912b 39                 LB965     RTS                  
2819                         * SKIP TO NEXT TAB FIELD                      
2820 912c bd 81 45           LB966     JSR  LA35F          SET UP TAB WIDTH, ZONE ETC 
2821 912f 27 0a                        BEQ  LB975          BRANCH IF LINE WIDTH = 0 (CASSETTE) 
2822 9131 d6 6c                        LDB  DEVPOS         GET CURRENT POSITION 
2823 9133 d1 6b                        CMPB DEVLCF         COMPARE TO LAST TAB ZONE 
2824 9135 25 06                        BCS  LB977          BRANCH IF < LAST TAB ZONE 
2825 9137 8d e5                        BSR  LB958          SEND A CARRIAGE RETURN TO CONSOLE OUT 
2826 9139 20 1e                        BRA  LB997          GET MORE DATA 
2827 913b d6 6c              LB975     LDB  DEVPOS         * 
2828 913d d0 6a              LB977     SUBB DEVCFW         * SUBTRACT TAB FIELD WIDTH FROM CURRENT 
2829 913f 24 fc                        BCC  LB977          * POSITION UNTIL CARRY SET - NEGATING THE 
2830 9141 50                           NEGB                * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT 
2831                         *              * TAB ZONE IN ACCB  
2832 9142 20 10                        BRA  LB98E          GO ADVANCE TO NEXT TAB ZONE 
2833                                                        
2834                         * PRINT TAB(                      
2835 9144 bd 8e f7           LB97E     JSR  LB709          EVALUATE EXPRESSION - RETURN VALUE IN B 
2836 9147 81 29                        CMPA #')'            * 'SYNTAX' ERROR IF NOT ')' 
2837 9149 10 26 f9 12                  LBNE LB277          * 
2838 914d bd 81 45                     JSR  LA35F          SET UP TAB WIDTH, ZONE ETC 
2839 9150 d0 6c                        SUBB DEVPOS         GET DIFFERENCE OF PRINT POSITION & TAB POSITION 
2840 9152 23 05                        BLS  LB997          BRANCH IF TAB POSITION < CURRENT POSITION 
2841                         LB98E                          
2842 9154 8d 19              LB992     BSR  LB9AC          SEND A SPACE TO CONSOLE OUT 
2843 9156 5a                           DECB                DECREMENT DIFFERENCE COUNT 
2844 9157 26 fb                        BNE  LB992          BRANCH UNTIL CURRENT POSITION = TAB POSITION 
2845 9159 bd a4 b3           LB997     JSR  GETNCH         GET NEXT CHARACTER FROM BASIC 
2846 915c 7e 90 e9                     JMP  LB91B          LOOK FOR MORE PRINT DATA 
2847                         * COPY A STRING FROM (X) TO CONSOLE OUT                      
2848 915f bd 8d 05           LB99C     JSR  LB518          PARSE A STRING FROM X AND PUT 
2849                         *         DESCRIPTOR ON STRING STACK  
2850 9162 bd 8e 44           LB99F     JSR  LB657          GET LENGTH OF STRING AND REMOVE 
2851                         *         DESCRIPTOR FROM STRING STACK  
2852 9165 5c                           INCB                COMPENSATE FOR DECB BELOW 
2853 9166 5a                 LB9A3     DECB                DECREMENT COUNTER 
2854 9167 27 c2                        BEQ  LB965          EXIT ROUTINE 
2855 9169 a6 80                        LDA  ,X+            GET A CHARACTER FROM X 
2856 916b 8d 07                        BSR  LB9B1          SEND TO CONSOLE OUT 
2857 916d 20 f7                        BRA  LB9A3          KEEP LOOPING 
2858 916f 86 20              LB9AC     LDA  #SPACE         SPACE TO CONSOLE OUT 
2859 9171 8c                           FCB  SKP2           SKIP NEXT TWO BYTES 
2860 9172 86 3f              LB9AF     LDA  #'?'           QUESTION MARK TO CONSOLE OUT 
2861 9174 7e 81 13           LB9B1     JMP  PUTCHR         JUMP TO CONSOLE OUT 
2862                                                        
2863                         * FLOATING POINT MATH PACKAGE                      
2864                                                        
2865                         * ADD .5 TO FPA0                      
2866 9177 8e 96 88           LB9B4     LDX  #LBEC0         FLOATING POINT CONSTANT (.5) 
2867 917a 20 09                        BRA  LB9C2          ADD .5 TO FPA0 
2868                         * SUBTRACT FPA0 FROM FP NUMBER POINTED                      
2869                         * TO BY (X), LEAVE RESULT IN FPA0                      
2870 917c bd 92 f2           LB9B9     JSR  LBB2F          COPY PACKED FP DATA FROM (X) TO FPA1 
2871                                                        
2872                         * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER                      
2873                         * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)                      
2874 917f 03 54              LB9BC     COM  FP0SGN         CHANGE MANTISSA SIGN OF FPA0 
2875 9181 03 62                        COM  RESSGN         REVERSE RESULT SIGN FLAG 
2876 9183 20 03                        BRA  LB9C5          GO ADD FPA1 AND FPA0 
2877                         * ADD FP NUMBER POINTED TO BY                      
2878                         * (X) TO FPA0 - LEAVE RESULT IN FPA0                      
2879 9185 bd 92 f2           LB9C2     JSR  LBB2F          UNPACK PACKED FP DATA FROM (X) TO 
2880                         *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA  
2881                                                        
2882                         * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO                      
2883                                                        
2884 9188 5d                 LB9C5     TSTB                CHECK EXPONENT OF FPA0 
2885 9189 10 27 02 80                  LBEQ LBC4A          COPY FPA1 TO FPA0 IF FPA0 = 
2886 918d 8e 00 5c                     LDX  #FP1EXP        POINT X TO FPA1 
2887 9190 1f 89              LB9CD     TFR  A,B            PUT EXPONENT OF FPA1 INTO ACCB 
2888 9192 5d                           TSTB                CHECK EXPONENT 
2889 9193 27 6c                        BEQ  LBA3E          RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0) 
2890 9195 d0 4f                        SUBB FP0EXP         SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1 
2891 9197 27 69                        BEQ  LBA3F          BRANCH IF EXPONENTS ARE EQUAL 
2892 9199 25 0a                        BCS  LB9E2          BRANCH IF EXPONENT FPA0 > FPA1 
2893 919b 97 4f                        STA  FP0EXP         REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT 
2894 919d 96 61                        LDA  FP1SGN         * REPLACE FPA0 MANTISSA SIGN 
2895 919f 97 54                        STA  FP0SGN         * WITH FPA1 MANTISSA SIGN 
2896 91a1 8e 00 4f                     LDX  #FP0EXP        POINT X TO FPA0 
2897 91a4 50                           NEGB                NEGATE DIFFERENCE OF EXPONENTS 
2898 91a5 c1 f8              LB9E2     CMPB #-8            TEST DIFFERENCE OF EXPONENTS 
2899 91a7 2f 59                        BLE  LBA3F          BRANCH IF DIFFERENCE OF EXPONENTS <= 8 
2900 91a9 4f                           CLRA                CLEAR OVERFLOW BYTE 
2901 91aa 64 01                        LSR  1,X            SHIFT MS BYTE OF MANTISSA; BIT 7 = 0 
2902 91ac bd 92 7d                     JSR  LBABA          GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES 
2903 91af d6 62              LB9EC     LDB  RESSGN         GET SIGN FLAG 
2904 91b1 2a 0b                        BPL  LB9FB          BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME 
2905 91b3 63 01                        COM  1,X            * COMPLEMENT MANTISSA POINTED 
2906 91b5 63 02                        COM  2,X            * TO BY (X) THE 
2907 91b7 63 03                        COM  3,X            * ADCA BELOW WILL 
2908 91b9 63 04                        COM  4,X            * CONVERT THIS OPERATION 
2909 91bb 43                           COMA                * INTO A NEG (MANTISSA) 
2910 91bc 89 00                        ADCA #0             ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG 
2911                         * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA                      
2912                         *                              
2913                         * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0                      
2914 91be 97 63              LB9FB     STA  FPSBYT         SAVE FPA SUB BYTE 
2915 91c0 96 53                        LDA  FPA0+3         * ADD LS BYTE 
2916 91c2 99 60                        ADCA FPA1+3         * OF MANTISSA 
2917 91c4 97 53                        STA  FPA0+3         SAVE IN FPA0 LSB 
2918 91c6 96 52                        LDA  FPA0+2         * ADD NEXT BYTE 
2919 91c8 99 5f                        ADCA FPA1+2         * OF MANTISSA 
2920 91ca 97 52                        STA  FPA0+2         SAVE IN FPA0 
2921 91cc 96 51                        LDA  FPA0+1         * ADD NEXT BYTE 
2922 91ce 99 5e                        ADCA FPA1+1         * OF MANTISSA 
2923 91d0 97 51                        STA  FPA0+1         SAVE IN FPA0 
2924 91d2 96 50                        LDA  FPA0           * ADD MS BYTE 
2925 91d4 99 5d                        ADCA FPA1           * OF MANTISSA 
2926 91d6 97 50                        STA  FPA0           SAVE IN FPA0 
2927 91d8 5d                           TSTB TEST SIGN FLAG  
2928 91d9 2a 44                        BPL  LBA5C          BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE 
2929 91db 25 02              LBA18     BCS  LBA1C          BRANCH IF POSITIVE MANTISSA 
2930 91dd 8d 5d                        BSR  LBA79          NEGATE FPA0 MANTISSA 
2931                                                        
2932                         * NORMALIZE FPA0                      
2933 91df 5f                 LBA1C     CLRB                CLEAR TEMPORARY EXPONENT ACCUMULATOR 
2934 91e0 96 50              LBA1D     LDA  FPA0           TEST MSB OF MANTISSA 
2935 91e2 26 2e                        BNE  LBA4F          BRANCH IF <> 0 
2936 91e4 96 51                        LDA  FPA0+1         * IF THE MSB IS 
2937 91e6 97 50                        STA  FPA0           * 0, THEN SHIFT THE 
2938 91e8 96 52                        LDA  FPA0+2         * MANTISSA A WHOLE BYTE 
2939 91ea 97 51                        STA  FPA0+1         * AT A TIME. THIS 
2940 91ec 96 53                        LDA  FPA0+3         * IS FASTER THAN ONE 
2941 91ee 97 52                        STA  FPA0+2         * BIT AT A TIME 
2942 91f0 96 63                        LDA  FPSBYT         * BUT USES MORE MEMORY. 
2943 91f2 97 53                        STA  FPA0+3         * FPSBYT, THE CARRY IN 
2944 91f4 0f 63                        CLR  FPSBYT         * BYTE, REPLACES THE MATISSA LSB. 
2945 91f6 cb 08                        ADDB #8             SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT 
2946 91f8 c1 28                        CMPB #5*8           CHECK FOR 5 SHIFTS 
2947 91fa 2d e4                        BLT  LBA1D          BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0 
2948 91fc 4f                 LBA39     CLRA                A ZERO EXPONENT = 0 FLOATING POINT 
2949 91fd 97 4f              LBA3A     STA  FP0EXP         ZERO OUT THE EXPONENT 
2950 91ff 97 54                        STA  FP0SGN         ZERO OUT THE MANTISSA SIGN 
2951 9201 39                 LBA3E     RTS                  
2952 9202 8d 6d              LBA3F     BSR  LBAAE          SHIFT FPA0 MANTISSA TO RIGHT 
2953 9204 5f                           CLRB                CLEAR CARRY FLAG 
2954 9205 20 a8                        BRA  LB9EC           
2955                         * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7                      
2956                         * OF MATISSA MS BYTE = 1                      
2957 9207 5c                 LBA44     INCB                ADD ONE TO EXPONENT ACCUMULATOR 
2958 9208 08 63                        ASL  FPSBYT         SHIFT SUB BYTE ONE LEFT 
2959 920a 09 53                        ROL  FPA0+3         SHIFT LS BYTE 
2960 920c 09 52                        ROL  FPA0+2         SHIFT NS BYTE 
2961 920e 09 51                        ROL  FPA0+1         SHIFT NS BYTE 
2962 9210 09 50                        ROL  FPA0           SHIFT MS BYTE 
2963 9212 2a f3              LBA4F     BPL  LBA44          BRANCH IF NOT YET NORMALIZED 
2964 9214 96 4f                        LDA  FP0EXP         GET CURRENT EXPONENT 
2965 9216 34 04                        PSHS B              SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION 
2966 9218 a0 e0                        SUBA ,S+            SUBTRACT ACCUMULATED EXPONENT MODIFIER 
2967 921a 97 4f                        STA  FP0EXP         SAVE AS NEW EXPONENT 
2968 921c 23 de                        BLS  LBA39          SET FPA0 = 0 IF THE NORMALIZATION CAUSED 
2969                         *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE  
2970                         *         SIZE OF THE EXPONENT  
2971 921e 8c                           FCB  SKP2           SKIP 2 BYTES 
2972 921f 25 08              LBA5C     BCS  LBA66          BRANCH IF MANTISSA OVERFLOW 
2973 9221 08 63                        ASL  FPSBYT         SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF 
2974                         *                             FLAG (TRUNCATE THE REST OF SUB BYTE) 
2975 9223 86 00                        LDA  #0             CLRA, BUT DO NOT CHANGE CARRY FLAG 
2976 9225 97 63                        STA  FPSBYT         CLEAR THE SUB BYTE 
2977 9227 20 0c                        BRA  LBA72          GO ROUND-OFF RESULT 
2978 9229 0c 4f              LBA66     INC  FP0EXP         INCREMENT EXPONENT - MULTIPLY BY 2 
2979 922b 27 28                        BEQ  LBA92          OVERFLOW ERROR IF CARRY PAST $FF 
2980 922d 06 50                        ROR  FPA0           * SHIFT MANTISSA 
2981 922f 06 51                        ROR  FPA0+1         * ONE TO 
2982 9231 06 52                        ROR  FPA0+2         * THE RIGHT - 
2983 9233 06 53                        ROR  FPA0+3         * DIVIDE BY TWO 
2984 9235 24 04              LBA72     BCC  LBA78          BRANCH IF NO ROUND-OFF NEEDED 
2985 9237 8d 0d                        BSR  LBA83          ADD ONE TO MANTISSA - ROUND OFF 
2986 9239 27 ee                        BEQ  LBA66          BRANCH iF OVERFLOW - MANTISSA = 0 
2987 923b 39                 LBA78     RTS                  
2988                         * NEGATE FPA0 MANTISSA                      
2989 923c 03 54              LBA79     COM  FP0SGN         TOGGLE SIGN OF MANTISSA 
2990 923e 03 50              LBA7B     COM  FPA0           * COMPLEMENT ALL 4 MANTISSA BYTES 
2991 9240 03 51                        COM  FPA0+1         * 
2992 9242 03 52                        COM  FPA0+2         * 
2993 9244 03 53                        COM  FPA0+3         * 
2994                         * ADD ONE TO FPA0 MANTISSA                      
2995 9246 9e 52              LBA83     LDX  FPA0+2         * GET BOTTOM 2 MANTISSA 
2996 9248 30 01                        LEAX 1,X            * BYTES, ADD ONE TO 
2997 924a 9f 52                        STX  FPA0+2         * THEM AND SAVE THEM 
2998 924c 26 06                        BNE  LBA91          BRANCH IF NO OVERFLOW 
2999 924e 9e 50                        LDX  FPA0           * IF OVERFLOW ADD ONE 
3000 9250 30 01                        LEAX 1,X            * TO TOP 2 MANTISSA 
3001 9252 9f 50                        STX  FPA0           * BYTES AND SAVE THEM 
3002 9254 39                 LBA91     RTS                  
3003 9255 c6 0a              LBA92     LDB  #2*5           OV' OVERFLOW ERROR 
3004 9257 7e 84 41                     JMP  LAC46          PROCESS AN ERROR 
3005 925a 8e 00 12           LBA97     LDX  #FPA2-1        POINT X TO FPA2 
3006                         * SHIFT FPA POINTED TO BY (X) TO                      
3007                         * THE RIGHT -(B) TIMES. EXIT WITH                      
3008                         * ACCA CONTAINING DATA SHIFTED OUT                      
3009                         * TO THE RIGHT (SUB BYTE) AND THE DATA                      
3010                         * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY                      
3011 925d a6 04              LBA9A     LDA  4,X            GET LS BYTE OF MANTISSA (X) 
3012 925f 97 63                        STA  FPSBYT         SAVE IN FPA SUB BYTE 
3013 9261 a6 03                        LDA  3,X            * SHIFT THE NEXT THREE BYTES OF THE 
3014 9263 a7 04                        STA  4,X            * MANTISSA RIGHT ONE COMPLETE BYTE. 
3015 9265 a6 02                        LDA  2,X            * 
3016 9267 a7 03                        STA  3,X            * 
3017 9269 a6 01                        LDA  1,X            * 
3018 926b a7 02                        STA  2,X            * 
3019 926d 96 5b                        LDA  FPCARY         GET THE CARRY IN BYTE 
3020 926f a7 01                        STA  1,X            STORE AS THE MS MANTISSA BYTE OF (X) 
3021 9271 cb 08              LBAAE     ADDB #8             ADD 8 TO DIFFERENCE OF EXPONENTS 
3022 9273 2f e8                        BLE  LBA9A          BRANCH IF EXPONENT DIFFERENCE < -8 
3023 9275 96 63                        LDA  FPSBYT         GET FPA SUB BYTE 
3024 9277 c0 08                        SUBB #8             CAST OUT THE 8 ADDED IN ABOVE 
3025 9279 27 0c                        BEQ  LBAC4          BRANCH IF EXPONENT DIFFERENCE = 0 
3026                                                        
3027                                                        
3028 927b 67 01              LBAB8     ASR  1,X            * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT 
3029 927d 66 02              LBABA     ROR  2,X            * 
3030 927f 66 03                        ROR  3,X            * 
3031 9281 66 04                        ROR  4,X            * 
3032 9283 46                           RORA                * 
3033 9284 5c                           INCB                ADD ONE TO EXPONENT DIFFERENCE 
3034 9285 26 f4                        BNE  LBAB8          BRANCH IF EXPONENTS NOT = 
3035 9287 39                 LBAC4     RTS                  
3036 9288 81 00 00 00 00     LBAC5     FCB  $81,$00,$00,$00,$00 FLOATING POINT CONSTANT 1.0 
3037                                                        
3038                         * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY                      
3039                         * FPA0 BY (X) - RETURN PRODUCT IN FPA0                      
3040 928d 8d 63              LBACA     BSR  LBB2F          MOVE PACKED FPA FROM (X) TO FPA1 
3041 928f 27 60              LBACC     BEQ  LBB2E          BRANCH IF EXPONENT OF FPA0 = 0 
3042 9291 8d 78                        BSR  LBB48          CALCULATE EXPONENT OF PRODUCT 
3043                         * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE                      
3044                         * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE                      
3045                         * LOW ORDER FOUR BYTES OF THE PRODUCT WILL                      
3046                         * BE STORED IN VAB-VAE.                      
3047 9293 86 00              LBAD0     LDA  #0             * ZERO OUT MANTISSA OF FPA2 
3048 9295 97 13                        STA  FPA2           * 
3049 9297 97 14                        STA  FPA2+1         * 
3050 9299 97 15                        STA  FPA2+2         * 
3051 929b 97 16                        STA  FPA2+3         * 
3052 929d d6 53                        LDB  FPA0+3         GET LS BYTE OF FPA0 
3053 929f 8d 22                        BSR  LBB00          MULTIPLY BY FPA1 
3054 92a1 d6 63                        LDB  FPSBYT         * TEMPORARILY SAVE SUB BYTE 4 
3055 92a3 d7 81                        STB  VAE            * 
3056 92a5 d6 52                        LDB  FPA0+2         GET NUMBER 3 MANTISSA BYTE OF FPA0 
3057 92a7 8d 1a                        BSR  LBB00          MULTIPLY BY FPA1 
3058 92a9 d6 63                        LDB  FPSBYT         * TEMPORARILY SAVE SUB BYTE 3 
3059 92ab d7 80                        STB  VAD            * 
3060 92ad d6 51                        LDB  FPA0+1         GET NUMBER 2 MANTISSA BYTE OF FPA0 
3061 92af 8d 12                        BSR  LBB00          MULTIPLY BY FPA1 
3062 92b1 d6 63                        LDB  FPSBYT         * TEMPORARILY SAVE SUB BYTE 2 
3063 92b3 d7 7f                        STB  VAC            * 
3064 92b5 d6 50                        LDB  FPA0           GET MS BYTE OF FPA0 MANTISSA 
3065 92b7 8d 0c                        BSR  LBB02          MULTIPLY BY FPA1 
3066 92b9 d6 63                        LDB  FPSBYT         * TEMPORARILY SAVE SUB BYTE 1 
3067 92bb d7 7e                        STB  VAB            * 
3068 92bd bd 93 ce                     JSR  LBC0B          COPY MANTISSA FROM FPA2 TO FPA0 
3069 92c0 7e 91 df                     JMP  LBA1C          NORMALIZE FPA0 
3070 92c3 27 95              LBB00     BEQ  LBA97          SHIFT FPA2 ONE BYTE TO RIGHT 
3071 92c5 43                 LBB02     COMA                SET CARRY FLAG 
3072                         * MULTIPLY FPA1 MANTISSA BY ACCB AND                      
3073                         * ADD PRODUCT TO FPA2 MANTISSA                      
3074 92c6 96 13              LBB03     LDA  FPA2           GET FPA2 MS BYTE 
3075 92c8 56                           RORB ROTATE CARRY FLAG INTO SHIFT COUNTER;  
3076                         *         DATA BIT INTO CARRY  
3077 92c9 27 26                        BEQ  LBB2E          BRANCH WHEN 8 SHIFTS DONE 
3078 92cb 24 16                        BCC  LBB20          DO NOT ADD FPA1 IF DATA BIT = 0 
3079 92cd 96 16                        LDA  FPA2+3         * ADD MANTISSA LS BYTE 
3080 92cf 9b 60                        ADDA FPA1+3         * 
3081 92d1 97 16                        STA  FPA2+3         * 
3082 92d3 96 15                        LDA  FPA2+2         = ADD MANTISSA NUMBER 3 BYTE 
3083 92d5 99 5f                        ADCA FPA1+2         = 
3084 92d7 97 15                        STA  FPA2+2         = 
3085 92d9 96 14                        LDA  FPA2+1         * ADD MANTISSA NUMBER 2 BYTE 
3086 92db 99 5e                        ADCA FPA1+1         * 
3087 92dd 97 14                        STA  FPA2+1         * 
3088 92df 96 13                        LDA  FPA2           = ADD MANTISSA MS BYTE 
3089 92e1 99 5d                        ADCA FPA1           = 
3090 92e3 46                 LBB20     RORA * ROTATE CARRY INTO MS BYTE  
3091 92e4 97 13                        STA  FPA2           * 
3092 92e6 06 14                        ROR  FPA2+1         = ROTATE FPA2 ONE BIT TO THE RIGHT 
3093 92e8 06 15                        ROR  FPA2+2         = 
3094 92ea 06 16                        ROR  FPA2+3         = 
3095 92ec 06 63                        ROR  FPSBYT         = 
3096 92ee 4f                           CLRA                CLEAR CARRY FLAG 
3097 92ef 20 d5                        BRA  LBB03          KEEP LOOPING 
3098 92f1 39                 LBB2E     RTS                  
3099                         * UNPACK A FP NUMBER FROM (X) TO FPA1                      
3100 92f2 ec 01              LBB2F     LDD  1,X            GET TWO MSB BYTES OF MANTISSA FROM 
3101                         *         FPA  POINTED TO BY X  
3102 92f4 97 61                        STA  FP1SGN         SAVE PACKED MANTISSA SIGN BYTE 
3103 92f6 8a 80                        ORA  #$80           FORCE BIT 7 OF MSB MANTISSA = 1 
3104 92f8 dd 5d                        STD  FPA1           SAVE 2 MSB BYTES IN FPA1 
3105 92fa d6 61                        LDB  FP1SGN         * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0 
3106 92fc d8 54                        EORB FP0SGN         * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE, 
3107 92fe d7 62                        STB  RESSGN         * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED 
3108                         *                             * MANTISSA SIGN BYTE 
3109 9300 ec 03                        LDD  3,X            = GET 2 LSB BYTES OF MANTISSA 
3110 9302 dd 5f                        STD  FPA1+2         = AND PUT IN FPA1 
3111 9304 a6 84                        LDA  ,X             * GET EXPONENT FROM (X) AND 
3112 9306 97 5c                        STA  FP1EXP         * PUT IN EXPONENT OF FPA1 
3113 9308 d6 4f                        LDB  FP0EXP         GET EXPONENT OF FPA0 
3114 930a 39                           RTS                  
3115                         * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1                      
3116                         * ENTER WITH EXPONENT OF FPA1 IN ACCA                      
3117 930b 4d                 LBB48     TSTA                TEST EXPONENT OF FPA1 
3118 930c 27 16                        BEQ  LBB61          PURGE RETURN ADDRESS & SET FPA0 = 0 
3119 930e 9b 4f                        ADDA FP0EXP         ADD FPA1 EXPONENT TO FPA0 EXPONENT 
3120 9310 46                           RORA                ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY 
3121 9311 49                           ROLA                SET OVERFLOW FLAG 
3122 9312 28 10                        BVC  LBB61          BRANCH IF EXPONENT TOO LARGE OR SMALL 
3123 9314 8b 80                        ADDA #$80           ADD $80 BIAS TO EXPONENT 
3124 9316 97 4f                        STA  FP0EXP         SAVE NEW EXPONENT 
3125 9318 27 0c                        BEQ  LBB63          SET FPA0 
3126 931a 96 62                        LDA  RESSGN         GET MANTISSA SIGN 
3127 931c 97 54                        STA  FP0SGN         SAVE AS MANTISSA SIGN OF FPA0 
3128 931e 39                           RTS                  
3129                         * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0                      
3130                         * = IS NEGATIVE THEN FPA0 = 0                      
3131 931f 96 54              LBB5C     LDA  FP0SGN         GET MANTISSA SIGN OF FPA0 
3132 9321 43                           COMA                CHANGE SIGN OF FPA0 MANTISSA 
3133 9322 20 02                        BRA  LBB63           
3134 9324 32 62              LBB61     LEAS 2,S            PURGE RETURN ADDRESS FROM STACK 
3135 9326 10 2a fe d2        LBB63     LBPL LBA39          ZERO FPA0 MANTISSA SIGN & EXPONENT 
3136 932a 7e 92 55           LBB67     JMP  LBA92          OV' OVERFLOW ERROR 
3137                         * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0                      
3138 932d bd 94 22           LBB6A     JSR  LBC5F          TRANSFER FPA0 TO FPA1 
3139 9330 27 0d                        BEQ  LBB7C          BRANCH IF EXPONENT = 0 
3140 9332 8b 02                        ADDA #2             ADD 2 TO EXPONENT (TIMES 4) 
3141 9334 25 f4                        BCS  LBB67          OV' ERROR IF EXPONENT > $FF 
3142 9336 0f 62                        CLR  RESSGN         CLEAR RESULT SIGN BYTE 
3143 9338 bd 91 90                     JSR  LB9CD          ADD FPA1 TO FPA0 (TIMES 5) 
3144 933b 0c 4f                        INC  FP0EXP         ADD ONE TO EXPONENT (TIMES 10) 
3145 933d 27 eb                        BEQ  LBB67          OV' ERROR IF EXPONENT > $FF 
3146 933f 39                 LBB7C     RTS                  
3147 9340 84 20 00 00 00     LBB7D     FCB  $84,$20,$00,$00,$00 FLOATING POINT CONSTANT 10 
3148                         * DIVIDE FPA0 BY 10                      
3149 9345 bd 94 22           LBB82     JSR  LBC5F          MOVE FPA0 TO FPA1 
3150 9348 8e 93 40                     LDX  #LBB7D         POINT TO FLOATING POINT CONSTANT 10 
3151 934b 5f                           CLRB                ZERO MANTISSA SIGN BYTE 
3152 934c d7 62              LBB89     STB  RESSGN         STORE THE QUOTIENT MANTISSA SIGN BYTE 
3153 934e bd 93 d7                     JSR  LBC14          UNPACK AN FP NUMBER FROM (X) INTO FPA0 
3154 9351 8c                           FCB  SKP2           SKIP TWO BYTES 
3155                         * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0                      
3156 9352 8d 9e              LBB8F     BSR  LBB2F          GET FP NUMBER FROM (X) TO FPA1 
3157                                                        
3158                         * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH                      
3159                         * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)                      
3160                                                        
3161                         * DIVIDE FPA1 BY FPA0                      
3162 9354 27 73              LBB91     BEQ  LBC06          /0' DIVIDE BY ZERO ERROR 
3163 9356 00 4f                        NEG  FP0EXP         GET EXPONENT OF RECIPROCAL OF DIVISOR 
3164 9358 8d b1                        BSR  LBB48          CALCULATE EXPONENT OF QUOTIENT 
3165 935a 0c 4f                        INC  FP0EXP         INCREMENT EXPONENT 
3166 935c 27 cc                        BEQ  LBB67          OV' OVERFLOW ERROR 
3167 935e 8e 00 13                     LDX  #FPA2          POINT X TO MANTISSA OF FPA2 - HOLD 
3168                         *                             TEMPORARY QUOTIENT IN FPA2 
3169 9361 c6 04                        LDB  #4             5 BYTE DIVIDE 
3170 9363 d7 03                        STB  TMPLOC         SAVE BYTE COUNTER 
3171 9365 c6 01                        LDB  #1             SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE 
3172                         * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -                      
3173                         * SET CARRY FLAG IF FPA1 >= FPA0                      
3174 9367 96 50              LBBA4     LDA  FPA0           * COMPARE THE TWO MS BYTES 
3175 9369 91 5d                        CMPA FPA1           * OF FPA0 AND FPA1 AND 
3176 936b 26 13                        BNE  LBBBD          * BRANCH IF <> 
3177 936d 96 51                        LDA  FPA0+1         = COMPARE THE NUMBER 2 
3178 936f 91 5e                        CMPA FPA1+1         = BYTES AND 
3179 9371 26 0d                        BNE  LBBBD          = BRANCH IF <> 
3180 9373 96 52                        LDA  FPA0+2         * COMPARE THE NUMBER 3 
3181 9375 91 5f                        CMPA FPA1+2         * BYTES AND 
3182 9377 26 07                        BNE  LBBBD          * BRANCH IF <> 
3183 9379 96 53                        LDA  FPA0+3         = COMPARE THE LS BYTES 
3184 937b 91 60                        CMPA FPA1+3         = AND BRANCH 
3185 937d 26 01                        BNE  LBBBD          = IF <> 
3186 937f 43                           COMA                SET CARRY FLAG IF FPA0 = FPA1 
3187 9380 1f a8              LBBBD     TFR  CC,A           SAVE CARRY FLAG STATUS IN ACCA; CARRY 
3188                         *         CLEAR IF FPA0 > FPA1  
3189 9382 59                           ROLB                ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE 
3190 9383 24 0a                        BCC  LBBCC          CARRY WILL BE SET AFTER 8 SHIFTS 
3191 9385 e7 80                        STB  ,X+            SAVE TEMPORARY QUOTIENT 
3192 9387 0a 03                        DEC  TMPLOC         DECREMENT BYTE COUNTER 
3193 9389 2b 34                        BMI  LBBFC          BRANCH IF DONE 
3194 938b 27 2e                        BEQ  LBBF8          BRANCH IF LAST BYTE 
3195 938d c6 01                        LDB  #1             RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE 
3196 938f 1f 8a              LBBCC     TFR  A,CC           RESTORE CARRY FLAG AND 
3197 9391 25 0e                        BCS  LBBDE          BRANCH IF FPA0 =< FPA1 
3198 9393 08 60              LBBD0     ASL  FPA1+3         * SHIFT FPA1 MANTISSA 1 BIT TO LEFT 
3199 9395 09 5f                        ROL  FPA1+2         * 
3200 9397 09 5e                        ROL  FPA1+1         * 
3201 9399 09 5d                        ROL  FPA1           * 
3202 939b 25 e3                        BCS  LBBBD          BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT 
3203 939d 2b c8                        BMI  LBBA4          IF MSB OF HIGH ORDER MANTISSA BYTE IS 
3204                         *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1  
3205 939f 20 df                        BRA  LBBBD          CARRY IS CLEAR, CHECK ANOTHER BIT 
3206                         * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1                      
3207 93a1 96 60              LBBDE     LDA  FPA1+3         * SUBTRACT THE LS BYTES OF MANTISSA 
3208 93a3 90 53                        SUBA FPA0+3         * 
3209 93a5 97 60                        STA  FPA1+3         * 
3210 93a7 96 5f                        LDA  FPA1+2         = THEN THE NEXT BYTE 
3211 93a9 92 52                        SBCA FPA0+2         = 
3212 93ab 97 5f                        STA  FPA1+2         = 
3213 93ad 96 5e                        LDA  FPA1+1         * AND THE NEXT 
3214 93af 92 51                        SBCA FPA0+1         * 
3215 93b1 97 5e                        STA  FPA1+1         * 
3216 93b3 96 5d                        LDA  FPA1           = AND FINALLY, THE MS BYTE OF MANTISSA 
3217 93b5 92 50                        SBCA FPA0           = 
3218 93b7 97 5d                        STA  FPA1           = 
3219 93b9 20 d8                        BRA  LBBD0          GO SHIFT FPA1 
3220 93bb c6 40              LBBF8     LDB  #$40           USE ONLY TWO BITS OF THE LAST BYTE (FIFTH) 
3221 93bd 20 d0                        BRA  LBBCC          GO SHIFT THE LAST BYTE 
3222 93bf 56                 LBBFC     RORB * SHIFT CARRY (ALWAYS SET HERE) INTO  
3223 93c0 56                           RORB * BIT 5 AND MOVE  
3224 93c1 56                           RORB * BITS 1,0 TO BITS 7,6  
3225 93c2 d7 63                        STB  FPSBYT         SAVE SUB BYTE 
3226 93c4 8d 08                        BSR  LBC0B          MOVE MANTISSA OF FPA2 TO FPA0 
3227 93c6 7e 91 df                     JMP  LBA1C          NORMALIZE FPA0 
3228 93c9 c6 14              LBC06     LDB  #2*10          /0' ERROR 
3229 93cb 7e 84 41                     JMP  LAC46          PROCESS THE ERROR 
3230                         * COPY MANTISSA FROM FPA2 TO FPA0                      
3231 93ce 9e 13              LBC0B     LDX  FPA2           * MOVE TOP 2 BYTES 
3232 93d0 9f 50                        STX  FPA0           * 
3233 93d2 9e 15                        LDX  FPA2+2         = MOVE BOTTOM 2 BYTES 
3234 93d4 9f 52                        STX  FPA0+2         = 
3235 93d6 39                           RTS                  
3236                         * COPY A PACKED FP NUMBER FROM (X) TO FPA0                      
3237 93d7 34 02              LBC14     PSHS A              SAVE ACCA 
3238 93d9 ec 01                        LDD  1,X            GET TOP TWO MANTISSA BYTES 
3239 93db 97 54                        STA  FP0SGN         SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN 
3240 93dd 8a 80                        ORA  #$80           UNPACK MS BYTE 
3241 93df dd 50                        STD  FPA0           SAVE UNPACKED TOP 2 MANTISSA BYTES 
3242 93e1 0f 63                        CLR  FPSBYT         CLEAR MANTISSA SUB BYTE 
3243 93e3 e6 84                        LDB  ,X             GET EXPONENT TO ACCB 
3244 93e5 ae 03                        LDX  3,X            * MOVE LAST 2 
3245 93e7 9f 52                        STX  FPA0+2         * MANTISSA BYTES 
3246 93e9 d7 4f                        STB  FP0EXP         SAVE EXPONENT 
3247 93eb 35 82                        PULS A,PC           RESTORE ACCA AND RETURN 
3248                                                        
3249 93ed 8e 00 45           LBC2A     LDX  #V45           POINT X TO MANTISSA OF FPA4 
3250 93f0 20 06                        BRA  LBC35          MOVE FPA0 TO FPA4 
3251 93f2 8e 00 40           LBC2F     LDX  #V40           POINT X TO MANTISSA OF FPA3 
3252 93f5 8c                           FCB  SKP2           SKIP TWO BYTES 
3253 93f6 9e 3b              LBC33     LDX  VARDES         POINT X TO VARIABLE DESCRIPTOR IN VARDES 
3254                         * PACK FPA0 AND MOVE IT TO ADDRESS IN X                      
3255 93f8 96 4f              LBC35     LDA  FP0EXP         * COPY EXPONENT 
3256 93fa a7 84                        STA  ,X             * 
3257 93fc 96 54                        LDA  FP0SGN         GET MANTISSA SIGN BIT 
3258 93fe 8a 7f                        ORA  #$7F           MASK THE BOTTOM 7 BITS 
3259 9400 94 50                        ANDA FPA0           AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE 
3260 9402 a7 01                        STA  1,X            SAVE MS BYTE 
3261 9404 96 51                        LDA  FPA0+1         * MOVE 2ND MANTISSA BYTE 
3262 9406 a7 02                        STA  2,X            * 
3263 9408 de 52                        LDU  FPA0+2         = MOVE BOTTOM 2 MANTISSA BYTES 
3264 940a ef 03                        STU  3,X            = 
3265 940c 39                           RTS                  
3266                         * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA                      
3267 940d 96 61              LBC4A     LDA  FP1SGN         * COPY MANTISSA SIGN FROM 
3268 940f 97 54              LBC4C     STA  FP0SGN         * FPA1 TO FPA0 
3269 9411 9e 5c                        LDX  FP1EXP         = COPY EXPONENT + MS BYTE FROM 
3270 9413 9f 4f                        STX  FP0EXP         = FPA1 TO FPA0 
3271 9415 0f 63                        CLR  FPSBYT         CLEAR MANTISSA SUB BYTE 
3272 9417 96 5e                        LDA  FPA1+1         * COPY 2ND MANTISSA BYTE 
3273 9419 97 51                        STA  FPA0+1         * FROM FPA1 TO FPA0 
3274 941b 96 54                        LDA  FP0SGN         GET MANTISSA SIGN 
3275 941d 9e 5f                        LDX  FPA1+2         * COPY 3RD AND 4TH MANTISSA BYTE 
3276 941f 9f 52                        STX  FPA0+2         * FROM FPA1 TO FPA0 
3277 9421 39                           RTS                  
3278                         * TRANSFER FPA0 TO FPA1                      
3279 9422 dc 4f              LBC5F     LDD  FP0EXP         * TRANSFER EXPONENT & MS BYTE 
3280 9424 dd 5c                        STD  FP1EXP         * 
3281 9426 9e 51                        LDX  FPA0+1         = TRANSFER MIDDLE TWO BYTES 
3282 9428 9f 5e                        STX  FPA1+1         = 
3283 942a 9e 53                        LDX  FPA0+3         * TRANSFER BOTTOM TWO BYTES 
3284 942c 9f 60                        STX  FPA1+3         * 
3285 942e 4d                           TSTA                SET FLAGS ACCORDING TO EXPONENT 
3286 942f 39                           RTS                  
3287                         * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,                      
3288                         * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE                      
3289 9430 d6 4f              LBC6D     LDB  FP0EXP         GET EXPONENT 
3290 9432 27 08                        BEQ  LBC79          BRANCH IF FPA0 = 0 
3291 9434 d6 54              LBC71     LDB  FP0SGN         GET SIGN OF MANTISSA 
3292 9436 59                 LBC73     ROLB                BIT 7 TO CARRY 
3293 9437 c6 ff                        LDB  #$FF           NEGATIVE FLAG 
3294 9439 25 01                        BCS  LBC79          BRANCH IF NEGATIVE MANTISSA 
3295 943b 50                           NEGB                ACCB = 1 IF POSITIVE MANTISSA 
3296 943c 39                 LBC79     RTS                  
3297                                                        
3298                         * SGN                          
3299 943d 8d f1              SGN       BSR  LBC6D          SET ACCB ACCORDING TO SIGN OF FPA0 
3300                         * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER                      
3301 943f d7 50              LBC7C     STB  FPA0           SAVE ACCB IN FPA0 
3302 9441 0f 51                        CLR  FPA0+1         CLEAR NUMBER 2 MANTISSA BYTE OF FPA0 
3303 9443 c6 88                        LDB  #$88           EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER 
3304 9445 96 50              LBC82     LDA  FPA0           GET MS BYTE OF MANTISSA 
3305 9447 80 80                        SUBA #$80           SET CARRY IF POSITIVE MANTISSA 
3306 9449 d7 4f              LBC86     STB  FP0EXP         SAVE EXPONENT 
3307 944b dc 74                        LDD  ZERO           * ZERO OUT ACCD AND 
3308 944d dd 52                        STD  FPA0+2         * BOTTOM HALF OF FPA0 
3309 944f 97 63                        STA  FPSBYT         CLEAR SUB BYTE 
3310 9451 97 54                        STA  FP0SGN         CLEAR SIGN OF FPA0 MANTISSA 
3311 9453 7e 91 db                     JMP  LBA18          GO NORMALIZE FPA0 
3312                                                        
3313                         * ABS                          
3314 9456 0f 54              ABS       CLR  FP0SGN         FORCE MANTISSA SIGN OF FPA0 POSITIVE 
3315 9458 39                           RTS                  
3316                         * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO                      
3317                         * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN                      
3318                         * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF                      
3319                         * FPA0 > (X); ACCB = $FF IF FPA0 < (X)                      
3320 9459 e6 84              LBC96     LDB  ,X             CHECK EXPONENT OF (X) 
3321 945b 27 d3                        BEQ  LBC6D          BRANCH IF FPA = 0 
3322 945d e6 01                        LDB  1,X            GET MS BYTE OF MANTISSA OF (X) 
3323 945f d8 54                        EORB FP0SGN         EOR WITH SIGN OF FPA0 
3324 9461 2b d1                        BMI  LBC71          BRANCH IF SIGNS NOT = 
3325                         * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).                      
3326                         * FPA0 IS NORMALIZED, (X) IS PACKED.                      
3327 9463 d6 4f              LBCA0     LDB  FP0EXP         * GET EXPONENT OF 
3328 9465 e1 84                        CMPB ,X             * FPA0, COMPARE TO EXPONENT OF 
3329 9467 26 1d                        BNE  LBCC3          * (X) AND BRANCH IF <>. 
3330 9469 e6 01                        LDB  1,X            * GET MS BYTE OF (X), KEEP ONLY 
3331 946b ca 7f                        ORB  #$7F           * THE SIGN BIT - 'AND' THE BOTTOM 7 
3332 946d d4 50                        ANDB FPA0           * BITS OF FPA0 INTO ACCB 
3333 946f e1 01                        CMPB 1,X            = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA 
3334 9471 26 13                        BNE  LBCC3          = MS BYTE AND BRANCH IF <> 
3335 9473 d6 51                        LDB  FPA0+1         * COMPARE 2ND BYTE 
3336 9475 e1 02                        CMPB 2,X            * OF MANTISSA, 
3337 9477 26 0d                        BNE  LBCC3          * BRANCH IF <> 
3338 9479 d6 52                        LDB  FPA0+2         = COMPARE 3RD BYTE 
3339 947b e1 03                        CMPB 3,X            = OF MANTISSA, 
3340 947d 26 07                        BNE  LBCC3          = BRANCH IF <> 
3341 947f d6 53                        LDB  FPA0+3         * SUBTRACT LS BYTE 
3342 9481 e0 04                        SUBB 4,X            * OF (X) FROM LS BYTE OF 
3343 9483 26 01                        BNE  LBCC3          * FPA0, BRANCH IF <> 
3344 9485 39                           RTS                 RETURN IF FP (X) = FPA0 
3345 9486 56                 LBCC3     RORB                SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X) 
3346 9487 d8 54                        EORB FP0SGN         TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE 
3347 9489 20 ab                        BRA  LBC73          GO SET ACCB ACCORDING TO COMPARISON 
3348                         * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT                      
3349                         * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA                      
3350 948b d6 4f              LBCC8     LDB  FP0EXP         GET EXPONENT OF FPA0 
3351 948d 27 3d                        BEQ  LBD09          ZERO MANTISSA IF FPA0 = 0 
3352 948f c0 a0                        SUBB #$A0           SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD 
3353                         *                             THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN 
3354                         *                             THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT 
3355                         *                             WILL BE TO THE RIGHT OF THE MANTISSA 
3356 9491 96 54                        LDA  FP0SGN         TEST SIGN OF FPA0 MANTISSA 
3357 9493 2a 05                        BPL  LBCD7          BRANCH IF POSITIVE 
3358 9495 03 5b                        COM  FPCARY         COMPLEMENT CARRY IN BYTE 
3359 9497 bd 92 3e                     JSR  LBA7B          NEGATE MANTISSA OF FPA0 
3360 949a 8e 00 4f           LBCD7     LDX  #FP0EXP        POINT X TO FPA0 
3361 949d c1 f8                        CMPB #-8            EXPONENT DIFFERENCE < -8? 
3362 949f 2e 06                        BGT  LBCE4          YES 
3363 94a1 bd 92 71                     JSR  LBAAE          SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0 
3364 94a4 0f 5b                        CLR  FPCARY         CLEAR CARRY IN BYTE 
3365 94a6 39                           RTS                  
3366 94a7 0f 5b              LBCE4     CLR  FPCARY         CLEAR CARRY IN BYTE 
3367 94a9 96 54                        LDA  FP0SGN         * GET SIGN OF FPA0 MANTISSA 
3368 94ab 49                           ROLA                * ROTATE IT INTO THE CARRY FLAG 
3369 94ac 06 50                        ROR  FPA0           ROTATE CARRY (MANTISSA SIGN) INTO BIT 7 
3370                         *                             OF LS BYTE OF MANTISSA 
3371 94ae 7e 92 7d                     JMP  LBABA          DE-NORMALIZE FPA0 
3372                                                        
3373                         * INT                          
3374                         * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT                      
3375                         * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE                      
3376                         * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT                      
3377                         * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION                      
3378                         * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.                      
3379                         *                              
3380 94b1 d6 4f              INT       LDB  FP0EXP         GET EXPONENT OF FPA0 
3381 94b3 c1 a0                        CMPB #$A0           LARGEST POSSIBLE INTEGER EXPONENT 
3382 94b5 24 1d                        BCC  LBD11          RETURN IF FPA0 >= 32768 
3383 94b7 8d d2                        BSR  LBCC8          SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE 
3384                         *                             LS BYTE OF THE FPA0 MANTISSA 
3385 94b9 d7 63                        STB  FPSBYT         ACCB = 0: ZERO OUT THE SUB BYTE 
3386 94bb 96 54                        LDA  FP0SGN         GET MANTISSA SIGN 
3387 94bd d7 54                        STB  FP0SGN         FORCE MANTISSA SIGN TO BE POSITIVE 
3388 94bf 80 80                        SUBA #$80           SET CARRY IF MANTISSA 
3389 94c1 86 a0                        LDA  #$A0           * GET DENORMALIZED EXPONENT AND 
3390 94c3 97 4f                        STA  FP0EXP         * SAVE IT IN FPA0 EXPONENT 
3391 94c5 96 53                        LDA  FPA0+3         = GET LS BYTE OF FPA0 AND 
3392 94c7 97 01                        STA  CHARAC         = SAVE IT IN CHARAC 
3393 94c9 7e 91 db                     JMP  LBA18          NORMALIZE FPA0 
3394                                                        
3395 94cc d7 50              LBD09     STB  FPA0           * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB 
3396 94ce d7 51                        STB  FPA0+1         * 
3397 94d0 d7 52                        STB  FPA0+2         * 
3398 94d2 d7 53                        STB  FPA0+3         * 
3399 94d4 39                 LBD11     RTS                 * 
3400                                                        
3401                         * CONVERT ASCII STRING TO FLOATING POINT                      
3402 94d5 9e 74              LBD12     LDX  ZERO           (X) = 0 
3403 94d7 9f 54                        STX  FP0SGN         * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT) 
3404 94d9 9f 4f                        STX  FP0EXP         * 
3405 94db 9f 51                        STX  FPA0+1         * 
3406 94dd 9f 52                        STX  FPA0+2         * 
3407 94df 9f 47                        STX  V47            INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO 
3408 94e1 9f 45                        STX  V45            INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0 
3409 94e3 25 69                        BCS  LBD86          IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST 
3410                         *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK  
3411 94e5 9d f8                        JSR  RVEC19         HOOK INTO RAM 
3412 94e7 bd 9c 58                     JSR  XVEC19          
3413 94ea 81 2d              LBD25     CMPA #'-'            * CHECK FOR A LEADING MINUS SIGN AND BRANCH 
3414 94ec 26 04                        BNE  LBD2D          * IF NO MINUS SIGN 
3415 94ee 03 55                        COM  COEFCT         TOGGLE SIGN; 0 = +; FF = - 
3416 94f0 20 04                        BRA  LBD31          INTERPRET THE REST OF THE STRING 
3417 94f2 81 2b              LBD2D     CMPA #'+'            * CHECK FOR LEADING PLUS SlGN AND BRANCH 
3418 94f4 26 05                        BNE  LBD35          * IF NOT A PLUS SIGN 
3419 94f6 bd a4 b3           LBD31     JSR  GETNCH         GET NEXT INPUT CHARACTER FROM BASIC 
3420 94f9 25 53                        BCS  LBD86          BRANCH IF NUMERIC CHARACTER 
3421 94fb 81 2e              LBD35     CMPA #'.'            DECIMAL POlNT? 
3422 94fd 27 2a                        BEQ  LBD61          YES 
3423 94ff 81 45                        CMPA #'E'            "E" SHORTHAND FORM (SCIENTIFIC NOTATION)? 
3424 9501 26 2a                        BNE  LBD65          NO 
3425                         * EVALUATE EXPONENT OF EXPONENTIAL FORMAT                      
3426 9503 bd a4 b3                     JSR  GETNCH         GET NEXT INPUT CHARACTER FROM BASIC 
3427 9506 25 65                        BCS  LBDA5          BRANCH IF NUMERIC 
3428 9508 81 ac                        CMPA #$AC           MINUS TOKEN? 
3429 950a 27 0e                        BEQ  LBD53          YES 
3430 950c 81 2d                        CMPA #'-'            ASCII MINUS? 
3431 950e 27 0a                        BEQ  LBD53          YES 
3432 9510 81 ab                        CMPA #$AB           PLUS TOKEN? 
3433 9512 27 08                        BEQ  LBD55          YES 
3434 9514 81 2b                        CMPA #'+'            ASCII PLUS? 
3435 9516 27 04                        BEQ  LBD55          YES 
3436 9518 20 07                        BRA  LBD59          BRANCH IF NO SIGN FOUND 
3437 951a 03 48              LBD53     COM  V48            SET EXPONENT SIGN FLAG TO NEGATIVE 
3438                         * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47                      
3439 951c bd a4 b3           LBD55     JSR  GETNCH         GET NEXT INPUT CHARACTER FROM BASIC 
3440 951f 25 4c                        BCS  LBDA5          IF NUMERIC CHARACTER, CONVERT TO BINARY 
3441 9521 0d 48              LBD59     TST  V48            * CHECK EXPONENT SIGN FLAG 
3442 9523 27 08                        BEQ  LBD65          * AND BRANCH IF POSITIVE 
3443 9525 00 47                        NEG  V47            NEGATE VALUE OF EXPONENT 
3444 9527 20 04                        BRA  LBD65           
3445 9529 03 46              LBD61     COM  V46            *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER 
3446 952b 26 c9                        BNE  LBD31          *CHARACTER IF <> 0 - TERMINATE INTERPRETATION 
3447                         *         IF   SECOND DECIMAL POINT  
3448                         * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47                      
3449 952d 96 47              LBD65     LDA  V47            * GET EXPONENT, SUBTRACT THE NUMBER OF 
3450 952f 90 45                        SUBA V45            * PLACES TO THE RIGHT OF DECIMAL POINT 
3451 9531 97 47                        STA  V47            * AND RESAVE IT. 
3452 9533 27 12                        BEQ  LBD7F          EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO 
3453 9535 2a 09                        BPL  LBD78          BRANCH IF POSITIVE EXPONENT 
3454 9537 bd 93 45           LBD6F     JSR  LBB82          DIVIDE FPA0 BY 10 
3455 953a 0c 47                        INC  V47            INCREMENT EXPONENT COUNTER (MULTIPLY BY 10) 
3456 953c 26 f9                        BNE  LBD6F          KEEP MULTIPLYING 
3457 953e 20 07                        BRA  LBD7F          EXIT ROUTINE 
3458 9540 bd 93 2d           LBD78     JSR  LBB6A          MULTIPLY FPA0 BY 10 
3459 9543 0a 47                        DEC  V47            DECREMENT EXPONENT COUNTER (DIVIDE BY 10) 
3460 9545 26 f9                        BNE  LBD78          KEEP MULTIPLYING 
3461 9547 96 55              LBD7F     LDA  COEFCT         GET THE SIGN FLAG 
3462 9549 2a 89                        BPL  LBD11          RETURN IF POSITIVE 
3463 954b 7e 96 b1                     JMP  LBEE9          TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE 
3464                         *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT                      
3465 954e d6 45              LBD86     LDB  V45            *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT 
3466 9550 d0 46                        SUBB V46            *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT 
3467 9552 d7 45                        STB  V45            *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS 
3468                         *                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE 
3469 9554 34 02                        PSHS A              SAVE NEW DIGIT ON STACK 
3470 9556 bd 93 2d                     JSR  LBB6A          MULTIPLY FPA0 BY 10 
3471 9559 35 04                        PULS B              GET NEW DIGIT BACK 
3472 955b c0 30                        SUBB #'0'            MASK OFF ASCII 
3473 955d 8d 02                        BSR  LBD99          ADD ACCB TO FPA0 
3474 955f 20 95                        BRA  LBD31          GET ANOTHER CHARACTER FROM BASIC 
3475 9561 bd 93 f2           LBD99     JSR  LBC2F          PACK FPA0 AND SAVE IT IN FPA3 
3476 9564 bd 94 3f                     JSR  LBC7C          CONVERT ACCB TO FP NUMBER IN FPA0 
3477 9567 8e 00 40                     LDX  #V40           * ADD FPA0 TO 
3478 956a 7e 91 85                     JMP  LB9C2          * FPA3 
3479                                                        
3480                                                        
3481 956d d6 47              LBDA5     LDB  V47             
3482 956f 58                           ASLB                TIMES 2 
3483 9570 58                           ASLB                TIMES 4 
3484 9571 db 47                        ADDB V47            ADD 1 = TIMES 5 
3485 9573 58                           ASLB                TIMES 10 
3486 9574 80 30                        SUBA #'0'            *MASK OFF ASCII FROM ACCA, PUSH 
3487 9576 34 04                        PSHS B              *RESULT ONTO THE STACK AND 
3488 9578 ab e0                        ADDA ,S+            ADD lT TO ACCB 
3489 957a 97 47                        STA  V47            SAVE IN V47 
3490 957c 20 9e                        BRA  LBD55          INTERPRET ANOTHER CHARACTER 
3491                         *                              
3492 957e 9b 3e bc 1f fd     LBDB6     FCB  $9B,$3E,$BC,$1F,$FD * 99999999.9 
3493 9583 9e 6e 6b 27 fd     LBDBB     FCB  $9E,$6E,$6B,$27,$FD * 999999999 
3494 9588 9e 6e 6b 28 00     LBDC0     FCB  $9E,$6E,$6B,$28,$00 * 1E + 09 
3495                         *                              
3496 958d 8e 83 e2           LBDC5     LDX  #LABE8-1       POINT X TO " IN " MESSAGE 
3497 9590 8d 0c                        BSR  LBDD6          COPY A STRING FROM (X) TO CONSOLE OUT 
3498 9592 dc 68                        LDD  CURLIN         GET CURRENT BASIC LINE NUMBER TO ACCD 
3499                         * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER                      
3500                         * AND PRINT IT TO CONSOLE OUT                      
3501 9594 dd 50              LBDCC     STD  FPA0           SAVE ACCD IN TOP HALF OF FPA0 
3502 9596 c6 90                        LDB  #$90           REQ’D EXPONENT IF TOP HALF OF ACCD = INTEGER 
3503 9598 43                           COMA                SET CARRY FLAG - FORCE POSITIVE MANTISSA 
3504 9599 bd 94 49                     JSR  LBC86          ZERO BOTTOM HALF AND SIGN OF FPA0, THEN 
3505                         *         SAVE EXPONENT AND NORMALIZE IT  
3506 959c 8d 03                        BSR  LBDD9          CONVERT FP NUMBER TO ASCII STRING 
3507 959e 7e 91 5f           LBDD6     JMP  LB99C          COPY A STRING FROM (X) TO CONSOLE OUT 
3508                                                        
3509                         * CONVERT FP NUMBER TO ASCII STRING                      
3510 95a1 ce 02 2f           LBDD9     LDU  #STRBUF+3      POINT U TO BUFFER WHICH WILL NOT CAUSE 
3511                         *                             THE STRING TO BE STORED IN STRING SPACE 
3512 95a4 86 20              LBDDC     LDA  #SPACE         SPACE = DEFAULT SIGN FOR POSITIVE # 
3513 95a6 d6 54                        LDB  FP0SGN         GET SIGN OF FPA0 
3514 95a8 2a 02                        BPL  LBDE4          BRANCH IF POSITIVE 
3515 95aa 86 2d                        LDA  #'-'            ASCII MINUS SIGN 
3516 95ac a7 c0              LBDE4     STA  ,U+            STORE SIGN OF NUMBER 
3517 95ae df 64                        STU  COEFPT         SAVE BUFFER POINTER 
3518 95b0 97 54                        STA  FP0SGN         SAVE SIGN (IN ASCII) 
3519 95b2 86 30                        LDA  #'0'            ASCII ZERO IF EXPONENT = 0 
3520 95b4 d6 4f                        LDB  FP0EXP         GET FPA0 EXPONENT 
3521 95b6 10 27 00 c6                  LBEQ LBEB8          BRANCH IF FPA0 = 0 
3522 95ba 4f                           CLRA                BASE 10 EXPONENT=0 FOR FP NUMBER > 1 
3523 95bb c1 80                        CMPB #$80           CHECK EXPONENT 
3524 95bd 22 08                        BHI  LBDFF          BRANCH IF FP NUMBER > 1 
3525                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS                      
3526 95bf 8e 95 88                     LDX  #LBDC0         POINT X TO FP 1E+09 
3527 95c2 bd 92 8d                     JSR  LBACA          MULTIPLY FPA0 BY (X) 
3528 95c5 86 f7                        LDA  #-9            BASE 10 EXPONENT = -9 
3529 95c7 97 45              LBDFF     STA  V45            BASE 10 EXPONENT 
3530                         * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE                      
3531                         * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST                      
3532                         * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE                      
3533                         * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING                      
3534                         * SCIENTIFIC NOTATION                      
3535 95c9 8e 95 83           LBE01     LDX  #LBDBB         POINT X TO FP 999,999,999 
3536 95cc bd 94 63                     JSR  LBCA0          COMPARE FPA0 TO 999,999,999 
3537 95cf 2e 0f                        BGT  LBE18          BRANCH IF > 999,999,999 
3538 95d1 8e 95 7e           LBE09     LDX  #LBDB6         POINT X TO FP 99,999,999.9 
3539 95d4 bd 94 63                     JSR  LBCA0          COMPARE FPA0 TO 99,999,999.9 
3540 95d7 2e 0e                        BGT  LBE1F          BRANCH IF > 99,999,999.9 (IN RANGE) 
3541 95d9 bd 93 2d                     JSR  LBB6A          MULTIPLY FPA0 BY 10 
3542 95dc 0a 45                        DEC  V45            SUBTRACT ONE FROM DECIMAL OFFSET 
3543 95de 20 f1                        BRA  LBE09          PSEUDO - NORMALIZE SOME MORE 
3544 95e0 bd 93 45           LBE18     JSR  LBB82          DIVIDE FPA0 BY 10 
3545 95e3 0c 45                        INC  V45            ADD ONE TO BASE 10 EXPONENT 
3546 95e5 20 e2                        BRA  LBE01          PSEUDO - NORMALIZE SOME MORE 
3547 95e7 bd 91 77           LBE1F     JSR  LB9B4          ADD .5 TO FPA0 (ROUND OFF) 
3548 95ea bd 94 8b                     JSR  LBCC8          CONVERT FPA0 TO AN INTEGER 
3549 95ed c6 01                        LDB  #1             DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT) 
3550 95ef 96 45                        LDA  V45            * GET BASE 10 EXPONENT AND ADD TEN TO IT 
3551 95f1 8b 0a                        ADDA #9+1           * (NUMBER ‘NORMALIZED’ TO 9 PLACES & DECIMAL PT) 
3552 95f3 2b 09                        BMI  LBE36          BRANCH IF NUMBER < 1.0 
3553 95f5 81 0b                        CMPA #9+2           NINE PLACES MAY BE DISPLAYED WITHOUT 
3554                         *         USING SCIENTIFIC NOTATION  
3555 95f7 24 05                        BCC  LBE36          BRANCH IF SCIENTIFIC NOTATION REQUIRED 
3556 95f9 4a                           DECA                * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR 
3557 95fa 1f 89                        TFR  A,B            * AND SAVE IT IN ACCB (DECiMAL POINT FLAG) 
3558 95fc 86 02                        LDA  #2             FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION 
3559 95fe 4a                 LBE36     DECA                * SUBTRACT TWO (WITHOUT AFFECTING CARRY) 
3560 95ff 4a                           DECA                * FROM BASE 10 EXPONENT 
3561 9600 97 47                        STA  V47            SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY 
3562                         *         IN   SCIENTIFIC NOTATION  
3563 9602 d7 45                        STB  V45            DECIMAL POINT FLAG - NUMBER OF PLACES TO 
3564                         *         LEFT OF DECIMAL POINT  
3565 9604 2e 0d                        BGT  LBE4B          BRANCH IF >= 1 
3566 9606 de 64                        LDU  COEFPT         POINT U TO THE STRING BUFFER 
3567 9608 86 2e                        LDA  #'.'            * STORE A PERIOD 
3568 960a a7 c0                        STA  ,U+            * IN THE BUFFER 
3569 960c 5d                           TSTB CHECK DECIMAL POINT FLAG  
3570 960d 27 04                        BEQ  LBE4B          BRANCH IF NOTHING TO LEFT OF DECIMAL POINT 
3571 960f 86 30                        LDA  #'0'            * STORE A ZERO 
3572 9611 a7 c0                        STA  ,U+            * IN THE BUFFER 
3573                                                        
3574                         * CONVERT FPA0 INTO A STRING OF ASCII DIGITS                      
3575 9613 8e 96 8d           LBE4B     LDX  #LBEC5         POINT X TO FP POWER OF 10 MANTISSA 
3576 9616 c6 80                        LDB  #0+$80         INITIALIZE DIGIT COUNTER TO 0+$80 
3577                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA                      
3578                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS                      
3579                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW                      
3580                         * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.                      
3581 9618 96 53              LBE50     LDA  FPA0+3         * ADD MANTISSA LS 
3582 961a ab 03                        ADDA 3,X            * BYTE OF FPA0 
3583 961c 97 53                        STA  FPA0+3         * AND (X) 
3584 961e 96 52                        LDA  FPA0+2         = ADD MANTISSA 
3585 9620 a9 02                        ADCA 2,X            = NUMBER 3 BYTE OF 
3586 9622 97 52                        STA  FPA0+2         = FPA0 AND (X) 
3587 9624 96 51                        LDA  FPA0+1         * ADD MANTISSA 
3588 9626 a9 01                        ADCA 1,X            * NUMBER 2 BYTE OF 
3589 9628 97 51                        STA  FPA0+1         * FPA0 AND (X) 
3590 962a 96 50                        LDA  FPA0           = ADD MANTISSA 
3591 962c a9 84                        ADCA ,X             = MS BYTE OF 
3592 962e 97 50                        STA  FPA0           = FPA0 AND (X) 
3593 9630 5c                           INCB                ADD ONE TO DIGIT COUNTER 
3594 9631 56                           RORB ROTATE CARRY INTO BIT 7  
3595 9632 59                           ROLB                *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND 
3596 9633 28 e3                        BVC  LBE50          *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA 
3597 9635 24 03                        BCC  LBE72          BRANCH IF NEGATIVE MANTISSA 
3598 9637 c0 0b                        SUBB #10+1          * TAKE THE 9’S COMPLEMENT IF 
3599 9639 50                           NEGB                * ADDING MANTISSA 
3600 963a cb 2f              LBE72     ADDB #'0'-1          ADD ASCII OFFSET TO DIGIT 
3601 963c 30 04                        LEAX 4,X            MOVE TO NEXT POWER OF 10 MANTISSA 
3602 963e 1f 98                        TFR  B,A            SAVE DIGIT IN ACCA 
3603 9640 84 7f                        ANDA #$7F           MASK OFF BIT 7 (ADD/SUBTRACT FLAG) 
3604 9642 a7 c0                        STA  ,U+            STORE DIGIT IN STRING BUFFER 
3605 9644 0a 45                        DEC  V45            DECREMENT DECIMAL POINT FLAG 
3606 9646 26 04                        BNE  LBE84          BRANCH IF NOT TIME FOR DECIMAL POINT 
3607 9648 86 2e                        LDA  #'.'            * STORE DECIMAL POINT IN 
3608 964a a7 c0                        STA  ,U+            * STRING BUFFER 
3609 964c 53                 LBE84     COMB                TOGGLE BIT 7 (ADD/SUBTRACT FLAG) 
3610 964d c4 80                        ANDB #$80           MASK OFF ALL BUT ADD/SUBTRACT FLAG 
3611 964f 8c 96 b1                     CMPX #LBEC5+36      COMPARE X TO END OF MANTISSA TABLE 
3612 9652 26 c4                        BNE  LBE50          BRANCH IF NOT AT END OF TABLE 
3613                         * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY                      
3614 9654 a6 c2              LBE8C     LDA  ,-U            GET THE LAST CHARACTER; MOVE POINTER BACK 
3615 9656 81 30                        CMPA #'0'            WAS IT A ZERO? 
3616 9658 27 fa                        BEQ  LBE8C          IGNORE TRAILING ZEROS IF SO 
3617 965a 81 2e                        CMPA #'.            CHECK FOR DECIMAL POINT 
3618 965c 26 02                        BNE  LBE98          BRANCH IF NOT DECIMAL POINT 
3619 965e 33 5f                        LEAU -1,U           STEP OVER THE DECIMAL POINT 
3620 9660 86 2b              LBE98     LDA  #'+'            ASCII PLUS SIGN 
3621 9662 d6 47                        LDB  V47            GET SCIENTIFIC NOTATION EXPONENT 
3622 9664 27 1c                        BEQ  LBEBA          BRANCH IF NOT SCIENTIFIC NOTATION 
3623 9666 2a 03                        BPL  LBEA3          BRANCH IF POSITIVE EXPONENT 
3624 9668 86 2d                        LDA  #'-'            ASCII MINUS SIGN 
3625 966a 50                           NEGB                NEGATE EXPONENT IF NEGATIVE 
3626 966b a7 42              LBEA3     STA  2,U            STORE EXPONENT SIGN IN STRING 
3627 966d 86 45                        LDA  #'E'            * GET ASCII ‘E’ (SCIENTIFIC NOTATION 
3628 966f a7 41                        STA  1,U            * FLAG) AND SAVE IT IN THE STRING 
3629 9671 86 2f                        LDA  #'0'-1          INITIALIZE ACCA TO ASCII ZERO 
3630                                                        
3631                                                        
3632 9673 4c                 LBEAB     INCA                ADD ONE TO 10’S DIGIT OF EXPONENT 
3633 9674 c0 0a                        SUBB #10            SUBTRACT 10 FROM ACCB 
3634 9676 24 fb                        BCC  LBEAB          ADD 1 TO 10’S DIGIT IF NO CARRY 
3635 9678 cb 3a                        ADDB #'9'+1          CONVERT UNITS DIGIT TO ASCII 
3636 967a ed 43                        STD  3,U            SAVE EXPONENT IN STRING 
3637 967c 6f 45                        CLR  5,U            CLEAR LAST BYTE (TERMINATOR) 
3638 967e 20 04                        BRA  LBEBC          GO RESET POINTER 
3639 9680 a7 c4              LBEB8     STA  ,U             STORE LAST CHARACTER 
3640 9682 6f 41              LBEBA     CLR  1,U            CLEAR LAST BYTE (TERMINATOR - REQUIRED BY 
3641                         *         PRINT SUBROUTINES)    
3642 9684 8e 02 2f           LBEBC     LDX  #STRBUF+3      RESET POINTER TO START OF BUFFER 
3643 9687 39                           RTS                  
3644                         *                              
3645 9688 80 00 00 00 00     LBEC0     FCB  $80,$00,$00,$00,$00 FLOATING POINT .5 
3646                         *                              
3647                         *** TABLE OF UNNORMALIZED POWERS OF 10                      
3648 968d fa 0a 1f 00        LBEC5     FCB  $FA,$0A,$1F,$00 -100000000 
3649 9691 00 98 96 80        LBEC9     FCB  $00,$98,$96,$80 10000000 
3650 9695 ff f0 bd c0        LBECD     FCB  $FF,$F0,$BD,$C0 -1000000 
3651 9699 00 01 86 a0        LBED1     FCB  $00,$01,$86,$A0 100000 
3652 969d ff ff d8 f0        LBED5     FCB  $FF,$FF,$D8,$F0 -10000 
3653 96a1 00 00 03 e8        LBED9     FCB  $00,$00,$03,$E8 1000 
3654 96a5 ff ff ff 9c        LBEDD     FCB  $FF,$FF,$FF,$9C -100 
3655 96a9 00 00 00 0a        LBEE1     FCB  $00,$00,$00,$0A 10 
3656 96ad ff ff ff ff        LBEE5     FCB  $FF,$FF,$FF,$FF -1 
3657                         *                              
3658                         *                              
3659 96b1 96 4f              LBEE9     LDA  FP0EXP         GET EXPONENT OF FPA0 
3660 96b3 27 02                        BEQ  LBEEF          BRANCH IF FPA0 = 0 
3661 96b5 03 54                        COM  FP0SGN         TOGGLE MANTISSA SIGN OF FPA0 
3662 96b7 39                 LBEEF     RTS                  
3663                         * EXPAND A POLYNOMIAL OF THE FORM                      
3664                         * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0                      
3665                         * AND THE X REGISTER POINTS TO A TABLE OF                      
3666                         * COEFFICIENTS A,B,C,D....                      
3667 96b8 9f 64              LBEF0     STX  COEFPT         SAVE COEFFICIENT TABLE POINTER 
3668 96ba bd 93 f2                     JSR  LBC2F          MOVE FPA0 TO FPA3 
3669 96bd 8d 05                        BSR  LBEFC          MULTIPLY FPA3 BY FPA0 
3670 96bf 8d 08                        BSR  LBF01          EXPAND POLYNOMIAL 
3671 96c1 8e 00 40                     LDX  #V40           POINT X TO FPA3 
3672 96c4 7e 92 8d           LBEFC     JMP  LBACA          MULTIPLY (X) BY FPA0 
3673                                                        
3674                         * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL                      
3675                         * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE                      
3676                         * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE                      
3677                         * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER                      
3678                         * OF PACKED FLOATING POINT NUMBERS. THE                      
3679                         * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =                      
3680                         * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0…YN)                      
3681 96c7 9f 64              LBEFF     STX  COEFPT         SAVE COEFFICIENT TABLE POINTER 
3682 96c9 bd 93 ed           LBF01     JSR  LBC2A          MOVE FPA0 TO FPA4 
3683 96cc 9e 64                        LDX  COEFPT         GET THE COEFFICIENT POINTER 
3684 96ce e6 80                        LDB  ,X+            GET THE TOP OF COEFFICIENT TABLE TO 
3685 96d0 d7 55                        STB  COEFCT         * USE AND STORE IT IN TEMPORARY COUNTER 
3686 96d2 9f 64                        STX  COEFPT         SAVE NEW COEFFICIENT POINTER 
3687 96d4 8d ee              LBF0C     BSR  LBEFC          MULTIPLY (X) BY FPA0 
3688 96d6 9e 64                        LDX  COEFPT         *GET COEFFICIENT POINTER 
3689 96d8 30 05                        LEAX 5,X            *MOVE TO NEXT FP NUMBER 
3690 96da 9f 64                        STX  COEFPT         *SAVE NEW COEFFICIENT POINTER 
3691 96dc bd 91 85                     JSR  LB9C2          ADD (X) AND FPA0 
3692 96df 8e 00 45                     LDX  #V45           POINT (X) TO FPA4 
3693 96e2 0a 55                        DEC  COEFCT         DECREMENT TEMP COUNTER 
3694 96e4 26 ee                        BNE  LBF0C          BRANCH IF MORE COEFFICIENTS LEFT 
3695 96e6 39                           RTS                  
3696                                                        
3697                         * RND                          
3698 96e7 bd 94 30           RND       JSR  LBC6D          TEST FPA0 
3699 96ea 2b 1f                        BMI  LBF45          BRANCH IF FPA0 = NEGATIVE 
3700 96ec 27 15                        BEQ  LBF3B          BRANCH IF FPA0 = 0 
3701 96ee 8d 10                        BSR  LBF38          CONVERT FPA0 TO AN INTEGER 
3702 96f0 bd 93 f2                     JSR  LBC2F          PACK FPA0 TO FPA3 
3703 96f3 8d 0e                        BSR  LBF3B          GET A RANDOM NUMBER: FPA0 < 1.0 
3704 96f5 8e 00 40                     LDX  #V40           POINT (X) TO FPA3 
3705 96f8 8d ca                        BSR  LBEFC          MULTIPLY (X) BY FPA0 
3706 96fa 8e 92 88                     LDX  #LBAC5         POINT (X) TO FP VALUE OF 1.0 
3707 96fd bd 91 85                     JSR  LB9C2          ADD 1.0 TO FPA0 
3708 9700 7e 94 b1           LBF38     JMP  INT            CONVERT FPA0 TO AN INTEGER 
3709                         * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0                      
3710 9703 9e a7              LBF3B     LDX  RVSEED+1       * MOVE VARIABLE 
3711 9705 9f 50                        STX  FPA0           * RANDOM NUMBER 
3712 9707 9e a9                        LDX  RVSEED+3       * SEED TO 
3713 9709 9f 52                        STX  FPA0+2         * FPA0 
3714 970b be 97 38           LBF45     LDX  RSEED          = MOVE FIXED 
3715 970e 9f 5d                        STX  FPA1           = RANDOM NUMBER 
3716 9710 be 97 3a                     LDX  RSEED+2        = SEED TO 
3717 9713 9f 5f                        STX  FPA1+2         = MANTISSA OF FPA0 
3718 9715 bd 92 93                     JSR  LBAD0          MULTIPLY FPA0 X FPA1 
3719 9718 dc 80                        LDD  VAD            GET THE TWO LOWEST ORDER PRODUCT BYTES 
3720 971a c3 65 8b                     ADDD #$658B         ADD A CONSTANT 
3721 971d dd a9                        STD  RVSEED+3       SAVE NEW LOW ORDER VARIABLE RANDOM # SEED 
3722 971f dd 52                        STD  FPA0+2         SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA 
3723 9721 dc 7e                        LDD  VAB            GET 2 MORE LOW ORDER PRODUCT BYTES 
3724 9723 c9 b0                        ADCB #$B0           ADD A CONSTANT 
3725 9725 89 05                        ADCA #5             ADD A CONSTANT 
3726 9727 dd a7                        STD  RVSEED+1       SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED 
3727 9729 dd 50                        STD  FPA0           SAVE NEW HIGH ORDER FPA0 MANTISSA 
3728 972b 0f 54                        CLR  FP0SGN         FORCE FPA0 MANTISSA = POSITIVE 
3729 972d 86 80                        LDA  #$80           * SET FPA0 BIASED EXPONENT 
3730 972f 97 4f                        STA  FP0EXP         * TO 0 1 < FPA0 < 0 
3731 9731 96 15                        LDA  FPA2+2         GET A BYTE FROM FPA2 (MORE RANDOMNESS) 
3732 9733 97 63                        STA  FPSBYT         SAVE AS SUB BYTE 
3733 9735 7e 91 df                     JMP  LBA1C          NORMALIZE FPA0 
3734                         *                              
3735 9738 40 e6              RSEED     FDB  $40E6          *CONSTANT RANDOM NUMBER GENERATOR SEED 
3736 973a 4d ab                        FDB  $4DAB          * 
3737                                                        
3738                         * SIN                          
3739                         * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY                      
3740                         * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS                      
3741                         * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE                      
3742                         * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.                      
3743                                                        
3744                         * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:                      
3745                         * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)                      
3746 973c bd 94 22           SIN       JSR  LBC5F          COPY FPA0 TO FPA1 
3747 973f 8e 97 81                     LDX  #LBFBD         POINT (X) TO 2*PI 
3748 9742 d6 61                        LDB  FP1SGN         *GET MANTISSA SIGN OF FPA1 
3749 9744 bd 93 4c                     JSR  LBB89          *AND DIVIDE FPA0 BY 2*PI 
3750 9747 bd 94 22                     JSR  LBC5F          COPY FPA0 TO FPA1 
3751 974a 8d b4                        BSR  LBF38          CONVERT FPA0 TO AN INTEGER 
3752 974c 0f 62                        CLR  RESSGN         SET RESULT SIGN = POSITIVE 
3753 974e 96 5c                        LDA  FP1EXP         *GET EXPONENT OF FPA1 
3754 9750 d6 4f                        LDB  FP0EXP         *GET EXPONENT OF FPA0 
3755 9752 bd 91 7f                     JSR  LB9BC          *SUBTRACT FPA0 FROM FPA1 
3756                         * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI                      
3757 9755 8e 97 86                     LDX  #LBFC2         POINT X TO FP (.25) 
3758 9758 bd 91 7c                     JSR  LB9B9          SUBTRACT FPA0 FROM .25 (PI/2) 
3759 975b 96 54                        LDA  FP0SGN         GET MANTISSA SIGN OF FPA0 
3760 975d 34 02                        PSHS A              SAVE IT ON STACK 
3761 975f 2a 09                        BPL  LBFA6          BRANCH IF MANTISSA POSITIVE 
3762 9761 bd 91 77                     JSR  LB9B4          ADD .5 (PI) TO FPA0 
3763 9764 96 54                        LDA  FP0SGN         GET SIGN OF FPA0 
3764 9766 2b 05                        BMI  LBFA9          BRANCH IF NEGATIVE 
3765 9768 03 0a                        COM  RELFLG         COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG) 
3766 976a bd 96 b1           LBFA6     JSR  LBEE9          TOGGLE MANTISSA SIGN OF FPA0 
3767 976d 8e 97 86           LBFA9     LDX  #LBFC2         POINT X TO FP (.25) 
3768 9770 bd 91 85                     JSR  LB9C2          ADD .25 (PI/2) TO FPA0 
3769 9773 35 02                        PULS A              GET OLD MANTISSA SIGN 
3770 9775 4d                           TSTA                * BRANCH IF OLD 
3771 9776 2a 03                        BPL  LBFB7          * SIGN WAS POSITIVE 
3772 9778 bd 96 b1                     JSR  LBEE9          TOGGLE MANTISSA SIGN 
3773 977b 8e 97 8b           LBFB7     LDX  #LBFC7         POINT X TO TABLE OF COEFFICIENTS 
3774 977e 7e 96 b8                     JMP  LBEF0          GO CALCULATE POLYNOMIAL VALUE 
3775                                                        
3776 9781 83 49 0f da a2     LBFBD     FCB  $83,$49,$0F,$DA,$A2 6.28318531 (2*PI) 
3777 9786 7f 00 00 00 00     LBFC2     FCB  $7F,$00,$00,$00,$00 .25 
3778                                                        
3779                                                        
3780 978b 05                 LBFC7     FCB  6-1            SIX COEFFICIENTS 
3781 978c 84 e6 1a 2d 1b     LBFC8     FCB  $84,$E6,$1A,$2D,$1B * -((2*PI)**11)/11! 
3782 9791 86 28 07 fb f8     LBFCD     FCB  $86,$28,$07,$FB,$F8 * ((2*PI)**9)/9! 
3783 9796 87 99 68 89 01     LBFD2     FCB  $87,$99,$68,$89,$01 * -((2*PI)**7)/7! 
3784 979b 87 23 35 df e1     LBFD7     FCB  $87,$23,$35,$DF,$E1 * ((2*PI)**5)/5! 
3785 97a0 86 a5 5d e7 28     LBFDC     FCB  $86,$A5,$5D,$E7,$28 * -((2*PI)**3)/3! 
3786 97a5 83 49 0f da a2     LBFE1     FCB  $83,$49,$0F,$DA,$A2 * 
3787                                                        
3788 97aa a1 54 46 8f 13               FCB  $A1,$54,$46,$8F,$13 UNUSED GARBAGE BYTES 
3789 97af 8f 52 43 89 cd               FCB  $8F,$52,$43,$89,$CD UNUSED GARBAGE BYTES 
3790                         * EXTENDED BASIC                      
3791                                                        
3792 97b4 32 62              XVEC20    LEAS $02,S          PURGE RETURN ADDRESS FROM STACK 
3793 97b6 1c af              L82BB     ANDCC #$AF           ENABLE INTERRUPTS 
3794 97b8 bd 85 e6                     JSR  LADEB          CHECK FOR KEYBOARD BREAK 
3795 97bb 9e 7c                        LDX  CHARAD         * GET CURRENT BASIC LINE 
3796 97bd 9f 2f                        STX  TINPTR         * POINTER AND SAVE IT 
3797 97bf a6 80                        LDA  ,X+            GET CURRENT INPUT CHARACTER AND ADVANCE POINTER 
3798 97c1 27 07                        BEQ  L82CF          BRANCH IF END OF LINE 
3799 97c3 81 3a                        CMPA #':'           CHECK FOR COLON 
3800 97c5 27 25                        BEQ  L82F1          CONTINUE INTERPRETING IF COLON 
3801 97c7 7e 8a 5f                     JMP  LB277          SNYTAX ERROR - COLON ONLY LEGAL LINE SEPARATOR 
3802 97ca a6 81              L82CF     LDA  ,X++           * GET 1ST BYTE OF ADDRESS OF NEXT 
3803 97cc 97 00                        STA  ENDFLG         * BASIC LINE AND SAVE IT 
3804 97ce 26 03                        BNE  L82D8          BRANCH IF NOT END OF PROGRAM 
3805 97d0 7e 86 0e                     JMP  LAE15          RETURN TO DIRECT MODE - PRINT OK 
3806 97d3 ec 80              L82D8     LDD  ,X+            GET LINE NUMBER OF NEXT LINE 
3807 97d5 dd 68                        STD  CURLIN         SAVE LINE NUMBER 
3808 97d7 9f 7c                        STX  CHARAD         SAVE ADDRESS NEXT BYTE TO INTERPRET 
3809 97d9 96 82                        LDA  TRCFLG         TEST THE TRACE FLAG 
3810 97db 27 0f                        BEQ  L82F1          BRANCH IF TRACE OFF 
3811 97dd 86 5b                        LDA  #$5B           <LEFT HAND MARKER FOR TRON LINE NUMBER 
3812 97df bd 81 13                     JSR  PUTCHR         OUTPUT A CHARACTER 
3813 97e2 96 68                        LDA  CURLIN         GET MS BYTE OF LINE NUMBER 
3814 97e4 bd 95 94                     JSR  LBDCC          CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN 
3815 97e7 86 5d                        LDA  #$5D           > RIGHT HAND MARKER FOR TRON LINE NUMBER 
3816 97e9 bd 81 13                     JSR  PUTCHR         OUTPUT A CHARACTER 
3817 97ec bd a4 b3           L82F1     JSR  GETNCH         GET A CHARACTER FROM BASIC 
3818 97ef bd 85 b1                     JSR  LADC6          LINK BACK TO BASIC’S INTERPRETATION LOOP 
3819 97f2 20 c2                        BRA  L82BB          GO TO MAIN INTERPRETATION LOOP 
3820                                                        
3821                                                        
3822                                                        
3823 97f4 8e 98 27           COS       LDX  #L83AB         POINT X TO FP CONSTANT (P1/2) 
3824 97f7 bd 91 85                     JSR  LB9C2          ADD FPA0 TO (X) 
3825 97fa 7e 97 3c           L837E     JMP  SIN            JUMP TO SIN ROUTINE 
3826                                                        
3827                         * TAN                          
3828                         * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)                      
3829 97fd bd 93 f2           TAN       JSR  LBC2F          PACK FPA0 AND MOVE IT TO FPA3 
3830 9800 0f 0a                        CLR  RELFLG         RESET QUADRANT FLAG 
3831 9802 8d f6                        BSR  L837E          CALCULATE SIN OF ARGUMENT 
3832 9804 8e 00 4a                     LDX  #V4A           POINT X TO FPA5 
3833 9807 bd 93 f8                     JSR  LBC35          PACK FPA0 AND MOVE IT TO FPA5 
3834 980a 8e 00 40                     LDX  #V40           POINT X TO FPA3 
3835 980d bd 93 d7                     JSR  LBC14          MOVE FPA3 TO FPA0 
3836 9810 0f 54                        CLR  FP0SGN         FORCE FPA0 MANTISSA TO BE POSITIVE 
3837 9812 96 0a                        LDA  RELFLG         GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3 
3838 9814 8d 0c                        BSR  L83A6          CALCULATE VALUE OF COS(FPA0) 
3839 9816 0d 4f                        TST  FP0EXP         CHECK EXPONENT OF FPA0 
3840 9818 10 27 fa 39                  LBEQ LBA92          ‘OV’ ERROR IF COS(X)=0 
3841 981c 8e 00 4a                     LDX  #V4A           POINT X TO FPA5 
3842 981f 7e 93 52           L83A3     JMP  LBB8F          DIVIDE (X) BY FPA0 - SIN(X)/COS(X) 
3843 9822 34 02              L83A6     PSHS A              SAVE SIGN FLAG ON STACK 
3844 9824 7e 97 6a                     JMP  LBFA6          EXPAND POLYNOMIAL 
3845                                                        
3846 9827 81 49 0f da a2     L83AB     FCB  $81,$49,$0F,$DA,$A2 1.57079633 (PI/2) 
3847                                                        
3848                         * ATN                          
3849                         * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE                      
3850                         * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED  
3851                         * TO EVALUATE THE EXPRESSION DEPENDING UPON                      
3852                         * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0                      
3853                                                        
3854                         * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7………..                      
3855                         * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-………)                      
3856                                                        
3857 982c 96 54              ATN       LDA  FP0SGN         * GET THE SIGN OF THE MANTISSA AND 
3858 982e 34 02                        PSHS A              * SAVE IT ON THE STACK 
3859 9830 2a 02                        BPL  L83B8          BRANCH IF POSITIVE MANTISSA 
3860 9832 8d 24                        BSR  L83DC          CHANGE SIGN OF FPA0 
3861 9834 96 4f              L83B8     LDA  FP0EXP         * GET EXPONENT OF FPA0 AND 
3862 9836 34 02                        PSHS A              * SAVE IT ON THE STACK 
3863 9838 81 81                        CMPA #$81           IS FPAO < 1.0? 
3864 983a 25 05                        BLO  L83C5          YES 
3865 983c 8e 92 88                     LDX  #LBAC5         POINT X TO FP CONSTANT 1.0 
3866 983f 8d de                        BSR  L83A3          GET RECIPROCAL OF FPA0 
3867 9841 8e 98 5c           L83C5     LDX  #L83E0         POINT (X) TO TAYLOR SERIES COEFFICIENTS 
3868 9844 bd 96 b8                     JSR  LBEF0          EXPAND POLYNOMIAL 
3869 9847 35 02                        PULS A              GET EXPONENT OF ARGUMENT 
3870 9849 81 81                        CMPA #$81           WAS ARGUMENT < 1.0? 
3871 984b 25 06                        BLO  L83D7          YES 
3872 984d 8e 98 27                     LDX  #L83AB         POINT (X) TO FP NUMBER (PI/2) 
3873 9850 bd 91 7c                     JSR  LB9B9          SUBTRACT FPA0 FROM (PI/2) 
3874 9853 35 02              L83D7     PULS A              * GET SIGN OF INITIAL ARGUMENT MANTISSA 
3875 9855 4d                           TSTA                * AND SET FLAGS ACCORDING TO IT 
3876 9856 2a 03                        BPL  L83DF          RETURN IF ARGUMENT WAS POSITIVE 
3877 9858 7e 96 b1           L83DC     JMP  LBEE9          CHANGE MANTISSA SIGN OF FPA0 
3878 985b 39                 L83DF     RTS                  
3879                         *                              
3880                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT                      
3881 985c 0b                 L83E0     FCB  $0B            TWELVE COEFFICIENTS 
3882 985d 76 b3 83 bd d3     L83E1     FCB  $76,$B3,$83,$BD,$D3 -6.84793912E-04 1/23 
3883 9862 79 1e f4 a6 f5     L83E6     FCB  $79,$1E,$F4,$A6,$F5 +4.85094216E-03 1/21 
3884 9867 7b 83 fc b0 10     L83EB     FCB  $7B,$83,$FC,$B0,$10 -0.0161117018 
3885 986c 7c 0c 1f 67 ca     L83F0     FCB  $7C,$0C,$1F,$67,$CA 0.0342096381 
3886 9871 7c de 53 cb c1     L83F5     FCB  $7C,$DE,$53,$CB,$C1 -0.0542791328 
3887 9876 7d 14 64 70 4c     L83FA     FCB  $7D,$14,$64,$70,$4C 0.0724571965 
3888 987b 7d b7 ea 51 7a     L83FF     FCB  $7D,$B7,$EA,$51,$7A -0.0898023954 
3889 9880 7d 63 30 88 7e     L8404     FCB  $7D,$63,$30,$88,$7E 0.110932413 
3890 9885 7e 92 44 99 3a     L8409     FCB  $7E,$92,$44,$99,$3A -0.142839808 
3891 988a 7e 4c cc 91 c7     L840E     FCB  $7E,$4C,$CC,$91,$C7 0.199999121 
3892 988f 7f aa aa aa 13     L8413     FCB  $7F,$AA,$AA,$AA,$13 -0.333333316 
3893 9894 81 00 00 00 00     L8418     FCB  $81,$00,$00,$00,$00 1 
3894                         *                              
3895                         *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)                      
3896                         *                              
3897 9899 03                 L841D     FCB  3              FOUR COEFFICIENTS 
3898 989a 7f 5e 56 cb 79     L841E     FCB  $7F,$5E,$56,$CB,$79 0.434255942 
3899 989f 80 13 9b 0b 64     L8423     FCB  $80,$13,$9B,$0B,$64 0.576584541 
3900 98a4 80 76 38 93 16     L8428     FCB  $80,$76,$38,$93,$16 0.961800759 
3901 98a9 82 38 aa 3b 20     L842D     FCB  $82,$38,$AA,$3B,$20 2.88539007 
3902                                                        
3903 98ae 80 35 04 f3 34     L8432     FCB  $80,$35,$04,$F3,$34 1/SQR(2) 
3904                                                        
3905 98b3 81 35 04 f3 34     L8437     FCB  $81,$35,$04,$F3,$34 SQR(2) 
3906                                                        
3907 98b8 80 80 00 00 00     L843C     FCB  $80,$80,$00,$00,$00 -0.5 
3908                                                        
3909 98bd 80 31 72 17 f8     L8441     FCB  $80,$31,$72,$17,$F8 LN(2) 
3910                                                        
3911                                                        
3912                                                        
3913                                                        
3914                                                        
3915                                                        
3916                                                        
3917                                                        
3918                                                        
3919                                                        
3920 98c2 bd 94 30           LOG       JSR  LBC6D          CHECK STATUS OF FPA0 
3921 98c5 10 2f f3 6e                  LBLE LB44A          ‘FC’ ERROR IF NEGATIVE OR ZERO 
3922 98c9 8e 98 ae                     LDX  #L8432         POINT (X) TO FP NUMBER (1/SQR(2)) 
3923 98cc 96 4f                        LDA  FP0EXP         *GET EXPONENT OF ARGUMENT 
3924 98ce 80 80                        SUBA #$80           *SUBTRACT OFF THE BIAS AND 
3925 98d0 34 02                        PSHS A              *SAVE IT ON THE STACK 
3926 98d2 86 80                        LDA  #$80            
3927 98d4 97 4f                        STA  FP0EXP          
3928 98d6 bd 91 85                     JSR  LB9C2          ADD FPA0 TO (X) 
3929 98d9 8e 98 b3                     LDX  #L8437         POINT X TO SQR(2) 
3930 98dc bd 93 52                     JSR  LBB8F          DIVIDE SQR(2) BY FPA0 
3931 98df 8e 92 88                     LDX  #LBAC5         POINT X TO FP VALUE OF 1.00 
3932 98e2 bd 91 7c                     JSR  LB9B9          SUBTRACT FPA0 FROM (X) 
3933                         *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT  
3934 98e5 8e 98 99                     LDX  #L841D         POINT X TO TABLE OF COEFFICIENTS 
3935 98e8 bd 96 b8                     JSR  LBEF0          EXPAND POLYNOMIAL 
3936 98eb 8e 98 b8                     LDX  #L843C         POINT X TO FP VALUE OF (-.5) 
3937 98ee bd 91 85                     JSR  LB9C2          ADD FPA0 TO X 
3938 98f1 35 04                        PULS B              GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS) 
3939 98f3 bd 95 61                     JSR  LBD99          ADD ACCB TO FPA0 
3940 98f6 8e 98 bd                     LDX  #L8441         POINT X TO LN(2) 
3941 98f9 7e 92 8d                     JMP  LBACA          MULTIPLY FPA0 * LN(2) 
3942                                                        
3943                         * SQR                          
3944 98fc bd 94 22           SQR       JSR  LBC5F          MOVE FPA0 TO FPA1 
3945 98ff 8e 96 88                     LDX  #LBEC0         POINT (X) TO FP NUMBER (.5) 
3946 9902 bd 93 d7                     JSR  LBC14          COPY A PACKED NUMBER FROM (X) TO FPA0 
3947                                                        
3948                         * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS                      
3949                         * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION                      
3950                         * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818                      
3951 9905 27 67              L8489     BEQ  EXP            DO A NATURAL EXPONENTIATION IF EXPONENT = 0 
3952 9907 4d                           TSTA                *CHECK VALUE BEING EXPONENTIATED 
3953 9908 26 03                        BNE  L8491          *AND BRANCH IF IT IS <> 0 
3954 990a 7e 91 fd                     JMP  LBA3A          FPA0=0 IF RAISING ZERO TO A POWER 
3955 990d 8e 00 4a           L8491     LDX  #V4A           * PACK FPA0 AND SAVE 
3956 9910 bd 93 f8                     JSR  LBC35          * IT IN FPA5 (ARGUMENT’S EXPONENT) 
3957 9913 5f                           CLRB                ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE 
3958 9914 96 61                        LDA  FP1SGN         *CHECK THE SIGN OF ARGUMENT 
3959 9916 2a 10                        BPL  L84AC          *BRANCH IF POSITIVE 
3960 9918 bd 94 b1                     JSR  INT            CONVERT EXPONENT INTO AN INTEGER 
3961 991b 8e 00 4a                     LDX  #V4A           POINT X TO FPA5 (ORIGINAL EXPONENT) 
3962 991e 96 61                        LDA  FP1SGN         GET MANTISSA SIGN OF FPA1 (ARGUMENT) 
3963 9920 bd 94 63                     JSR  LBCA0          *COMPARE FPA0 TO (X) AND 
3964 9923 26 03                        BNE  L84AC          *BRANCH IF NOT EQUAL 
3965 9925 43                           COMA                TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE 
3966 9926 d6 01                        LDB  CHARAC         GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG) 
3967 9928 bd 94 0f           L84AC     JSR  LBC4C          COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN 
3968 992b 34 04                        PSHS B              PUT RESULT SIGN FLAG ON THE STACK 
3969 992d bd 98 c2                     JSR  LOG             
3970 9930 8e 00 4a                     LDX  #V4A           POINT (X) TO FPA5 
3971 9933 bd 92 8d                     JSR  LBACA          MULTIPLY FPA0 BY FPA5 
3972 9936 8d 36                        BSR  EXP            CALCULATE E**(FPA0) 
3973 9938 35 02                        PULS A              * GET RESULT SIGN FLAG FROM THE STACK 
3974 993a 46                           RORA * AND BRANCH IF NEGATIVE  
3975 993b 10 25 fd 72                  LBCS LBEE9          CHANGE SIGN OF FPA0 MANTISSA 
3976 993f 39                           RTS                  
3977                                                        
3978                         * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION                      
3979 9940 81 38 aa 3b 29     L84C4     FCB  $81,$38,$AA,$3B,$29 1.44269504 ( CF ) 
3980                         *                              
3981                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X                      
3982                         *                              
3983 9945 07                 L84C9     FCB  7              EIGHT COEFFICIENTS 
3984 9946 71 34 58 3e 56     L84CA     FCB  $71,$34,$58,$3E,$56 2.14987637E-05: 1/(7!*(CF**7)) 
3985 994b 74 16 7e b3 1b     L84CF     FCB  $74,$16,$7E,$B3,$1B 1.4352314E-04 : 1/(6!*(CF**6)) 
3986 9950 77 2f ee e3 85     L84D4     FCB  $77,$2F,$EE,$E3,$85 1.34226348E-03: 1/(5!*(CF**5)) 
3987 9955 7a 1d 84 1c 2a     L84D9     FCB  $7A,$1D,$84,$1C,$2A 9.61401701E-03: 1/(4!*(CF**4)) 
3988 995a 7c 63 59 58 0a     L84DE     FCB  $7C,$63,$59,$58,$0A 0.0555051269 
3989 995f 7e 75 fd e7 c6     L84E3     FCB  $7E,$75,$FD,$E7,$C6 0.240226385 
3990 9964 80 31 72 18 10     L84E8     FCB  $80,$31,$72,$18,$10 0.693147186 
3991 9969 81 00 00 00 00     L84ED     FCB  $81,$00,$00,$00,$00 1 
3992                         *                              
3993                         * EXP ( E**X)                      
3994                         * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE                      
3995                         * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN                      
3996                         * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A                      
3997                         * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE                      
3998                         * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT                      
3999                         * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.                      
4000                                                        
4001 996e 8e 99 40           EXP       LDX  #L84C4         POINT X TO THE CORRECTION FACTOR 
4002 9971 bd 92 8d                     JSR  LBACA          MULTIPLY FPA0 BY (X) 
4003 9974 bd 93 f2                     JSR  LBC2F          PACK FPA0 AND STORE IT IN FPA3 
4004 9977 96 4f                        LDA  FP0EXP         *GET EXPONENT OF FPA0 AND 
4005 9979 81 88                        CMPA #$88           *COMPARE TO THE MAXIMUM VALUE 
4006 997b 25 03                        BLO  L8504          BRANCH IF FPA0 < 128 
4007 997d 7e 93 1f           L8501     JMP  LBB5C          SET FPA0 = 0 OR ‘OV’ ERROR 
4008 9980 bd 94 b1           L8504     JSR  INT            CONVERT FPA0 TO INTEGER 
4009 9983 96 01                        LDA  CHARAC         GET LS BYTE OF INTEGER 
4010 9985 8b 81                        ADDA #$81           * WAS THE ARGUMENT =127, IF SO 
4011 9987 27 f4                        BEQ  L8501          * THEN ‘OV’ ERROR; THIS WILL ALSO ADD THE $80 BIAS 
4012                         *              * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW  
4013 9989 4a                           DECA                DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE 
4014 998a 34 02                        PSHS A              SAVE EXPONENT OF INTEGER PORTION ON STACK 
4015 998c 8e 00 40                     LDX  #V40           POINT (X) TO FPA3 
4016 998f bd 91 7c                     JSR  LB9B9          SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT 
4017 9992 8e 99 45                     LDX  #L84C9         POINT X TO COEFFICIENTS 
4018 9995 bd 96 c7                     JSR  LBEFF          EVALUATE POLYNOMIAL FOR FRACTIONAL PART 
4019 9998 0f 62                        CLR  RESSGN         FORCE THE MANTISSA TO BE POSITIVE 
4020 999a 35 02                        PULS A              GET INTEGER EXPONENT FROM STACK 
4021 999c bd 93 0b                     JSR  LBB48          * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE 
4022                         *              * INTEGER AND FRACTIONAL PARTS  
4023 999f 39                           RTS                  
4024                                                        
4025                         * FIX                          
4026 99a0 bd 94 30           FIX       JSR  LBC6D          CHECK STATUS OF FPA0 
4027 99a3 2b 03                        BMI  L852C          BRANCH IF FPA0 = NEGATIVE 
4028 99a5 7e 94 b1           L8529     JMP  INT            CONVERT FPA0 TO INTEGER 
4029 99a8 03 54              L852C     COM  FP0SGN         TOGGLE SIGN OF FPA0 MANTISSA 
4030 99aa 8d f9                        BSR  L8529          CONVERT FPA0 TO INTEGER 
4031 99ac 7e 96 b1                     JMP  LBEE9          TOGGLE SIGN OF FPA0 
4032                                                        
4033                         * EDIT                         
4034 99af bd 9d ea           EDIT      JSR  L89AE          GET LINE NUMBER FROM BASIC 
4035 99b2 32 62                        LEAS $02,S 		PURGE RETURN ADDRESS OFF OF THE STACK  
4036 99b4 86 01              L8538     LDA  #$01           ‘LIST’ FLAG 
4037 99b6 97 8e                        STA  VD8            SET FLAG TO LIST LINE 
4038 99b8 bd 84 e7                     JSR  LAD01          GO FIND THE LINE NUMBER IN PROGRAM 
4039 99bb 10 25 ed 0a                  LBCS LAED2 			ERROR #7 ‘UNDEFINED LINE #'  
4040 99bf bd 8f aa                     JSR  LB7C2          GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1 
4041 99c2 1f 20                        TFR  Y,D            PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD 
4042 99c4 83 01 33                     SUBD #LINBUF+2 		SUBTRACT OUT THE START OF LINE  
4043 99c7 d7 8d                        STB  VD7            SAVE LENGTH OF LINE 
4044 99c9 dc 2b              L854D     LDD  BINVAL         GET THE HEX VALUE OF LINE NUMBER 
4045 99cb bd 95 94                     JSR  LBDCC          LIST THE LINE NUMBER ON THE SCREEN 
4046 99ce bd 91 6f                     JSR  LB9AC          PRINT A SPACE 
4047 99d1 8e 01 32                     LDX  #LINBUF+1      POINT X TO BUFFER 
4048 99d4 d6 8e                        LDB  VD8            * CHECK TO SEE IF LINE IS TO BE 
4049 99d6 26 25                        BNE  L8581          * LISTED TO SCREEN - BRANCH IF IT IS 
4050 99d8 5f                 L855C     CLRB                RESET DIGIT ACCUMULATOR - DEFAULT VALUE 
4051 99d9 bd 9b 03           L855D     JSR  L8687          GET KEY STROKE 
4052 99dc bd a2 c5                     JSR  L90AA          SET CARRY IF NOT NUMERIC 
4053 99df 25 0b                        BLO  L8570          BRANCH IF NOT NUMERIC 
4054 99e1 80 30                        SUBA #'0' 		MASK OFF ASCII  
4055 99e3 34 02                        PSHS A 			SAVE IT ON STACK  
4056 99e5 86 0a                        LDA  #10            NUMBER BEING CONVERTED IS BASE 10 
4057 99e7 3d                           MUL  					MULTIPLY ACCUMULATED VALUE BY BASE (10)  
4058 99e8 eb e0                        ADDB ,S+ 				ADD DIGIT TO ACCUMULATED VALUE  
4059 99ea 20 ed                        BRA  L855D          CHECK FOR ANOTHER DIGIT 
4060 99ec c0 01              L8570     SUBB #$01 			* REPEAT PARAMETER IN ACCB; IF IT  
4061 99ee c9 01                        ADCB #$01 			*IS 0, THEN MAKE IT ‘1’  
4062 99f0 81 41                        CMPA #'A' 			ABORT?          
4063 99f2 26 05                        BNE  L857D          NO 
4064 99f4 bd 91 1e                     JSR  LB958          PRINT CARRIAGE RETURN TO SCREEN 
4065 99f7 20 bb                        BRA  L8538          RESTART EDIT PROCESS - CANCEL ALL CHANGES 
4066 99f9 81 4c              L857D     CMPA #'L' 		LIST?           
4067 99fb 26 0b                        BNE  L858C          NO 
4068 99fd 8d 31              L8581     BSR  L85B4          LIST THE LINE 
4069 99ff 0f 8e                        CLR  VD8            RESET THE LIST FLAG TO ‘NO LIST’ 
4070 9a01 bd 91 1e                     JSR  LB958          PRINT CARRIAGE RETURN 
4071 9a04 20 c3                        BRA  L854D          GO INTERPRET ANOTHER EDIT COMMAND 
4072 9a06 32 62              L858A     LEAS $02,S PURGE RETURN ADDRESS OFF OF THE STACK  
4073 9a08 81 0d              L858C     CMPA #CR ENTER KEY?      
4074 9a0a 26 0d                        BNE  L859D          NO 
4075 9a0c 8d 22                        BSR  L85B4          ECHO THE LINE TO THE SCREEN 
4076 9a0e bd 91 1e           L8592     JSR  LB958          PRINT CARRIAGE RETURN 
4077 9a11 8e 01 32                     LDX  #LINBUF+1      * RESET BASIC’S INPUT POINTER 
4078 9a14 9f 7c                        STX  CHARAD         * TO THE LINE INPUT BUFFER 
4079 9a16 7e 84 8e                     JMP  LACA8          GO PUT LINE BACK IN PROGRAM 
4080 9a19 81 45              L859D     CMPA #'E' EXIT?           
4081 9a1b 27 f1                        BEQ  L8592          YES - SAME AS ENTER EXCEPT NO ECHO 
4082 9a1d 81 51                        CMPA #'Q' QUIT?           
4083 9a1f 26 06                        BNE  L85AB          NO 
4084 9a21 bd 91 1e                     JSR  LB958          PRINT CARRIAGE RETURN TO SCREEN 
4085 9a24 7e 84 64                     JMP  LAC73          GO TO COMMAND LEVEL - MAKE NO CHANGES 
4086 9a27 8d 02              L85AB     BSR  L85AF          INTERPRET THE REMAINING COMMANDS AS SUBROUTINES 
4087 9a29 20 ad                        BRA  L855C          GO INTERPRET ANOTHER EDIT COMMAND 
4088 9a2b 81 20              L85AF     CMPA #SPACE SPACE BAR?      
4089 9a2d 26 10                        BNE  L85C3          NO 
4090 9a2f 8c                 L85B3     FCB  SKP2           SKIP TWO BYTES 
4091                         * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN                      
4092                         *                              
4093 9a30 c6 f9              L85B4     LDB  #LBUFMX-1      250 BYTES MAX IN BUFFER 
4094 9a32 a6 84              L85B6     LDA  ,X             GET A CHARACTER FROM BUFFER 
4095 9a34 27 08                        BEQ  L85C2          EXIT IF IT’S A 0 
4096 9a36 bd 81 13                     JSR  PUTCHR         SEND CHAR TO CONSOLE OUT 
4097 9a39 30 01                        LEAX $01,X MOVE POINTER UP ONE  
4098 9a3b 5a                           DECB DECREMENT CHARACTER COUNTER  
4099 9a3c 26 f4                        BNE  L85B6          LOOP IF NOT DONE 
4100 9a3e 39                 L85C2     RTS                  
4101 9a3f 81 44              L85C3     CMPA #'D' DELETE?         
4102 9a41 26 48                        BNE  L860F          NO 
4103 9a43 6d 84              L85C7     TST  ,X             * CHECK FOR END OF LINE 
4104 9a45 27 f7                        BEQ  L85C2          * AND BRANCH IF SO 
4105 9a47 8d 04                        BSR  L85D1          REMOVE A CHARACTER 
4106 9a49 5a                           DECB DECREMENT REPEAT PARAMETER  
4107 9a4a 26 f7                        BNE  L85C7          BRANCH IF NOT DONE 
4108 9a4c 39                           RTS                  
4109                         * REMOVE ONE CHARACTER FROM BUFFER                      
4110 9a4d 0a 8d              L85D1     DEC  VD7            DECREMENT LENGTH OF BUFFER 
4111 9a4f 31 1f                        LEAY $-01,X POINT Y TO ONE BEFORE CURRENT BUFFER POINTER  
4112 9a51 31 21              L85D5     LEAY $01,Y INCREMENT TEMPORARY BUFFER POINTER  
4113 9a53 a6 21                        LDA  $01,Y          GET NEXT CHARACTER 
4114 9a55 a7 a4                        STA  ,Y             PUT IT IN CURRENT POSITION 
4115 9a57 26 f8                        BNE  L85D5          BRANCH IF NOT END OF LINE 
4116 9a59 39                           RTS                  
4117 9a5a 81 49              L85DE     CMPA #'I' INSERT?         
4118 9a5c 27 13                        BEQ  L85F5          YES 
4119 9a5e 81 58                        CMPA #'X' EXTEND?         
4120 9a60 27 0d                        BEQ  L85F3          YES 
4121 9a62 81 48                        CMPA #'H' HACK?           
4122 9a64 26 5c                        BNE  L8646          NO 
4123 9a66 6f 84                        CLR  ,X             TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG 
4124 9a68 1f 10                        TFR  X,D            PUT CURRENT BUFFER POINTER IN ACCD 
4125 9a6a 83 01 33                     SUBD #LINBUF+2 SUBTRACT INITIAL POINTER POSITION  
4126 9a6d d7 8d                        STB  VD7            SAVE NEW BUFFER LENGTH 
4127 9a6f 8d bf              L85F3     BSR  L85B4          DISPLAY THE LINE ON THE SCREEN 
4128 9a71 bd 9b 03           L85F5     JSR  L8687          GET A KEYSTROKE 
4129 9a74 81 0d                        CMPA #CR ENTER KEY?      
4130 9a76 27 8e                        BEQ  L858A          YES - INTERPRET ANOTHER COMMAND - PRINT LINE 
4131 9a78 81 1b                        CMPA #ESC ESCAPE?         
4132 9a7a 27 25                        BEQ  L8625          YES - RETURN TO COMMAND LEVEL - DON’T PRINT LINE 
4133 9a7c 81 08                        CMPA #BS BACK SPACE?     
4134 9a7e 26 22                        BNE  L8626          NO 
4135 9a80 8c 01 32                     CMPX #LINBUF+1 COMPARE POINTER TO START OF BUFFER  
4136 9a83 27 ec                        BEQ  L85F5          DO NOT ALLOW BS IF AT START 
4137 9a85 8d 45                        BSR  L8650          MOVE POINTER BACK ONE, BS TO SCREEN 
4138 9a87 8d c4                        BSR  L85D1          REMOVE ONE CHARACTER FROM BUFFER 
4139 9a89 20 e6                        BRA  L85F5          GET INSERT SUB COMMAND 
4140 9a8b 81 43              L860F     CMPA #'C' CHANGE?         
4141 9a8d 26 cb                        BNE  L85DE          NO 
4142 9a8f 6d 84              L8613     TST  ,X             CHECK CURRENT BUFFER CHARACTER 
4143 9a91 27 0e                        BEQ  L8625          BRANCH IF END OF LINE 
4144 9a93 bd 9b 03                     JSR  L8687          GET A KEYSTROKE 
4145 9a96 25 02                        BLO  L861E          BRANCH IF LEGITIMATE KEY 
4146 9a98 20 f5                        BRA  L8613          TRY AGAIN IF ILLEGAL KEY 
4147 9a9a a7 80              L861E     STA  ,X+            INSERT NEW CHARACTER INTO BUFFER 
4148 9a9c 8d 37                        BSR  L8659          SEND NEW CHARACTER TO SCREEN 
4149 9a9e 5a                           DECB DECREMENT REPEAT PARAMETER  
4150 9a9f 26 ee                        BNE  L8613          BRANCH IF NOT DONE 
4151 9aa1 39                 L8625     RTS                  
4152 9aa2 d6 8d              L8626     LDB  VD7            GET LENGTH OF LINE 
4153 9aa4 c1 f9                        CMPB #LBUFMX-1 COMPARE TO MAXIMUM LENGTH  
4154 9aa6 26 02                        BNE  L862E          BRANCH IF NOT AT MAXIMUM 
4155 9aa8 20 c7                        BRA  L85F5          IGNORE INPUT IF LINE AT MAXIMUM LENGTH 
4156 9aaa 34 10              L862E     PSHS X SAVE CURRENT BUFFER POINTER  
4157 9aac 6d 80              L8630     TST  ,X+            * SCAN THE LINE UNTIL END OF 
4158 9aae 26 fc                        BNE  L8630          * LINE (0) IS FOUND 
4159 9ab0 e6 82              L8634     LDB  ,-X            DECR TEMP LINE POINTER AND GET A CHARACTER 
4160 9ab2 e7 01                        STB  $01,X          PUT CHARACTER BACK DOWN ONE SPOT 
4161 9ab4 ac e4                        CMPX ,S HAVE WE REACHED STARTING POINT?  
4162 9ab6 26 f8                        BNE  L8634          NO - KEEP GOING 
4163 9ab8 32 62                        LEAS $02,S PURGE BUFFER POINTER FROM STACK  
4164 9aba a7 80                        STA  ,X+            INSERT NEW CHARACTER INTO THE LINE 
4165 9abc 8d 17                        BSR  L8659          SEND A CHARACTER TO CONSOLE OUT 
4166 9abe 0c 8d                        INC  VD7            ADD ONE TO BUFFER LENGTH 
4167 9ac0 20 af                        BRA  L85F5          GET INSERT SUB COMMAND 
4168 9ac2 81 08              L8646     CMPA #BS BACKSPACE?      
4169 9ac4 26 12                        BNE  L865C          NO 
4170 9ac6 8d 04              L864A     BSR  L8650          MOVE POINTER BACK 1, SEND BS TO SCREEN 
4171 9ac8 5a                           DECB DECREMENT REPEAT PARAMETER  
4172 9ac9 26 fb                        BNE  L864A          LOOP UNTIL DONE 
4173 9acb 39                           RTS                  
4174 9acc 8c 01 32           L8650     CMPX #LINBUF+1 COMPARE POINTER TO START OF BUFFER  
4175 9acf 27 d0                        BEQ  L8625          DO NOT ALLOW BS IF AT START 
4176 9ad1 30 1f                        LEAX $-01,X MOVE POINTER BACK ONE  
4177 9ad3 86 08                        LDA  #BS            BACK SPACE 
4178 9ad5 7e 81 13           L8659     JMP  PUTCHR         SEND TO CONSOLE OUT 
4179 9ad8 81 4b              L865C     CMPA #'K' KILL?           
4180 9ada 27 05                        BEQ  L8665          YES 
4181 9adc 80 53                        SUBA #'S' SEARCH?         
4182 9ade 27 01                        BEQ  L8665          YES 
4183 9ae0 39                           RTS                  
4184 9ae1 34 02              L8665     PSHS A SAVE KILL/SEARCH FLAG ON STACK  
4185 9ae3 8d 1e                        BSR  L8687          * GET A KEYSTROKE (TARGET CHARACTER) 
4186 9ae5 34 02                        PSHS A * AND SAVE IT ON STACK  
4187 9ae7 a6 84              L866B     LDA  ,X             Error 2029 
4188 9ae9 27 16                        BEQ  L8685          Error 2029 
4189 9aeb 6d 61                        TST  $01,S          CHECK KILL/SEARCH FLAG 
4190 9aed 26 06                        BNE  L8679          BRANCH IF KILL 
4191 9aef 8d e4                        BSR  L8659          SEND A CHARACTER TO CONSOLE OUT 
4192 9af1 30 01                        LEAX $01,X INCREMENT BUFFER POINTER  
4193 9af3 20 03                        BRA  L867C          CHECK NEXT INPUT CHARACTER 
4194 9af5 bd 9a 4d           L8679     JSR  L85D1          REMOVE ONE CHARACTER FROM BUFFER 
4195 9af8 a6 84              L867C     LDA  ,X             GET CURRENT INPUT CHARACTER 
4196 9afa a1 e4                        CMPA ,S COMPARE TO TARGET CHARACTER  
4197 9afc 26 e9                        BNE  L866B          BRANCH IF NO MATCH 
4198 9afe 5a                           DECB DECREMENT REPEAT PARAMETER  
4199 9aff 26 e6                        BNE  L866B          BRANCH IF NOT DONE 
4200 9b01 35 a0              L8685     PULS Y,PC THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A  
4201                         *                              
4202                         * GET A KEYSTRKE                      
4203 9b03 bd 80 fa           L8687     JSR  LA171          CALL CONSOLE IN : DEV NBR=SCREEN 
4204 9b06 81 7f                        CMPA #$7F GRAPHIC CHARACTER?  
4205 9b08 24 f9                        BCC  L8687          YES - GET ANOTHER CHAR 
4206 9b0a 81 5f                        CMPA #$5F SHIFT UP ARROW (QUIT INSERT)  
4207 9b0c 26 02                        BNE  L8694          NO 
4208 9b0e 86 1b                        LDA  #ESC           REPLACE W/ESCAPE CODE 
4209 9b10 81 0d              L8694     CMPA #CR ENTER KEY       
4210 9b12 27 0e                        BEQ  L86A6          YES 
4211 9b14 81 1b                        CMPA #ESC ESCAPE?         
4212 9b16 27 0a                        BEQ  L86A6          YES 
4213 9b18 81 08                        CMPA #BS BACKSPACE?      
4214 9b1a 27 06                        BEQ  L86A6          YES 
4215 9b1c 81 20                        CMPA #SPACE SPACE           
4216 9b1e 25 e3                        BLO  L8687          GET ANOTHER CHAR IF CONTROL CHAR 
4217 9b20 1a 01                        ORCC #$01 SET CARRY       
4218 9b22 39                 L86A6     RTS                  
4219                                                        
4220                         * TRON                         
4221 9b23 86                 TRON      FCB  SKP1LD         SKIP ONE BYTE AND LDA #$4F 
4222                                                        
4223                         * TROFF                        
4224 9b24 4f                 TROFF     CLRA                TROFF FLAG 
4225 9b25 97 82                        STA  TRCFLG         TRON/TROFF FLAG:0=TROFF, <> 0=TRON 
4226 9b27 39                           RTS                  
4227                                                        
4228                         * POS                          
4229                                                        
4230 9b28 86 00              POS       LDA  #0             GET DEVICE NUMBER 
4231 9b2a d6 79                        LDB  LPTPOS         GET PRINT POSITION 
4232 9b2c 1d                 LA5E8     SEX                 CONVERT ACCB TO 2 DIGIT SIGNED INTEGER 
4233 9b2d 7e 8c e1                     JMP  GIVABF         CONVERT ACCD TO FLOATING POINT 
4234                                                        
4235                                                        
4236                         * VARPTR                       
4237 9b30 bd 8a 51           VARPT     JSR  LB26A          SYNTAX CHECK FOR ‘(‘ 
4238 9b33 dc 1f                        LDD  ARYEND         GET ADDR OF END OF ARRAYS 
4239 9b35 34 06                        PSHS B,A            SAVE IT ON STACK 
4240 9b37 bd 8b 3d                     JSR  LB357          GET VARIABLE DESCRIPTOR 
4241 9b3a bd 8a 4e                     JSR  LB267          SYNTAX CHECK FOR ‘)‘ 
4242 9b3d 35 06                        PULS A,B            GET END OF ARRAYS ADDR BACK 
4243 9b3f 1e 10                        EXG  X,D            SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR 
4244 9b41 9c 1f                        CMPX ARYEND         COMPARE TO NEW END OF ARRAYS 
4245 9b43 26 52                        BNE  L8724          ‘FC’ ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR 
4246 9b45 7e 8c e1                     JMP  GIVABF         CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER 
4247                                                        
4248                                                        
4249 9b48 bd a4 b3           L86D6     JSR  GETNCH         GET INPUT CHAR FROM BASIC 
4250 9b4b bd 8a 51                     JSR  LB26A          SYNTAX CHECK FOR ‘(‘ 
4251 9b4e bd 8b 3d                     JSR  LB357          * GET VARIABLE DESCRIPTOR ADDRESS AND 
4252 9b51 34 10                        PSHS X              * SAVE IT ON THE STACK 
4253 9b53 ec 02                        LDD  $02,X          POINT ACCD TO START OF OLDSTRING 
4254 9b55 10 93 21                     CMPD FRETOP         COMPARE TO START OF CLEARED SPACE 
4255 9b58 23 04                        BLS  L86EB          BRANCH IF <= 
4256 9b5a 93 27                        SUBD MEMSIZ         SUBTRACT OUT TOP OF CLEARED SPACE 
4257 9b5c 23 12                        BLS  L86FD          BRANCH IF STRING IN STRING SPACE 
4258 9b5e e6 84              L86EB     LDB  ,X             GET LENGTH OF OLDSTRING 
4259 9b60 bd 8d 5a                     JSR  LB56D          RESERVE ACCB BYTES IN STRING SPACE 
4260 9b63 34 10                        PSHS X              SAVE RESERVED SPACE STRING ADDRESS ON STACK 
4261 9b65 ae 62                        LDX  $02,S          POINT X TO OLDSTRING DESCRIPTOR 
4262 9b67 bd 8e 30                     JSR  LB643          MOVE OLDSTRING INTO STRING SPACE 
4263 9b6a 35 50                        PULS X,U            * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING 
4264 9b6c af 42                        STX  $02,U          * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS 
4265 9b6e 34 40                        PSHS U              SAVE OLDSTRING DESCRIPTOR ADDRESS 
4266 9b70 bd 8f 29           L86FD     JSR  LB738          SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION 
4267 9b73 34 04                        PSHS B              SAVE POSITION PARAMETER ON STACK 
4268 9b75 5d                           TSTB * CHECK POSITION PARAMETER AND BRANCH  
4269 9b76 27 1f                        BEQ  L8724          * IF START OF STRING 
4270 9b78 c6 ff                        LDB  #$FF           DEFAULT REPLACEMENT LENGTH = $FF 
4271 9b7a 81 29                        CMPA #')'           * CHECK FOR END OF MID$ STATEMENT AND 
4272 9b7c 27 03                        BEQ  L870E          * BRANCH IF AT END OF STATEMENT 
4273 9b7e bd 8f 29                     JSR  LB738          SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION 
4274 9b81 34 04              L870E     PSHS B              SAVE LENGTH PARAMETER ON STACK 
4275 9b83 bd 8a 4e                     JSR  LB267          SYNTAX CHECK FOR ‘)‘ 
4276 9b86 c6 b3                        LDB  #$B3           TOKEN FOR = 
4277 9b88 bd 8a 56                     JSR  LB26F          SYNTAX CHECK FOR “=‘ 
4278 9b8b 8d 2e                        BSR  L8748          EVALUATE REPLACEMENT STRING 
4279 9b8d 1f 13                        TFR  X,U            SAVE REPLACEMENT STRING ADDRESS IN U 
4280 9b8f ae 62                        LDX  $02,S          POINT X TO OLOSTRING DESCRIPTOR ADDRESS 
4281 9b91 a6 84                        LDA  ,X             GET LENGTH OF OLDSTRING 
4282 9b93 a0 61                        SUBA $01,S          SUBTRACT POSITION PARAMETER 
4283 9b95 24 03                        BCC  L8727          INSERT REPLACEMENT STRING INTO OLDSTRING 
4284 9b97 7e 8c 37           L8724     JMP  LB44A          ‘FC’ ERROR IF POSITION > LENGTH OF OLDSTRING 
4285 9b9a 4c                 L8727     INCA                * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT 
4286                         *                             * (INCLUSIVE) OF THE POSITION PARAMETER 
4287 9b9b a1 e4                        CMPA ,S              
4288 9b9d 24 02                        BCC  L872E          BRANCH IF NEW STRING WILL FIT IN OLDSTRING 
4289 9b9f a7 e4                        STA  ,S             IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT 
4290 9ba1 a6 61              L872E     LDA  $01,S          GET POSITION PARAMETER 
4291 9ba3 1e 89                        EXG  A,B            ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER 
4292 9ba5 ae 02                        LDX  $02,X          POINT X TO OLDSTRING ADDRESS 
4293 9ba7 5a                           DECB                * BASIC’S POSITION PARAMETER STARTS AT 1; THIS ROUTINE 
4294                         *                             * WANTS IT TO START AT ZERO 
4295 9ba8 3a                           ABX                 POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO 
4296 9ba9 4d                           TSTA                * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO 
4297 9baa 27 0d                        BEQ  L8746          * THEN RETURN 
4298 9bac a1 e4                        CMPA ,S              
4299 9bae 23 02                        BLS  L873F          ADJUSTED LENGTH PARAMETER, THEN BRANCH 
4300 9bb0 a6 e4                        LDA  ,S             OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE 
4301 9bb2 1f 89              L873F     TFR  A,B            SAVE NUMBER OF BYTES TO MOVE IN ACCB 
4302 9bb4 1e 31                        EXG  U,X            SWAP SOURCE AND DESTINATION POINTERS 
4303 9bb6 bd 81 c9                     JSR  LA59A          MOVE (B) BYTES FROM (X) TO (U) 
4304 9bb9 35 96              L8746     PULS A,B,X,PC        
4305 9bbb bd 89 38           L8748     JSR  LB156          EVALUATE EXPRESSION 
4306 9bbe 7e 8e 41                     JMP  LB654          *‘TM’ ERROR IF NUMERIC; RETURN WITH X POINTING 
4307                         *                             *TO STRING, ACCB = LENGTH 
4308                                                        
4309                         * STRING                       
4310 9bc1 bd 8a 51           STRING    JSR  LB26A          SYNTAX CHECK FOR ‘(’ 
4311 9bc4 bd 8e fa                     JSR  LB70B          EVALUATE EXPRESSION; ERROR IF > 255 
4312 9bc7 34 04                        PSHS B              SAVE LENGTH OF STRING 
4313 9bc9 bd 8a 54                     JSR  LB26D          SYNTAX CHECK FOR COMMA 
4314 9bcc bd 89 38                     JSR  LB156          EVALUATE EXPRESSION 
4315 9bcf bd 8a 4e                     JSR  LB267          SYNTAX CHECK FOR ‘)‘ 
4316 9bd2 96 06                        LDA  VALTYP         GET VARIABLE TYPE 
4317 9bd4 26 05                        BNE  L8768          BRANCH IF STRING 
4318 9bd6 bd 8e fd                     JSR  LB70E          CONVERT FPA0 INTO AN INTEGER IN ACCB 
4319 9bd9 20 03                        BRA  L876B          SAVE THE STRING IN STRING SPACE 
4320 9bdb bd 8e 91           L8768     JSR  LB6A4          GET FIRST BYTE OF STRING 
4321 9bde 34 04              L876B     PSHS B              SAVE FIRST BYTE OF EXPRESSION 
4322 9be0 e6 61                        LDB  $01,S          GET LENGTH OF STRING 
4323 9be2 bd 8c fc                     JSR  LB50F          RESERVE ACCB BYTES IN STRING SPACE 
4324 9be5 35 06                        PULS A,B            GET LENGTH OF STRING AND CHARACTER 
4325 9be7 27 05                        BEQ  L877B          BRANCH IF NULL STRING 
4326 9be9 a7 80              L8776     STA  ,X+            SAVE A CHARACTER IN STRING SPACE 
4327 9beb 5a                           DECB                DECREMENT LENGTH 
4328 9bec 26 fb                        BNE  L8776          BRANCH IF NOT DONE 
4329 9bee 7e 8e 88           L877B     JMP  LB69B          PUT STRING DESCRIPTOR ONTO STRING STACK 
4330                                                        
4331                         * INSTR                        
4332 9bf1 bd 8a 51           INSTR     JSR  LB26A          SYNTAX CHECK FOR ‘(‘ 
4333 9bf4 bd 89 38                     JSR  LB156          EVALUATE EXPRESSION 
4334 9bf7 c6 01                        LDB  #$01           DEFAULT POSITION = 1 (SEARCH START) 
4335 9bf9 34 04                        PSHS B              SAVE START 
4336 9bfb 96 06                        LDA  VALTYP         GET VARIABLE TYPE 
4337 9bfd 26 10                        BNE  L879C          BRANCH IF STRING 
4338 9bff bd 8e fd                     JSR  LB70E          CONVERT FPA0 TO INTEGER IN ACCB 
4339 9c02 e7 e4                        STB  ,S             SAVE START SEARCH VALUE 
4340 9c04 27 91                        BEQ  L8724          BRANCH IF START SEARCH AT ZERO 
4341 9c06 bd 8a 54                     JSR  LB26D          SYNTAX CHECK FOR COMMA 
4342 9c09 bd 89 38                     JSR  LB156          EVALUATE EXPRESSION - SEARCH STRING 
4343 9c0c bd 89 28                     JSR  LB146          ‘TM’ ERROR IF NUMERIC 
4344 9c0f 9e 52              L879C     LDX  FPA0+2         SEARCH STRING DESCRIPTOR ADDRESS 
4345 9c11 34 10                        PSHS X              SAVE ON THE STACK 
4346 9c13 bd 8a 54                     JSR  LB26D          SYNTAX CHECK FOR COMMA 
4347 9c16 bd 9b bb                     JSR  L8748          EVALUATE TARGET STRING EXPRESSION 
4348 9c19 34 14                        PSHS X,B            SAVE ADDRESS AND LENGTH ON STACK 
4349 9c1b bd 8a 4e                     JSR  LB267          SYNTAX CHECK FOR ')' 
4350 9c1e ae 63                        LDX  $03,S          * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS 
4351 9c20 bd 8e 46                     JSR  LB659          * AND GET THE LENGTH ANDADDRESS OF SEARCH STRING 
4352 9c23 34 04                        PSHS B              SAVE LENGTH ON STACK 
4353                         *                              
4354                         * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION                      
4355                         * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET                      
4356                         * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION                      
4357 9c25 e1 66                        CMPB $06,S          COMPARE LENGTH OF SEARCH STRING TO START 
4358 9c27 25 23                        BLO  L87D9          POSITION; RETURN 0 IF LENGTH < START 
4359 9c29 a6 61                        LDA  $01,S          GET LENGTH OF TARGET STRING 
4360 9c2b 27 1c                        BEQ  L87D6          BRANCH IF TARGET STRING = NULL 
4361 9c2d e6 66                        LDB  $06,S          GET START POSITION 
4362 9c2f 5a                           DECB                MOVE BACK ONE 
4363 9c30 3a                           ABX  POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START  
4364 9c31 31 84              L87BE     LEAY ,X             POINT Y TO SEARCH POSITION 
4365 9c33 ee 62                        LDU  $02,S          POINT U TO START OF TARGET 
4366 9c35 e6 61                        LDB  $01,S          LOAD ACCB WITH LENGTH OF TARGET 
4367 9c37 a6 e4                        LDA  ,S             LOAD ACCA WITH LENGTH OF SEARCH 
4368 9c39 a0 66                        SUBA $06,S          SUBTRACT SEARCH POSITION FROM SEARCH LENGTH 
4369 9c3b 4c                           INCA                ADD ONE 
4370 9c3c a1 61                        CMPA $01,S          COMPARE TO TARGET LENGTH 
4371 9c3e 25 0c                        BLO  L87D9          RETURN 0 IF TARGET LENGTH > WHAT’S LEFT OF SEARCH STRING 
4372 9c40 a6 80              L87CD     LDA  ,X+            GET A CHARACTER FROM SEARCH STRING 
4373 9c42 a1 c0                        CMPA ,U+            COMPARE IT TO TARGET STRING 
4374 9c44 26 0c                        BNE  L87DF          BRANCH IF NO MATCH 
4375 9c46 5a                           DECB                DECREMENT TARGET LENGTH 
4376 9c47 26 f7                        BNE  L87CD          CHECK ANOTHER CHARACTER 
4377 9c49 e6 66              L87D6     LDB  $06,S          GET MATCH POSITION 
4378 9c4b 21                 L87D8     FCB  SKP1           SKIP NEXT BYTE 
4379 9c4c 5f                 L87D9     CLRB                MATCH ADDRESS = 0 
4380 9c4d 32 67                        LEAS $07,S          CLEAN UP THE STACK 
4381 9c4f 7e 8c e0                     JMP  LB4F3          CONVERT ACCB TO FP NUMBER 
4382 9c52 6c 66              L87DF     INC  $06,S          INCREMENT SEARCH POSITION 
4383 9c54 30 21                        LEAX $01,Y          MOVE X TO NEXT SEARCH POSITION 
4384 9c56 20 d9                        BRA  L87BE          KEEP LOOKING FOR A MATCH 
4385                                                        
4386                         * EXTENDED BASIC RVEC19 HOOK CODE                      
4387 9c58 81 26              XVEC19    CMPA  #'&'           * 
4388 9c5a 26 60                        BNE  L8845          * RETURN IF NOT HEX OR OCTAL VARIABLE 
4389 9c5c 32 62                        LEAS  $02,S          PURGE RETURN ADDRESS FROM STACK 
4390                         * PROCESS A VARIABLE PRECEEDED BY A ‘&‘ (&H,&O)                      
4391 9c5e 0f 52              L87EB     CLR  FPA0+2         * CLEAR BOTTOM TWO 
4392 9c60 0f 53                        CLR  FPA0+3         * BYTES OF FPA0 
4393 9c62 8e 00 52                     LDX  #FPA0+2        BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR) 
4394 9c65 bd a4 b3                     JSR  GETNCH         GET A CHARACTER FROM BASIC 
4395 9c68 81 4f                        CMPA #'O'            
4396 9c6a 27 13                        BEQ  L880A          YES 
4397 9c6c 81 48                        CMPA #'H'            
4398 9c6e 27 25                        BEQ  L881F          YES 
4399 9c70 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
4400 9c73 20 0d                        BRA  L880C          DEFAULT TO OCTAL (&O) 
4401 9c75 81 38              L8800     CMPA #'8'            
4402 9c77 10 22 ed e4                  LBHI LB277           
4403 9c7b c6 03                        LDB  #$03           BASE 8 MULTIPLIER 
4404 9c7d 8d 2c                        BSR  L8834          ADD DIGIT TO TEMPORARY ACCUMULATOR 
4405                         * EVALUATE AN &O VARIABLE                      
4406 9c7f bd a4 b3           L880A     JSR  GETNCH         GET A CHARACTER FROM BASIC 
4407 9c82 25 f1              L880C     BLO  L8800          BRANCH IF NUMERIC 
4408 9c84 0f 50              L880E     CLR  FPA0           * CLEAR 2 HIGH ORDER 
4409 9c86 0f 51                        CLR  FPA0+1         * BYTES OF FPA0 
4410 9c88 0f 06                        CLR  VALTYP         SET VARXABLE TYPE TO NUMERIC 
4411 9c8a 0f 63                        CLR  FPSBYT         ZERO OUT SUB BYTE OF FPA0 
4412 9c8c 0f 54                        CLR  FP0SGN         ZERO OUT MANTISSA SIGN OF FPA0 
4413 9c8e c6 a0                        LDB  #$A0           * SET EXPONENT OF FPA0 
4414 9c90 d7 4f                        STB  FP0EXP         * 
4415 9c92 7e 91 df                     JMP  LBA1C          GO NORMALIZE FPA0 
4416                         * EVALUATE AN &H VARIABLE                      
4417 9c95 bd a4 b3           L881F     JSR  GETNCH         GET A CHARACTER FROM BASIC 
4418 9c98 25 0b                        BLO  L882E          BRANCH IF NUMERIC 
4419 9c9a bd 8b 8d                     JSR  LB3A2          SET CARRY IF NOT ALPHA 
4420 9c9d 25 e5                        BLO  L880E          BRANCH IF NOT ALPHA OR NUMERIC 
4421 9c9f 81 47                        CMPA  #'G'           CHECK FOR LETTERS A-F 
4422 9ca1 24 e1                        BCC  L880E          BRANCH IF >= G (ILLEGAL HEX LETTER) 
4423 9ca3 80 07                        SUBA #7             SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9 
4424 9ca5 c6 04              L882E     LDB  #$04           BASE 16 DIGIT MULTIPLIER = 2**4 
4425 9ca7 8d 02                        BSR  L8834          ADD DIGIT TO TEMPORARY ACCUMULATOR 
4426 9ca9 20 ea                        BRA  L881F          KEEP EVALUATING VARIABLE 
4427 9cab 68 01              L8834     ASL  $01,X          * MULTIPLY TEMPORARY 
4428 9cad 69 84                        ROL  ,X             * ACCUMULATOR BY TWO 
4429 9caf 10 25 f5 a2                  LBCS LBA92          ‘OV' OVERFLOW ERROR 
4430 9cb3 5a                           DECB                DECREMENT SHIFT COUNTER 
4431 9cb4 26 f5                        BNE  L8834          MULTIPLY TEMPORARY ACCUMULATOR AGAIN 
4432 9cb6 80 30                        SUBA #'0'           MASK OFF ASCII 
4433 9cb8 ab 01                        ADDA  $01,X          * ADD DIGIT TO TEMPORARY 
4434 9cba a7 01                        STA  $01,X          * ACCUMULATOR AND SAVE IT 
4435 9cbc 39                 L8845     RTS                  
4436                                                        
4437 9cbd 35 40              XVEC15    PULS U              PULL RETURN ADDRESS AND SAVE IN U REGISTER 
4438 9cbf 0f 06                        CLR  VALTYP         SET VARIABLE TYPE TO NUMERIC 
4439 9cc1 9e 7c                        LDX  CHARAD         CURRENT INPUT POINTER TO X 
4440 9cc3 bd a4 b3                     JSR  GETNCH         GET CHARACTER FROM BASIC 
4441 9cc6 81 26                        CMPA #'&'           HEX AND OCTAL VARIABLES ARE PRECEEDED BY & 
4442 9cc8 27 94                        BEQ  L87EB          PROCESS A ‘&‘ VARIABLE 
4443 9cca 81 b5                        CMPA #$B5           TOKEN FOR FN 
4444 9ccc 27 5f                        BEQ  L88B4          PROCESS FN CALL 
4445 9cce 81 ff                        CMPA #$FF           CHECK FOR SECONDARY TOKEN 
4446 9cd0 26 09                        BNE  L8862          NOT SECONDARY 
4447 9cd2 bd a4 b3                     JSR  GETNCH         GET CHARACTER FROM BASIC 
4448 9cd5 81 83                        CMPA  #$83           TOKEN FOR USR 
4449 9cd7 10 27 00 af                  LBEQ  L892C          PROCESS USR CALL 
4450 9cdb 9f 7c              L8862     STX  CHARAD         RESTORE BASIC’S INPUT POINTER 
4451 9cdd 6e c4                        JMP  ,U             RETURN TO CALLING ROUTINE 
4452 9cdf 9e 68              L8866     LDX  CURLIN         GET CURRENT LINE NUMBER 
4453 9ce1 30 01                        LEAX  $01,X          IN DIRECT MODE? 
4454 9ce3 26 d7                        BNE  L8845          RETURN IF NOT IN DIRECT MODE 
4455 9ce5 c6 16                        LDB  #2*11          ‘ILLEGAL DIRECT STATEMENT’ ERROR 
4456 9ce7 7e 84 41           L886E     JMP  LAC46          PROCESS ERROR 
4457                                                        
4458 9cea ae 9f 00 7c        DEF       LDX  [CHARAD]       GET TWO INPUT CHARS 
4459 9cee 8c ff 83                     CMPX  #$FF83         TOKEN FOR USR 
4460 9cf1 10 27 00 75                  LBEQ L890F          BRANCH IF DEF USR 
4461 9cf5 8d 23                        BSR  L88A1          GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME 
4462 9cf7 8d e6                        BSR  L8866          DON’T ALLOW DEF FN IF IN DIRECT MODE 
4463 9cf9 bd 8a 51                     JSR  LB26A          SYNTAX CHECK FOR ‘(‘ 
4464 9cfc c6 80                        LDB  #$80           * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE 
4465 9cfe d7 08                        STB  ARYDIS         * AND SAVE IT IN THE ARRAY DISABLE FLAG 
4466 9d00 bd 8b 3d                     JSR  LB357          GET VARIABLE DESCRIPTOR 
4467 9d03 8d 25                        BSR  L88B1          ‘TM’ ERROR IF STRING 
4468 9d05 bd 8a 4e                     JSR  LB267          SYNTAX CHECK FOR ‘)‘ 
4469 9d08 c6 b3                        LDB  #$B3           TOKEN FOR ‘=‘ 
4470 9d0a bd 8a 56                     JSR  LB26F          DO A SYNTAX CHECK FOR = 
4471 9d0d 9e 4b                        LDX  V4B            GET THE ADDRESS OF THE FN NAME DESCRIPTOR 
4472 9d0f dc 7c                        LDD  CHARAD         * GET THE CURRENT INPUT POINTER ADDRESS AND 
4473 9d11 ed 84                        STD  ,X             * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR 
4474 9d13 dc 39                        LDD  VARPTR         = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT 
4475 9d15 ed 02                        STD  $02,X          = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME 
4476 9d17 7e 86 d7                     JMP  DATA           MOVE INPUT POINTER TO END OF LINE OR SUBLINE 
4477 9d1a c6 b5              L88A1     LDB  #$B5           TOKEN FOR FN 
4478 9d1c bd 8a 56                     JSR  LB26F          DO A SYNTAX CHECK FOR FN 
4479 9d1f c6 80                        LDB  #$80           * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG 
4480 9d21 d7 08                        STB  ARYDIS         * AND SAVE IT IN ARRAY VARIABLE FLAG 
4481 9d23 8a 80                        ORA  #$80           SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE 
4482 9d25 bd 8b 43                     JSR  LB35C          * GET THE DESCRIPTOR ADDRESS OF THIS 
4483 9d28 9f 4b                        STX  V4B            * VARIABLE AND SAVE IT IN V4B 
4484 9d2a 7e 89 25           L88B1     JMP  LB143          ‘TM’ ERROR IF STRING VARIABLE 
4485                         * EVALUATE AN FN CALL                      
4486 9d2d 8d eb              L88B4     BSR  L88A1          * GET THE DESCRIPTOR OF THE FN NAME 
4487 9d2f 34 10                        PSHS X              * VARIABLE AND SAVE IT ON THE STACK 
4488 9d31 bd 8a 49                     JSR  LB262          SYNTAX CHECK FOR ‘(‘ & EVALUATE EXPR 
4489 9d34 8d f4                        BSR  L88B1          ‘TM’ ERROR IF STRING VARIABLE 
4490 9d36 35 40                        PULS U              POINT U TO FN NAME DESCRIPTOR 
4491 9d38 c6 32                        LDB  #2*25          ‘UNDEFINED FUNCTION CALL’ ERROR 
4492 9d3a ae 42                        LDX  $02,U          POINT X TO ARGUMENT VARIABLE DESCRIPTOR 
4493 9d3c 27 a9                        BEQ  L886E          BRANCH TO ERROR HANDLER 
4494 9d3e 10 9e 7c                     LDY  CHARAD         SAVE CURRENT INPUT POINTER IN Y 
4495 9d41 ee c4                        LDU  ,U             * POINT U TO START OF FN FORMULA AND 
4496 9d43 df 7c                        STU  CHARAD         * SAVE IT IN INPUT POINTER 
4497 9d45 a6 04                        LDA  $04,X          = GET FP VALUE OF 
4498 9d47 34 02                        PSHS A              = ARGUMENT VARIABLE, CURRENT INPUT 
4499 9d49 ec 84                        LDD  ,X             = POINTER, AND ADDRESS OF START 
4500 9d4b ee 02                        LDU  $02,X          = OF FN FORMULA AND SAVE 
4501 9d4d 34 76                        PSHS U,Y,X,B,A      = THEM ON THE STACK 
4502 9d4f bd 93 f8                     JSR  LBC35          PACK FPA0 AND SAVE IT IN (X) 
4503 9d52 bd 89 23           L88D9     JSR  LB141          EVALUATE FN EXPRESSION 
4504 9d55 35 76                        PULS  A,B,X,Y,U      RESTORE REGISTERS 
4505 9d57 ed 84                        STD  ,X             * GET THE FP 
4506 9d59 ef 02                        STU  $02,X          * VALUE OF THE ARGUMENT 
4507 9d5b 35 02                        PULS A              * VARIABLE OFF OF THE 
4508 9d5d a7 04                        STA  $04,X          * STACK AND RE-SAVE IT 
4509 9d5f bd a4 b9                     JSR  GETCCH         GET FINAL CHARACTER OF THE FN FORMULA 
4510 9d62 10 26 ec f9                  LBNE  LB277          ‘SYNTAX’ ERROR IF NOT END OF LINE 
4511 9d66 10 9f 7c                     STY  CHARAD         RESTORE INPUT POINTER 
4512 9d69 39                 L88EF     RTS                  
4513                                                        
4514                                                        
4515                                                        
4516                         * DEF USR                      
4517 9d6a bd a4 b3           L890F     JSR  GETNCH         SKIP PAST SECOND BYTE OF DEF USR TOKEN 
4518 9d6d 8d 09                        BSR  L891C          GET FN NUMBER 
4519 9d6f 34 10                        PSHS  X              SAVE FN EXEC ADDRESS STORAGE LOC 
4520 9d71 8d 2f                        BSR  L8944          CALCULATE EXEC ADDRESS 
4521 9d73 35 40                        PULS U              GET FN EXEC ADDRESS STORAGE LOC 
4522 9d75 af c4                        STX  ,U             SAVE EXEC ADDRESS 
4523 9d77 39                           RTS                  
4524 9d78 5f                 L891C     CLRB                DEFAULT TO USR0 IF NO ARGUMENT 
4525 9d79 bd a4 b3                     JSR  GETNCH         GET A CHARACTER FROM BASIC 
4526 9d7c 24 07                        BCC  L8927          BRANCH IF NOT NUMERIC 
4527 9d7e 80 30                        SUBA  #'0'           MASK OFF ASCII 
4528 9d80 1f 89                        TFR  A,B            SAVE USR NUMBER IN ACCB 
4529 9d82 bd a4 b3                     JSR  GETNCH         GET A CHARACTER FROM BASIC 
4530 9d85 9e 83              L8927     LDX  USRADR         GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS 
4531 9d87 58                           ASLB                X2 - 2 BYTES/USR ADDRESS 
4532 9d88 3a                           ABX                 ADD OFFSET TO START ADDRESS OF STORAGE LOCs 
4533 9d89 39                           RTS                  
4534                         * PROCESS A USR CALL                      
4535 9d8a 8d ec              L892C     BSR  L891C          GET STORAGE LOC OF EXEC ADDRESS FOR USR N 
4536 9d8c ae 84                        LDX  ,X             * GET EXEC ADDRESS AND 
4537 9d8e 34 10                        PSHS X              * PUSH IT ONTO STACK 
4538 9d90 bd 8a 49                     JSR  LB262          SYNTAX CHECK FOR ‘(‘ & EVALUATE EXPR 
4539 9d93 8e 00 4f                     LDX  #FP0EXP        POINT X TO FPA0 
4540 9d96 96 06                        LDA  VALTYP         GET VARIABLE TYPE 
4541 9d98 27 07                        BEQ  L8943          BRANCH IF NUMERIC, STRING IF <> 0 
4542 9d9a bd 8e 44                     JSR  LB657          GET LENGTH & ADDRESS OF STRING VARIABLE 
4543 9d9d 9e 52                        LDX  FPA0+2         GET POINTER TO STRING DESCRIPTOR 
4544 9d9f 96 06                        LDA  VALTYP         GET VARIABLE TYPE 
4545 9da1 39                 L8943     RTS                 JUMP TO USR ROUTINE (PSHS X ABOVE) 
4546 9da2 c6 b3              L8944     LDB  #$B3           TOKEN FOR ‘=‘ 
4547 9da4 bd 8a 56                     JSR  LB26F          DO A SYNTAX CHECK FOR = 
4548 9da7 7e 8f 2e                     JMP  LB73D          EVALUATE EXPRESSION, RETURN VALUE IN X 
4549                                                        
4550                                                        
4551                                                        
4552                         * DEL                          
4553 9daa 10 27 ee 89        DEL       LBEQ LB44A          FC’ ERROR IF NO ARGUMENT 
4554 9dae bd 87 65                     JSR  LAF67          CONVERT A DECIMAL BASiC NUMBER TO BINARY 
4555 9db1 bd 84 e7                     JSR  LAD01          FIND RAM ADDRESS OF START OF A BASIC LINE 
4556 9db4 9f 89                        STX  VD3            SAVE RAM ADDRESS OF STARTING LINE NUMBER 
4557 9db6 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
4558 9db9 27 11                        BEQ  L8990          BRANCH IF END OF LINE 
4559 9dbb 81 ac                        CMPA #$AC           TOKEN FOR ‘-' 
4560 9dbd 26 3c                        BNE  L89BF          TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY ‘-‘ 
4561 9dbf bd a4 b3                     JSR  GETNCH         GET A CHARACTER FROM BASIC 
4562 9dc2 27 04                        BEQ  L898C          IF END OF LINE, USE DEFAULT ENDING LINE NUMBER 
4563 9dc4 8d 24                        BSR  L89AE          * CONVERT ENDING LINE NUMBER TO BINARY 
4564 9dc6 20 04                        BRA  L8990          * AND SAVE IT IN BINVAL 
4565 9dc8 86 ff              L898C     LDA  #$FF           = USE $FFXX AS DEFAULT ENDING 
4566 9dca 97 2b                        STA  BINVAL         = LINE NUMBER - SAVE IT IN BINVAL 
4567 9dcc de 89              L8990     LDU  VD3            POINT U TO STARTING LINE NUMBER ADDRESS 
4568 9dce 8c                 L8992     FCB  SKP2           SKIP TWO BYTES 
4569 9dcf ee c4              L8993     LDU  ,U             POINT U TO START OF NEXT LINE 
4570 9dd1 ec c4                        LDD  ,U             CHECK FOR END OF PROGRAM 
4571 9dd3 27 06                        BEQ  L899F          BRANCH IF END OF PROGRAM 
4572 9dd5 ec 42                        LDD  $02,U          LOAD ACCD WITH THIS LINE’S NUMBER 
4573 9dd7 93 2b                        SUBD BINVAL         SUBTRACT ENDING LINE NUMBER ADDRESS 
4574 9dd9 23 f4                        BLS  L8993          BRANCH IF = < ENDING LINE NUMBER 
4575 9ddb 9e 89              L899F     LDX  VD3            GET STARTING LINE NUMBER 
4576 9ddd 8d 15                        BSR  L89B8          MOVE (U) TO (X) UNTIL END OF PROGRAM 
4577 9ddf bd 85 07                     JSR  LAD21          RESET BASIC’S INPUT POINTER AND ERASE VARIABLES 
4578 9de2 9e 89                        LDX  VD3            GET STARTING LINE NUMBER ADDRESS 
4579 9de4 bd 84 d7                     JSR  LACF1          RECOMPUTE START OF NEXT LINE ADDRESSES 
4580 9de7 7e 84 64                     JMP  LAC73          JUMP TO BASIC’S MAIN COMMAND LOOP 
4581 9dea bd 87 65           L89AE     JSR  LAF67          GO GET LINE NUMBER CONVERTED TO BINARY 
4582 9ded 7e 81 d2                     JMP  LA5C7          MAKE SURE THERE’S NO MORE ON THIS LINE 
4583 9df0 a6 c0              L89B4     LDA  ,U+            GET A BYTE FROM (U) 
4584 9df2 a7 80                        STA  ,X+            MOVE THE BYTE TO (X) 
4585 9df4 11 93 1b           L89B8     CMPU VARTAB         COMPARE TO END OF BASIC 
4586 9df7 26 f7                        BNE  L89B4          BRANCH IF NOT AT END 
4587 9df9 9f 1b                        STX  VARTAB         SAVE (X) AS NEW END OF BASIC 
4588 9dfb 39                 L89BF     RTS                  
4589                                                        
4590                                                        
4591 9dfc bd 9c df           L89C0     JSR  L8866          ‘BS’ ERROR IF IN DIRECT MODE 
4592 9dff bd a4 b3                     JSR  GETNCH         GET A CHAR FROM BASIC 
4593 9e02 81 22              L89D2     CMPA #'"'           CHECK FOR PROMPT STRING 
4594 9e04 26 0b                        BNE  L89E1          BRANCH IF NO PROMPT STRING 
4595 9e06 bd 8a 2b                     JSR  LB244          STRIP OFF PROMPT STRING & PUT IT ON STRING STACK 
4596 9e09 c6 3b                        LDB  #';'           * 
4597 9e0b bd 8a 56                     JSR  LB26F          * DO A SYNTAX CHECK FOR; 
4598 9e0e bd 91 62                     JSR  LB99F          REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT 
4599 9e11 32 7e              L89E1     LEAS $-02,S         RESERVE TWO STORAGE SLOTS ON STACK 
4600 9e13 bd 88 1b                     JSR  LB035          INPUT A LINE FROM CURRENT INPUT DEVICE 
4601 9e16 32 62                        LEAS $02,S          CLEAN UP THE STACK 
4602 9e18 bd 8b 3d                     JSR  LB357          SEARCH FOR A VARIABLE 
4603 9e1b 9f 3b                        STX  VARDES         SAVE POINTER TO VARIABLE DESCRIPTOR 
4604 9e1d bd 89 28                     JSR  LB146          ‘TM’ ERROR IF VARIABLE TYPE = NUMERIC 
4605 9e20 8e 01 31                     LDX  #LINBUF        POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED 
4606 9e23 4f                           CLRA                TERMINATOR CHARACTER 0 (END OF LINE) 
4607 9e24 bd 8d 09                     JSR  LB51A          PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE 
4608 9e27 7e 87 a3                     JMP  LAFA4          REMOVE DESCRIPTOR FROM STRING STACK 
4609 9e2a bd 87 65           L89FC     JSR  LAF67          STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE 
4610 9e2d 9e 2b                        LDX  BINVAL         GET BINARY VALUE 
4611 9e2f 39                           RTS                  
4612 9e30 9e 87              L8A02     LDX  VD1            GET CURRENT OLD NUMBER BEING RENUMBERED 
4613 9e32 9f 2b              L8A04     STX  BINVAL         SAVE THE LINE NUMBER BEING SEARCHED FOR 
4614 9e34 7e 84 e7                     JMP  LAD01          GO FIND THE LINE NUMBER IN BASIC PROGRAM 
4615                                                        
4616                         * RENUM                        
4617 9e37 bd 85 0c           RENUM     JSR  LAD26          ERASE VARIABLES 
4618 9e3a cc 00 0a                     LDD  #10            DEFAULT LINE NUMBER INTERVAL 
4619 9e3d dd 8b                        STD  VD5            SAVE DEFAULT RENUMBER START LINE NUMBER 
4620 9e3f dd 85                        STD  VCF            SAVE DEFAULT INTERVAL 
4621 9e41 5f                           CLRB                NOW ACCD = 0 
4622 9e42 dd 87                        STD  VD1            DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING 
4623 9e44 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
4624 9e47 24 07                        BCC  L8A20          BRANCH IF NOT NUMERIC 
4625 9e49 8d df                        BSR  L89FC          CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY 
4626 9e4b 9f 8b                        STX  VD5            SAVE LINE NUMBER WHERE RENUMBERING STARTS 
4627 9e4d bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
4628 9e50 27 1c              L8A20     BEQ  L8A3D          BRANCH IF END OF LINE 
4629 9e52 bd 8a 54                     JSR  LB26D          SYNTAX CHECK FOR COMMA 
4630 9e55 24 07                        BCC  L8A2D          BRANCH IF NEXT CHARACTER NOT NUMERIC 
4631 9e57 8d d1                        BSR  L89FC          CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY 
4632 9e59 9f 87                        STX  VD1            SAVE NEW RENUMBER LINE 
4633 9e5b bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
4634 9e5e 27 0e              L8A2D     BEQ  L8A3D          BRANCH IF END OF LINE 
4635 9e60 bd 8a 54                     JSR  LB26D          SYNTAX CHECK FOR COMMA 
4636 9e63 24 06                        BCC  L8A3A          BRANCH IF NEXT CHARACTER NOT NUMERIC 
4637 9e65 8d c3                        BSR  L89FC          CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY 
4638 9e67 9f 85                        STX  VCF            SAVE NEW INTERVAL 
4639 9e69 27 49                        BEQ  L8A83          ‘FC' ERROR 
4640 9e6b bd 81 d2           L8A3A     JSR  LA5C7          CHECK FOR MORE CHARACTERS ON LINE - ‘SYNTAX’ ERROR IF ANY 
4641 9e6e 8d c0              L8A3D     BSR  L8A02          GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED 
4642 9e70 9f 89                        STX  VD3            SAVE ADDRESS 
4643 9e72 9e 8b                        LDX  VD5            GET NEXT RENUMBERED LINE NUMBER TO USE 
4644 9e74 8d bc                        BSR  L8A04          FIND THE LINE NUMBER IN THE BASIC PROGRAM 
4645 9e76 9c 89                        CMPX VD3            COMPARE TO ADDRESS OF OLD LINE NUMBER 
4646 9e78 25 3a                        BLO  L8A83          ‘FC’ ERROR IF NEW ADDRESS < OLD ADDRESS 
4647 9e7a 8d 1c                        BSR  L8A67          MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE 
4648 9e7c bd 9f 0e                     JSR  L8ADD          CONVERT ASCII LINE NUMBERS TO ‘EXPANDED’ BINARY 
4649 9e7f bd 84 d5                     JSR  LACEF          RECALCULATE NEXT LINE RAM ADDRESSES 
4650 9e82 8d ac                        BSR  L8A02          GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED 
4651 9e84 9f 89                        STX  VD3            SAVE IT 
4652 9e86 8d 3a                        BSR  L8A91          MAKE SURE LINE NUMBERS EXIST 
4653 9e88 8d 0f                        BSR  L8A68          INSERT NEW LINE NUMBERS IN LINE HEADERS 
4654 9e8a 8d 36                        BSR  L8A91          INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS 
4655 9e8c bd 9f b0                     JSR  L8B7B          CONVERT PACKED BINARY LINE NUMBERS TO ASCII 
4656 9e8f bd 85 0c                     JSR  LAD26          ERASE VARIABLES 
4657 9e92 bd 84 d5                     JSR  LACEF          RECALCULATE NEXT LINE RAM ADDRESS 
4658 9e95 7e 84 64                     JMP  LAC73          GO BACK TO BASIC’S MAIN LOOP 
4659 9e98 86                 L8A67     FCB  SKP1LD         SKIP ONE BYTE - LDA #$4F 
4660 9e99 4f                 L8A68     CLRA                NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS 
4661 9e9a 97 8e                        STA  VD8            SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS 
4662 9e9c 9e 89                        LDX  VD3            GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED 
4663 9e9e dc 8b                        LDD  VD5            GET THE CURRENT RENUMBERED LINE NUMBER 
4664 9ea0 8d 15                        BSR  L8A86          RETURN IF END OF PROGRAM 
4665 9ea2 0d 8e              L8A71     TST  VD8            CHECK NEW LINE NUMBER FLAG 
4666 9ea4 26 02                        BNE  L8A77          BRANCH IF NOT INSERTING NEW LINE NUMBERS 
4667 9ea6 ed 02                        STD  $02,X          STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM 
4668 9ea8 ae 84              L8A77     LDX  ,X             POINT X TO THE NEXT LINE IN BASIC 
4669 9eaa 8d 0b                        BSR  L8A86          RETURN IF END OF PROGRAM 
4670 9eac d3 85                        ADDD VCF            ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER 
4671 9eae 25 04                        BLO  L8A83          ‘FC’ ERROR IF LINE NUMBER > $FFFF 
4672 9eb0 81 fa                        CMPA #MAXLIN        LARGEST LINE NUMBER = $F9FF 
4673 9eb2 25 ee                        BLO  L8A71          BRANCH IF LEGAL LINE NUMBER 
4674 9eb4 7e 8c 37           L8A83     JMP  LB44A          ‘FC’ ERROR IF LINE NUMBER MS BYTE > $F9 
4675                         * TEST THE TWO BYTES POINTED TO BY (X).                      
4676                         * NORMAL RETURN IF <> 0. IF = 0 (END OF                      
4677                         * PROGRAM) RETURN IS PULLED OFF STACK AND                      
4678                         * YOU RETURN TO PREVIOUS SUBROUTINE CALL.                      
4679 9eb7 34 06              L8A86     PSHS B,A            SAVE ACCD 
4680 9eb9 ec 84                        LDD  ,X             TEST THE 2 BYTES POINTED TO BY X 
4681 9ebb 35 06                        PULS A,B            RESTORE ACCD 
4682 9ebd 26 02                        BNE  L8A90          BRANCH IF NOT END OF PROGRAM 
4683 9ebf 32 62                        LEAS $02,S          PURGE RETURN ADDRESS FROM STACK 
4684 9ec1 39                 L8A90     RTS                  
4685 9ec2 9e 19              L8A91     LDX  TXTTAB         GET START OF BASIC PROGRAM 
4686 9ec4 30 1f                        LEAX $-01,X         MOVE POINTER BACK ONE 
4687 9ec6 30 01              L8A95     LEAX $01,X          MOVE POINTER UP ONE 
4688 9ec8 8d ed                        BSR  L8A86          RETURN IF END OF PROGRAM 
4689 9eca 30 03              L8A99     LEAX $03,X          SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER 
4690 9ecc 30 01              L8A9B     LEAX $01,X          MOVE POINTER TO NEXT CHARACTER 
4691 9ece a6 84                        LDA  ,X             CHECK CURRENT CHARACTER 
4692 9ed0 27 f4                        BEQ  L8A95          BRANCH IF END OF LINE 
4693 9ed2 9f 0f                        STX  TEMPTR         SAVE CURRENT POINTER 
4694 9ed4 4a                           DECA                = 
4695 9ed5 27 0c                        BEQ  L8AB2          =BRANCH IF START OF PACKED NUMERIC LINE 
4696 9ed7 4a                           DECA                * 
4697 9ed8 27 2a                        BEQ  L8AD3          *BRANCH IF LINE NUMBER EXISTS 
4698 9eda 4a                           DECA                = 
4699 9edb 26 ef                        BNE  L8A9B          =MOVE TO NEXT CHARACTER IF > 3 
4700 9edd 86 03              L8AAC     LDA  #$03           * SET 1ST BYTE = 3 TO INDICATE LINE 
4701 9edf a7 80                        STA  ,X+            * NUMBER DOESN’T CURRENTLY EXIST 
4702 9ee1 20 e7                        BRA  L8A99          GO GET ANOTHER CHARACTER 
4703 9ee3 ec 01              L8AB2     LDD  $01,X          GET MS BYTE OF LINE NUMBER 
4704 9ee5 6a 02                        DEC  $02,X          DECREMENT ZERO CHECK BYTE 
4705 9ee7 27 01                        BEQ  L8AB9          BRANCH IF MS BYTE <> 0 
4706 9ee9 4f                           CLRA                CLEAR MS BYTE 
4707 9eea e6 03              L8AB9     LDB  $03,X          GET LS BYTE OF LINE NUMBER 
4708 9eec 6a 04                        DEC  $04,X          DECREMENT ZERO CHECK FLAG 
4709 9eee 27 01                        BEQ  L8AC0          BRANCH IF IS BYTE <> 0 
4710 9ef0 5f                           CLRB                CLEAR LS BYTE 
4711 9ef1 ed 01              L8AC0     STD  $01,X          SAVE BINARY LINE NUMBER 
4712 9ef3 dd 2b                        STD  BINVAL         SAVE TRIAL LINE NUMBER 
4713 9ef5 bd 84 e7                     JSR  LAD01          FIND RAM ADDRESS OF A BASIC LINE NUMBER 
4714 9ef8 9e 0f              L8AC7     LDX  TEMPTR         GET BACK POINTER TO START OF PACKED LINE NUMBER 
4715 9efa 25 e1                        BLO  L8AAC          BRANCH IF NO LINE NUMBER MATCH FOUND 
4716 9efc dc 47                        LDD  V47            GET START ADDRESS OF LINE NUMBER 
4717 9efe 6c 80                        INC  ,X+            * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR 
4718                         *              * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS  
4719                                                        
4720 9f00 ed 84                        STD  ,X             SAVE RAM ADDRESS OF CORRECT LINE NUMBER 
4721 9f02 20 c6                        BRA  L8A99          GO GET ANOTHER CHARACTER 
4722 9f04 6f 84              L8AD3     CLR  ,X             CLEAR CARRY FLAG AND 1ST BYTE 
4723 9f06 ae 01                        LDX  $01,X          POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER 
4724 9f08 ae 02                        LDX  $02,X          PUT CORRECT LINE NUMBER INTO (X) 
4725 9f0a 9f 47                        STX  V47            SAVE IT TEMPORARILY 
4726 9f0c 20 ea                        BRA  L8AC7          GO INSERT IT INTO BASIC LINE 
4727 9f0e 9e 19              L8ADD     LDX  TXTTAB         GET BEGINNING OF BASIC PROGRAM 
4728 9f10 20 04                        BRA  L8AE5           
4729 9f12 9e 7c              L8AE1     LDX  CHARAD         *GET CURRENT INPUT POINTER 
4730 9f14 30 01                        LEAX $01,X          *AND BUMP IT ONE 
4731 9f16 8d 9f              L8AE5     BSR  L8A86          RETURN IF END OF PROGRAM 
4732 9f18 30 02                        LEAX $02,X          SKIP PAST NEXT LINE ADDRESS 
4733 9f1a 30 01              L8AE9     LEAX $01,X          ADVANCE POINTER BY ONE 
4734 9f1c 9f 7c              L8AEB     STX  CHARAD         SAVE NEW BASIC INPUT POINTER 
4735 9f1e bd a4 b3           L8AED     JSR  GETNCH         GET NEXT CHARACTER FROM BASIC 
4736 9f21 4d                 L8AEF     TSTA                CHECK THE CHARACTER 
4737 9f22 27 ee                        BEQ  L8AE1          BRANCH IF END OF LINE 
4738 9f24 2a f8                        BPL  L8AED          BRANCH IF NOT A TOKEN 
4739 9f26 9e 7c                        LDX  CHARAD         GET CURRENT INPUT POINTER 
4740 9f28 81 ff                        CMPA #$FF           IS THIS A SECONDARY TOKEN? 
4741 9f2a 27 ee                        BEQ  L8AE9          YES - IGNORE IT 
4742 9f2c 9d fe                        JSR  RVEC22         HOOK INTO RAM AND CHECK FOR USER ADDED TOKENS 
4743 9f2e 81 a7                        CMPA #$A7           TOKEN FOR THEN? 
4744 9f30 27 13                        BEQ  L8B13          YES 
4745 9f32 81 84                        CMPA #$84           TOKEN FOR ELSE? 
4746 9f34 27 0f                        BEQ  L8B13          YES 
4747 9f36 81 81                        CMPA #$81           TOKEN FOR GO? 
4748 9f38 26 e4                        BNE  L8AED          NO 
4749 9f3a bd a4 b3                     JSR  GETNCH         GET A CHARACTER FROM BASIC 
4750 9f3d 81 a5                        CMPA #$A5           TOKEN FOR TO? 
4751 9f3f 27 04                        BEQ  L8B13          YES 
4752 9f41 81 a6                        CMPA #$A6           TOKEN FOR SUB? 
4753 9f43 26 d7                        BNE  L8AEB          NO 
4754 9f45 bd a4 b3           L8B13     JSR  GETNCH         GET A CHARACTER FROM BASIC 
4755 9f48 25 05                        BLO  L8B1B          BRANCH IF NUMERIC 
4756 9f4a bd a4 b9           L8B17     JSR  GETCCH         GET CURRENT BASIC INPUT CHARRACTER 
4757 9f4d 20 d2                        BRA  L8AEF          KEEP CHECKING THE LINE 
4758 9f4f 9e 7c              L8B1B     LDX  CHARAD         GET CURRENT INPUT ADDRESS 
4759 9f51 34 10                        PSHS X              SAVE IT ON THE STACK 
4760 9f53 bd 87 65                     JSR  LAF67          CONVERT DECIMAL BASIC NUMBER TO BINARY 
4761 9f56 9e 7c                        LDX  CHARAD         GET CURRENT INPUT POINTER 
4762 9f58 a6 82              L8B24     LDA  ,-X            GET PREVIOUS INPUT CHARACTER 
4763 9f5a bd a2 c5                     JSR  L90AA          CLEAR CARRY IF NUMERIC INPUT VALUE 
4764 9f5d 25 f9                        BLO  L8B24          BRANCH IF NON-NUMERIC 
4765 9f5f 30 01                        LEAX $01,X          MOVE POINTER UP ONE 
4766 9f61 1f 10                        TFR  X,D            NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER 
4767 9f63 e0 61                        SUBB $01,S          SUBTRACT PRE-NUMERIC POINTER LS BYTE 
4768 9f65 c0 05                        SUBB #$05           MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE 
4769                         *                              
4770 9f67 27 20                        BEQ  L8B55          BRANCH IF EXACTLY 5 
4771 9f69 25 0a                        BLO  L8B41          BRANCH IF < 5 
4772 9f6b 33 84                        LEAU ,X             TRANSFER X TO U 
4773 9f6d 50                           NEGB                NEGATE B 
4774 9f6e 30 85                        LEAX B,X            MOVE X BACK B BYTES 
4775 9f70 bd 9d f4                     JSR  L89B8          *MOVE BYTES FROM (U) TO (X) UNTIL 
4776                         *         *U   = END OF BASIC; (I) = NEW END OF BASIC  
4777 9f73 20 14                        BRA  L8B55           
4778                         * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER                      
4779 9f75 9f 47              L8B41     STX  V47            SAVE END OF NUMERIC VALUE 
4780 9f77 9e 1b                        LDX  VARTAB         GET END OF BASIC PROGRAM 
4781 9f79 9f 43                        STX  V43            SAVE IT 
4782 9f7b 50                           NEGB                NEGATE B 
4783 9f7c 30 85                        LEAX B,X            ADD IT TO END OF NUMERIC POiNTER 
4784 9f7e 9f 41                        STX  V41            SAVE POINTER 
4785 9f80 9f 1b                        STX  VARTAB         STORE END OF BASIC PROGRAM 
4786 9f82 bd 84 19                     JSR  LAC1E          ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM 
4787 9f85 9e 45                        LDX  V45            * GET AND SAVE THE 
4788 9f87 9f 7c                        STX  CHARAD         * NEW CURRENT INPUT POINTER 
4789 9f89 35 10              L8B55     PULS X              RESTORE POINTER TO START OF NUMERIC VALUE 
4790 9f8b 86 01                        LDA  #$01           NEW LINE NUMBER FLAG 
4791 9f8d a7 84                        STA  ,X             * SAVE NEW LINE FLAG 
4792 9f8f a7 02                        STA  $02,X          * 
4793 9f91 a7 04                        STA  $04,X          * 
4794 9f93 d6 2b                        LDB  BINVAL         GET MS BYTE OF BINARY LINE NUMBER 
4795 9f95 26 04                        BNE  L8B67          BRANCH IF IT IS NOT ZERO 
4796 9f97 c6 01                        LDB  #$01           SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL 
4797                         *              THINK IT IS THE END OF A LINE  
4798 9f99 6c 02                        INC  $02,X          IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO 
4799 9f9b e7 01              L8B67     STB  $01,X          SAVE MS BYTE OF BINARY LINE NUMBER 
4800 9f9d d6 2c                        LDB  BINVAL+1       GET IS BYTE OF BINARY LINE NUMBER 
4801 9f9f 26 04                        BNE  L8B71          BRANCH IF NOT A ZERO BYTE 
4802 9fa1 c6 01                        LDB  #$01           SAVE A 1 IF BYTE IS A 0 
4803 9fa3 6c 04                        INC  $04,X          IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0 
4804 9fa5 e7 03              L8B71     STB  $03,X          SAVE LS BYTE OF BINARY LINE NUMBER 
4805 9fa7 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
4806 9faa 81 2c                        CMPA #','           IS IT A COMMA? 
4807 9fac 27 97                        BEQ  L8B13          YES - PROCESS ANOTHER NUMERIC VALUE 
4808 9fae 20 9a                        BRA  L8B17          NO - GO GET AND PROCESS AN INPUT CHARACTER 
4809 9fb0 9e 19              L8B7B     LDX  TXTTAB         POINT X TO START OF BASIC PROGRAM 
4810 9fb2 30 1f                        LEAX $-01,X         MOVE POINTER BACK ONE 
4811 9fb4 30 01              L8B7F     LEAX $01,X          MOVE POINTER UP ONE 
4812 9fb6 ec 02                        LDD  $02,X          GET ADDRESS OF NEXT LINE 
4813 9fb8 dd 68                        STD  CURLIN         SAVE IT IN CURLIN 
4814 9fba bd 9e b7                     JSR  L8A86          RETURN IF END OF PROGRAM 
4815 9fbd 30 03                        LEAX $03,X          SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER 
4816 9fbf 30 01              L8B8A     LEAX $01,X          MOVE POINTER UP ONE 
4817 9fc1 a6 84              L8B8C     LDA  ,X             GET CURRENT CHARACTER 
4818 9fc3 27 ef                        BEQ  L8B7F          BRANCH IF END OF LINE 
4819 9fc5 4a                           DECA                INPUT CHARACTER = 1? - VALID LINE NUMBER 
4820 9fc6 27 1b                        BEQ  L8BAE          YES 
4821 9fc8 80 02                        SUBA #$02           INPUT CHARACTER 3? - UL LINE NUMBER 
4822 9fca 26 f3                        BNE  L8B8A          NO 
4823 9fcc 34 10                        PSHS X              SAVE CURRENT POSITION OF INPUT POINTER 
4824 9fce 8e a0 0d                     LDX  #L8BD9-1       POINT X TO ‘UL’ MESSAGE 
4825 9fd1 bd 91 5f                     JSR  LB99C          PRINT STRING TO THE SCREEN 
4826 9fd4 ae e4                        LDX  ,S             GET INPUT POINTER 
4827 9fd6 ec 01                        LDD  $01,X          GET THE UNDEFINED LINE NUMBER 
4828 9fd8 bd 95 94                     JSR  LBDCC          CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT 
4829 9fdb bd 95 8d                     JSR  LBDC5          PRINT ‘IN XXXX’ XXXX = CURRENT LINE NUMBER 
4830 9fde bd 91 1e                     JSR  LB958          SEND A CR TO CONSOLE OUT 
4831 9fe1 35 10                        PULS X              GET INPUT POINTER BACK 
4832 9fe3 34 10              L8BAE     PSHS X              SAVE CURRENT POSITION OF INPUT POINTER 
4833 9fe5 ec 01                        LDD  $01,X          LOAD ACCD WITH BINARY VALUE OF LINE NUMBER 
4834 9fe7 dd 52                        STD  FPA0+2         SAVE IN BOTTOM 2 BYTES OF FPA0 
4835 9fe9 bd 9c 84                     JSR  L880E          ADJUST REST OF FPA0 AS AN INTEGER 
4836 9fec bd 95 a1                     JSR  LBDD9          CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER 
4837 9fef 35 40                        PULS U              LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER 
4838 9ff1 c6 05                        LDB  #$05           EACH EXPANDED LINE NUMBER USES 5 BYTES 
4839 9ff3 30 01              L8BBE     LEAX $01,X          MOVE POINTER FORWARD ONE 
4840 9ff5 a6 84                        LDA  ,X             GET AN ASCII BYTE 
4841 9ff7 27 05                        BEQ  L8BC9          BRANCH IF END OF NUMBER 
4842 9ff9 5a                           DECB                DECREMENT BYTE COUNTER 
4843 9ffa a7 c0                        STA  ,U+            STORE ASCII NUMBER IN BASIC LINE 
4844 9ffc 20 f5                        BRA  L8BBE          CHECK FOR ANOTHER DIGIT 
4845 9ffe 30 c4              L8BC9     LEAX ,U             TRANSFER NEW LINE POINTER TO (X) 
4846 a000 5d                           TSTB DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?  
4847 a001 27 be                        BEQ  L8B8C          YES - GO GET ANOTHER INPUT CHARACTER 
4848 a003 31 c4                        LEAY ,U             SAVE NEW LINE POINTER IN Y 
4849 a005 33 c5                        LEAU B,U            POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK 
4850 a007 bd 9d f4                     JSR  L89B8          MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM 
4851 a00a 30 a4                        LEAX ,Y             LOAD (X) WITH NEW LINE POINTER 
4852 a00c 20 b3                        BRA  L8B8C          GO GET ANOTHER INPUT CHARACTER 
4853                                                        
4854 a00e 55 4c 20           L8BD9     FCC  "UL "          UNKNOWN LINE NUMBER MESSAGE 
4855 a011 00                           FCB  0               
4856                                                        
4857                                                        
4858 a012 bd 8f 31           HEXDOL    JSR  LB740          CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER 
4859 a015 8e 02 2e                     LDX  #STRBUF+2      POINT TO TEMPORARY BUFFER 
4860 a018 c6 04                        LDB  #$04           CONVERT 4 NIBBLES 
4861 a01a 34 04              L8BE5     PSHS B              SAVE NIBBLE COUNTER 
4862 a01c 5f                           CLRB                CLEAR CARRY FLAG 
4863 a01d 86 04                        LDA  #$04           4 SHIFTS 
4864 a01f 08 53              L8BEA     ASL  FPA0+3         * SHIFT BOTTOM TWO BYTES OF 
4865 a021 09 52                        ROL  FPA0+2         * FPA0 LEFT ONE BIT (X2) 
4866 a023 59                           ROLB                IF OVERFLOW, ACCB <> 0 
4867 a024 4a                           DECA                * DECREMENT SHIFT COUNTER AND 
4868 a025 26 f8                        BNE  L8BEA          * BRANCH IF NOT DONE 
4869 a027 5d                           TSTB CHECK FOR OVERFLOW  
4870 a028 26 0a                        BNE  L8BFF          BRANCH IF OVERFLOW 
4871 a02a a6 e4                        LDA  ,S             * GET NIBBLE COUNTER, 
4872 a02c 4a                           DECA                * DECREMENT IT AND 
4873 a02d 27 05                        BEQ  L8BFF          * BRANCH IF DONE 
4874 a02f 8c 02 2e                     CMPX #STRBUF+2      DO NOT DO A CONVERSION UNTIL A NON-ZERO 
4875 a032 27 0c                        BEQ  L8C0B          BYTE IS FOUND - LEADING ZERO SUPPRESSION 
4876 a034 cb 30              L8BFF     ADDB #'0'           ADD IN ASCII ZERO 
4877 a036 c1 39                        CMPB #'9'           COMPARE TO ASCII 9 
4878 a038 23 02                        BLS  L8C07          BRANCH IF < 9 
4879 a03a cb 07                        ADDB #7             ADD ASCII OFFSET IF HEX LETTER 
4880 a03c e7 80              L8C07     STB  ,X+            STORE HEX VALUE AND ADVANCE POINTER 
4881 a03e 6f 84                        CLR  ,X             CLEAR NEXT BYTE - END OF STRING FLAG 
4882 a040 35 04              L8C0B     PULS B              * GET NIBBLE COUNTER, 
4883 a042 5a                           DECB                * DECREMENT IT AND 
4884 a043 26 d5                        BNE  L8BE5          * BRANCH IF NOT DONE 
4885 a045 32 62                        LEAS $02,S          PURGE RETURN ADDRESS OFF OF STACK 
4886 a047 8e 02 2d                     LDX  #STRBUF+1      RESET POINTER 
4887 a04a 7e 8d 05                     JMP  LB518          SAVE STRING ON STRING STACK 
4888                         * PROCESS EXCLAMATION POINT                      
4889 a04d 86 01              L8E37     LDA  #$01           * SET SPACES 
4890 a04f 97 8f                        STA  VD9            * COUNTER = 1 
4891                         * PROCESS STRING ITEM - LIST                      
4892 a051 5a                 L8E3B     DECB                DECREMENT FORMAT STRING LENGTH COUNTER 
4893 a052 bd a1 f3                     JSR  L8FD8          SEND A '+' TO CONSOLE OUT IF VDA <>0 
4894 a055 bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
4895 a058 10 27 00 94                  LBEQ L8ED8          EXIT PRINT USING IF END OF LINE 
4896 a05c d7 89                        STB  VD3            SAVE REMAINDER FORMAT STRING LENGTH 
4897 a05e bd 89 38                     JSR  LB156          EVALUATE EXPRESSION 
4898 a061 bd 89 28                     JSR  LB146          ‘TM’ ERROR IF NUMERIC VARIABLE 
4899 a064 9e 52                        LDX  FPA0+2         * GET ITEM - LIST DESCRIPTOR ADDRESS 
4900 a066 9f 4d                        STX  V4D            * AND SAVE IT IN V4D 
4901 a068 d6 8f                        LDB  VD9            GET SPACES COUNTER 
4902 a06a bd 8e 9a                     JSR  LB6AD          PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK 
4903 a06d bd 91 62                     JSR  LB99F          PRINT THE FORMATTED STRING TO CONSOLE OUT 
4904                         * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH                      
4905 a070 9e 52                        LDX  FPA0+2         POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS 
4906 a072 d6 8f                        LDB  VD9            GET SPACES COUNTER 
4907 a074 e0 84                        SUBB ,X             SUBTRACT LENGTH OF FORMATTED STRING 
4908 a076 5a                 L8E5F     DECB                DECREMENT DIFFERENCE 
4909 a077 10 2b 01 51                  LBMI L8FB3          GO INTERPRET ANOTHER ITEM - LIST 
4910 a07b bd 91 6f                     JSR  LB9AC          PAD FORMAT STRING WITH A SPACE 
4911 a07e 20 f6                        BRA  L8E5F          KEEP PADDING 
4912                         * PERCENT SIGN - PROCESS A %SPACES% COMMAND                      
4913 a080 d7 89              L8E69     STB  VD3            * SAVE THE CURRENT FORMAT STRING 
4914 a082 9f 0f                        STX  TEMPTR         * COUNTER AND POINTER 
4915 a084 86 02                        LDA  #$02           INITIAL SPACES COUNTER = 2 
4916 a086 97 8f                        STA  VD9            SAVE IN SPACES COUNTER 
4917 a088 a6 84              L8E71     LDA  ,X             GET A CHARACTER FROM FORMAT STRING 
4918 a08a 81 25                        CMPA #'%'           COMPARE TO TERMINATOR CHARACTER 
4919 a08c 27 c3                        BEQ  L8E3B          BRANCH IF END OF SPACES COMMAND 
4920 a08e 81 20                        CMPA #' '           BLANK 
4921 a090 26 07                        BNE  L8E82          BRANCH IF ILLEGAL CHARACTER 
4922 a092 0c 8f                        INC  VD9            ADD ONE TO SPACES COUNTER 
4923 a094 30 01                        LEAX $01,X          MOVE FORMAT POINTER UP ONE 
4924 a096 5a                           DECB                DECREMENT LENGTH COUNTER 
4925 a097 26 ef                        BNE  L8E71          BRANCH IF NOT END OF FORMAT STRING 
4926 a099 9e 0f              L8E82     LDX  TEMPTR         * RESTORE CURRENT FORMAT STRING COUNTER 
4927 a09b d6 89                        LDB  VD3            * AND POINTER TO POSITION BEFORE SPACES COMMAND 
4928 a09d 86 25                        LDA  #'%'           SEND A ‘%’ TO CONSOLE OUT AS A DEBUGGING AID 
4929                                                        
4930 a09f bd a1 f3           L8E88     JSR  L8FD8          SEND A ‘+' TO CONSOLE OUT IF VDA <> 0 
4931 a0a2 bd 81 13                     JSR  PUTCHR         SEND CHARACTER TO CONSOLE OUT 
4932 a0a5 20 29                        BRA  L8EB9          GET NEXT CHARACTER IN FORMAT STRING 
4933                                                        
4934                                                        
4935 a0a7 81 b6              XVEC9     CMPA #$B6           USING TOKEN 
4936 a0a9 27 01                        BEQ  L8E95          BRANCH IF PRINT USING 
4937 a0ab 39                           RTS                   
4938                                                        
4939                                                        
4940                                                        
4941                                                        
4942                                                        
4943 a0ac 32 62              L8E95     LEAS $02,S          PURGE RETURN ADDRESS OFF THE STACK 
4944 a0ae bd 89 3a                     JSR  LB158          EVALUATE FORMAT STRING 
4945 a0b1 bd 89 28                     JSR  LB146          ‘TM’ ERROR IF VARIABLE TYPE = NUMERIC 
4946 a0b4 c6 3b                        LDB  #';'           CHECK FOR ITEM LIST SEPARATOR 
4947 a0b6 bd 8a 56                     JSR  LB26F          SYNTAX CHECK FOR ; 
4948 a0b9 9e 52                        LDX  FPA0+2         * GET FORMAT STRING DESCRIPTOR ADDRESS 
4949 a0bb 9f 8b                        STX  VD5            * AND SAVE IT IN VD5 
4950 a0bd 20 06                        BRA  L8EAE          GO PROCESS FORMAT STRING 
4951 a0bf 96 8d              L8EA8     LDA  VD7            *CHECK NEXT PRINT ITEM FLAG AND 
4952 a0c1 27 08                        BEQ  L8EB4          *‘FC’ ERROR IF NO FURTHER PRINT ITEMS 
4953 a0c3 9e 8b                        LDX  VD5            RESET FORMAT STRING POINTER TO START OF STRING 
4954 a0c5 0f 8d              L8EAE     CLR  VD7            RESET NEXT PRINT ITEM FLAG 
4955 a0c7 e6 84                        LDB  ,X             GET LENGTH OF FORMAT STRING 
4956 a0c9 26 03                        BNE  L8EB7          INTERPRET FORMAT STRING IF LENGTH > 0 
4957 a0cb 7e 8c 37           L8EB4     JMP  LB44A          ‘FC’ ERROR IF FORMAT STRING = NULL 
4958 a0ce ae 02              L8EB7     LDX  $02,X          POINT X TO START OF FORMAT STRING 
4959                         * INTERPRET THE FORMAT STRING                      
4960 a0d0 0f 90              L8EB9     CLR  VDA            CLEAR THE STATUS BYTE 
4961 a0d2 0f 8f              L8EBB     CLR  VD9            CLEAR LEFT DIGIT COUNTER 
4962 a0d4 a6 80                        LDA  ,X+            GET A CHARACTER FROM FORMAT STRING 
4963 a0d6 81 21                        CMPA #'!'           EXCLAMATION POINT? 
4964 a0d8 10 27 ff 71                  LBEQ L8E37          YES - STRING TYPE FORMAT 
4965 a0dc 81 23                        CMPA #'#'           NUMBER SIGN? (DIGIT LOCATOR) 
4966 a0de 27 5c                        BEQ  L8F24          YES - NUMERIC TYPE FORMAT 
4967 a0e0 5a                           DECB                DECREMENT FORMAT STRING LENGTH 
4968 a0e1 26 17                        BNE  L8EE2          BRANCH IF NOT DONE 
4969 a0e3 bd a1 f3                     JSR  L8FD8          SEND A ‘+‘ TO CONSOLE OUT IF VDA <> 0 
4970 a0e6 bd 81 13                     JSR  PUTCHR         SEND CHARACTER TO CONSOLE OUT 
4971 a0e9 bd a4 b9           L8ED2     JSR  GETCCH         GET CURRENT CHARACTER FROM BASIC 
4972 a0ec 26 d1                        BNE  L8EA8          BRANCH IF NOT END OF LINE 
4973 a0ee 96 8d                        LDA  VD7            GET NEXT PRINT ITEM FLAG 
4974 a0f0 26 03              L8ED8     BNE  L8EDD          BRANCH IF MORE PRINT ITEMS 
4975 a0f2 bd 91 1e                     JSR  LB958          SEND A CARRIAGE RETURN TO CONSOLE OUT 
4976 a0f5 9e 8b              L8EDD     LDX  VD5            POINT X TO FORMAT STRING DESCRIPTOR 
4977 a0f7 7e 8e 46                     JMP  LB659          RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING 
4978 a0fa 81 2b              L8EE2     CMPA #'+'           CHECK FOR ‘+‘ (PRE-SIGN FORCE) 
4979 a0fc 26 09                        BNE  L8EEF          NO PLUS 
4980 a0fe bd a1 f3                     JSR  L8FD8          SEND A ‘+' TO CONSOLE OUT IF VDA <> 0 
4981 a101 86 08                        LDA  #$08           * LOAD THE STATUS BYTE WITH 8; 
4982 a103 97 90                        STA  VDA            * PRE-SIGN FORCE FLAG 
4983 a105 20 cb                        BRA  L8EBB          INTERPRET THE REST OF THE FORMAT STRING 
4984 a107 81 2e              L8EEF     CMPA #'.'           DECIMAL POINT? 
4985 a109 27 4e                        BEQ  L8F41          YES 
4986 a10b 81 25                        CMPA #'%'           PERCENT SIGN? 
4987 a10d 10 27 ff 6f                  LBEQ L8E69          YES 
4988 a111 a1 84                        CMPA ,X             COMPARE THE PRESENT FORMAT STRING INPUT 
4989                         *              CHARACTER TO THE NEXT ONE IN THE STRING  
4990 a113 26 8a              L8EFB     BNE  L8E88          NO MATCH - ILLEGAL CHARACTER 
4991                         * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING                      
4992 a115 81 24                        CMPA #'$'           DOLLAR SIGN? 
4993 a117 27 19                        BEQ  L8F1A          YES - MAKE THE DOLLAR SIGN FLOAT 
4994 a119 81 2a                        CMPA #'*'           ASTERISK? 
4995 a11b 26 f6                        BNE  L8EFB          NO - ILLEGAL CHARACTER 
4996 a11d 96 90                        LDA  VDA            * GRAB THE STATUS BYTE AND BET BIT 5 
4997 a11f 8a 20                        ORA  #$20           * TO INDICATE THAT THE OUTPUT WILL 
4998 a121 97 90                        STA  VDA            * BE LEFT PADDED WITH ASTERISKS 
4999 a123 c1 02                        CMPB #2             * CHECK TO SEE IF THE $$ ARE THE LAST TWO 
5000 a125 25 11                        BLO  L8F20          * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO 
5001 a127 a6 01                        LDA  $01,X          GET THE NEXT CHARACTER AFTER ** 
5002 a129 81 24                        CMPA #'$'           CHECK FOR **$ 
5003 a12b 26 0b                        BNE  L8F20          CHECK FOR MORE CHARACTERS 
5004 a12d 5a                           DECB                DECREMENT STRING LENGTH COUNTER 
5005 a12e 30 01                        LEAX $01,X          MOVE FORMAT STRING POINTER UP ONE 
5006 a130 0c 8f                        INC  VD9            ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND 
5007                         *              FLOATING DOLLAR SIGN COMBINATION  
5008 a132 96 90              L8F1A     LDA  VDA            * GET THE STATUS BYTE AND SET 
5009 a134 8a 10                        ORA  #$10           * BIT 4 TO INDICATE A 
5010 a136 97 90                        STA  VDA            * FLOATING DOLLAR SIGN 
5011 a138 30 01              L8F20     LEAX $01,X          MOVE FORMAT STRING POINTER UP ONE 
5012 a13a 0c 8f                        INC  VD9            ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD) 
5013                         * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING                      
5014 a13c 0f 8e              L8F24     CLR  VD8            CLEAR THE RIGHT DIGIT COUNTER 
5015 a13e 0c 8f              L8F26     INC  VD9            ADD ONE TO LEFT DIGIT COUNTER 
5016 a140 5a                           DECB                DECREMENT FORMAT STRING LENGTH COUNTER 
5017 a141 27 49                        BEQ  L8F74          BRANCH IF END OF FORMAT STRING 
5018 a143 a6 80                        LDA  ,X+            GET THE NEXT FORMAT CHARACTER 
5019 a145 81 2e                        CMPA #'.'           DECIMAL POINT? 
5020 a147 27 1e                        BEQ  L8F4F          YES 
5021 a149 81 23                        CMPA #'#'           NUMBER SIGN? 
5022 a14b 27 f1                        BEQ  L8F26          YES 
5023 a14d 81 2c                        CMPA #','           COMMA? 
5024 a14f 26 21                        BNE  L8F5A          NO 
5025 a151 96 90                        LDA  VDA            * GET THE STATUS BYTE 
5026 a153 8a 40                        ORA  #$40           * AND SET BIT 6 WHICH IS THE 
5027 a155 97 90                        STA  VDA            * COMMA SEPARATOR FLAG 
5028 a157 20 e5                        BRA  L8F26          PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT 
5029                         * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT                      
5030 a159 a6 84              L8F41     LDA  ,X             GET NEXT FORMAT CHARACTER 
5031 a15b 81 23                        CMPA #'#'           IS IT A NUMBER SIGN? 
5032 a15d 10 26 ff 3e                  LBNE L8E88          NO 
5033 a161 86 01                        LDA  #1             * SET THE RIGHT DIGIT COUNTER TO 1 - 
5034 a163 97 8e                        STA  VD8            * ALLOW ONE SPOT FOR DECIMAL POINT 
5035 a165 30 01                        LEAX $01,X          MOVE FORMAT POINTER UP ONE 
5036                         * PROCESS DIGITS TO RIGHT OF DECIMAL POINT                      
5037 a167 0c 8e              L8F4F     INC  VD8            ADD ONE TO RIGHT DIGIT COUNTER 
5038 a169 5a                           DECB                DECREMENT FORMAT LENGTH COUNTER 
5039 a16a 27 20                        BEQ  L8F74          BRANCH IF END OF FORMAT STRING 
5040 a16c a6 80                        LDA  ,X+            GET A CHARACTER FROM FORMAT STRING 
5041 a16e 81 23                        CMPA #'#'           IS IT NUMBER SIGN? 
5042 a170 27 f5                        BEQ  L8F4F          YES - KEEP CHECKING 
5043                         * CHECK FOR EXPONENTIAL FORCE                      
5044 a172 81 5e              L8F5A     CMPA #$5E           CHECK FOR UP ARROW 
5045 a174 26 16                        BNE  L8F74          NO UP ARROW 
5046 a176 a1 84                        CMPA ,X             IS THE NEXT CHARACTER AN UP ARROW? 
5047 a178 26 12                        BNE  L8F74          NO 
5048 a17a a1 01                        CMPA $01,X          AND THE NEXT CHARACTER? 
5049 a17c 26 0e                        BNE  L8F74          NO 
5050 a17e a1 02                        CMPA $02,X          HOW ABOUT THE 4TH CHARACTER? 
5051 a180 26 0a                        BNE  L8F74          NO, ALSO 
5052 a182 c1 04                        CMPB #4             * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE 
5053 a184 25 06                        BLO  L8F74          * FORMAT STRING AND BRANCH IF NOT 
5054 a186 c0 04                        SUBB #4             * MOVE POINTER UP 4 AND SUBTRACT 
5055 a188 30 04                        LEAX $04,X          * FOUR FROM LENGTH 
5056 a18a 0c 90                        INC  VDA INCREMENT STATUS BYTE - EXPONENTIAL FORM  
5057                                                        
5058                         * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING                      
5059 a18c 30 1f              L8F74     LEAX $-01,X         MOVE POINTER BACK ONE 
5060 a18e 0c 8f                        INC  VD9            ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE 
5061 a190 96 90                        LDA  VDA            * PRE-SIGN 
5062 a192 85 08                        BITA #$08           * FORCE AND 
5063 a194 26 18                        BNE  L8F96          * BRANCH IF SET 
5064 a196 0a 8f                        DEC  VD9            DECREMENT LEFT DIGIT — NO PRE-SIGN FORCE 
5065 a198 5d                           TSTB * CHECK LENGTH COUNTER AND BRANCH  
5066 a199 27 13                        BEQ  L8F96          * IF END OF FORMAT STRING 
5067 a19b a6 84                        LDA  ,X             GET NEXT FORMAT STRING CHARACTER 
5068 a19d 80 2d                        SUBA #'-'           CHECK FOR MINUS SIGN 
5069 a19f 27 06                        BEQ  L8F8F          BRANCH IF MINUS SIGN 
5070 a1a1 81 fe                        CMPA #$FE           * WAS CMPA #('+')-('-') 
5071 a1a3 26 09                        BNE  L8F96          BRANCH IF NO PLUS SIGN 
5072 a1a5 86 08                        LDA  #$08           GET THE PRE-SIGN FORCE FLAG 
5073 a1a7 8a 04              L8F8F     ORA  #$04           ‘OR’ IN POST-SIGN FORCE FLAG 
5074 a1a9 9a 90                        ORA  VDA            ‘OR’ IN THE STATUS BYTE 
5075 a1ab 97 90                        STA  VDA            SAVE THE STATUS BYTE 
5076 a1ad 5a                           DECB                DECREMENT FORMAT STRING LENGTH 
5077                                                        
5078                         * EVALUATE NUMERIC ITEM-LIST                      
5079 a1ae bd a4 b9           L8F96     JSR  GETCCH         GET CURRENT CHARACTER 
5080 a1b1 10 27 ff 3b                  LBEQ L8ED8          BRANCH IF END OF LINE 
5081 a1b5 d7 89                        STB  VD3            SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED 
5082 a1b7 bd 89 23                     JSR  LB141          EVALUATE EXPRESSION 
5083 a1ba 96 8f                        LDA  VD9            GET THE LEFT DIGIT COUNTER 
5084 a1bc 9b 8e                        ADDA VD8            ADD IT TO THE RIGHT DIGIT COUNTER 
5085 a1be 81 11                        CMPA #17            * 
5086 a1c0 10 22 ea 73                  LBHI LB44A          *‘FC’ ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT 
5087 a1c4 bd a2 00                     JSR  L8FE5          CONVERT ITEM-LIST TO FORMATTED ASCII STRING 
5088 a1c7 30 1f                        LEAX $-01,X         MOVE BUFFER POINTER BACK ONE 
5089 a1c9 bd 91 5f                     JSR  LB99C          DISPLAY THE FORMATTED STRING TO CONSOLE OUT 
5090 a1cc 0f 8d              L8FB3     CLR  VD7            RESET NEXT PRINT ITEM FLAG 
5091 a1ce bd a4 b9                     JSR  GETCCH         GET CURRENT INPUT CHARACTER 
5092 a1d1 27 0e                        BEQ  L8FC6          BRANCH IF END OF LINE 
5093 a1d3 97 8d                        STA  VD7            SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG 
5094 a1d5 81 3b                        CMPA #';'           * CHECK FOR ; - ITEM-LIST SEPARATOR AND 
5095 a1d7 27 05                        BEQ  L8FC4          * BRANCH IF SEMICOLON 
5096 a1d9 bd 8a 54                     JSR  LB26D          SYNTAX CHECK FOR COMMA 
5097 a1dc 20 03                        BRA  L8FC6          PROCESS NEXT PRINT ITEM 
5098 a1de bd a4 b3           L8FC4     JSR  GETNCH         GET NEXT INPUT CHARACTER 
5099 a1e1 9e 8b              L8FC6     LDX  VD5            GET FORMAT STRING DESCRIPTOR ADDRESS 
5100 a1e3 e6 84                        LDB  ,X             GET LENGTH OF FORMAT STRING 
5101 a1e5 d0 89                        SUBB VD3            SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM 
5102 a1e7 ae 02                        LDX  $02,X          *GET FORMAT STRING START ADDRESS AND ADVANCE 
5103 a1e9 3a                           ABX  *POINTER TO START OF UNUSED FORMAT STRING  
5104 a1ea d6 89                        LDB  VD3            * GET AMOUNT OF UNUSED FORMAT STRING 
5105 a1ec 10 26 fe e0                  LBNE L8EB9          * REINTERPRET FORMAT STRING FROM THAT POINT 
5106 a1f0 7e a0 e9                     JMP  L8ED2          REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY 
5107                         *         USED ON LAST PRINT ITEM  
5108                                                        
5109                         * PRINT A ‘+‘ TO CONSOLE OUT IF THE STATUS BYTE <> 0                      
5110 a1f3 34 02              L8FD8     PSHS A              RESTORE ACCA AND RETURN 
5111 a1f5 86 2b                        LDA  #'+'           GET ASCII PLUS SIGN 
5112 a1f7 0d 90                        TST  VDA            * CHECK THE STATUS BYTE AND 
5113 a1f9 27 03                        BEQ  L8FE3          * RETURN IF = 0 
5114 a1fb bd 81 13                     JSR  PUTCHR         SEND A CHARACTER TO CONSOLE OUT 
5115 a1fe 35 82              L8FE3     PULS A,PC           RETURN ACCA AND RETURN 
5116                                                        
5117                         * CONVERT ITEM-LIST TO DECIMAL ASCII STRING                      
5118 a200 ce 02 30           L8FE5     LDU  #STRBUF+4      POINT U TO STRING BUFFER 
5119 a203 c6 20                        LDB  #SPACE         BLANK 
5120 a205 96 90                        LDA  VDA            * GET THE STATUS FLAG AND 
5121 a207 85 08                        BITA #$08           * CHECK FOR A PRE-SIGN FORCE 
5122 a209 27 02                        BEQ  L8FF2          * BRANCH IF NO PRE-SIGN FORCE 
5123 a20b c6 2b                        LDB  #'+'           PLUS SIGN 
5124 a20d 0d 54              L8FF2     TST  FP0SGN         CHECK THE SIGN OF FPA0 
5125 a20f 2a 04                        BPL  L8FFA          BRANCH IF POSITIVE 
5126 a211 0f 54                        CLR  FP0SGN         FORCE FPA0 SIGN TO BE POSITIVE 
5127 a213 c6 2d                        LDB  #'-'           MINUS SIGN 
5128 a215 e7 c0              L8FFA     STB  ,U+            SAVE THE SIGN IN BUFFER 
5129 a217 c6 30                        LDB  #'0'           * PUT A ZERO INTO THE BUFFER 
5130 a219 e7 c0                        STB  ,U+            * 
5131 a21b 84 01                        ANDA #$01            
5132 a21d 10 26 01 07                  LBNE L910D           
5133 a221 8e 95 88                     LDX  #LBDC0         POINT X TO FLOATING POINT 1E + 09 
5134 a224 bd 94 63                     JSR  LBCA0          COMPARE FPA0 TO (X) 
5135 a227 2b 15                        BMI  L9023          BRANCH IF FPA0 < 1E+09 
5136 a229 bd 95 a1                     JSR  LBDD9          CONVERT FP NUMBER TO ASCII STRING 
5137 a22c a6 80              L9011     LDA  ,X+            * ADVANCE POINTER TO END OF 
5138 a22e 26 fc                        BNE  L9011          * ASCII STRING (ZERO BYTE) 
5139 a230 a6 82              L9015     LDA  ,-X            Error 2029 
5140 a232 a7 01                        STA  $01,X          Error 2029 
5141 a234 8c 02 2f                     CMPX #STRBUF+3      Error 2029 
5142 a237 26 f7                        BNE  L9015          Error 2029 
5143 a239 86 25                        LDA  #'%'           * INSERT A % SIGN AT START OF 
5144 a23b a7 84                        STA  ,X             * STRING - OVERFLOW ERROR 
5145 a23d 39                           RTS                  
5146                                                        
5147 a23e 96 4f              L9023     LDA  FP0EXP         Error 2029 
5148 a240 97 47                        STA  V47            Error 2029 
5149 a242 27 03                        BEQ  L902C          BRANCH IF FPA0 = 0 
5150 a244 bd a3 e8                     JSR  L91CD          CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT 
5151                         *              PLACES TO LEFT OF DECIMAL POINT  
5152 a247 96 47              L902C     LDA  V47            GET BASE 10 EXPONENT OFFSET 
5153 a249 10 2b 00 81                  LBMI L90B3          BRANCH IF FPA0 < 100,000,000 
5154 a24d 40                           NEGA                * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT - 
5155 a24e 9b 8f                        ADDA VD9            * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS 
5156 a250 80 09                        SUBA #$09           * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER 
5157 a252 bd a3 05                     JSR  L90EA          PUT ACCA ZEROES IN STRING BUFFER 
5158 a255 bd a4 7e                     JSR  L9263          INITIALIZE DECIMAL POINT AND COMMA COUNTERS 
5159 a258 bd a4 1d                     JSR  L9202          CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER 
5160 a25b 96 47                        LDA  V47            * GET BASE 10 EXPONENT AND PUT THAT MANY 
5161 a25d bd a4 9c                     JSR  L9281          * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT 
5162 a260 96 47                        LDA  V47            WASTED INSTRUCTION - SERVES NO PURPOSE 
5163 a262 bd a4 64                     JSR  L9249          CHECK FOR DECIMAL POINT 
5164 a265 96 8e                        LDA  VD8            GET THE RIGHT DIGIT COUNTER 
5165 a267 26 02                        BNE  L9050          BRANCH IF RIGHT DIGlT COUNTER <> 0 
5166 a269 33 5f                        LEAU $-01,U         * MOVE BUFFER POINTER BACK ONE - DELETE 
5167                         *              * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED  
5168 a26b 4a                 L9050     DECA                SUBTRACT ONE (DECIMAL POINT) 
5169 a26c bd a3 05                     JSR  L90EA          PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES) 
5170 a26f bd a3 a0           L9054     JSR  L9185          INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN 
5171 a272 4d                           TSTA                WAS THERE A POST-SIGN? 
5172 a273 27 06                        BEQ  L9060          NO 
5173 a275 c1 2a                        CMPB #'*'           IS THE FIRST CHARACTER AN $? 
5174 a277 27 02                        BEQ  L9060          YES 
5175 a279 e7 c0                        STB  ,U+            STORE THE POST-SIGN 
5176 a27b 6f c4              L9060     CLR  ,U             CLEAR THE LAST CHARACTER IN THE BUFFER 
5177                         *                              
5178                         * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE                      
5179                         * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT                      
5180 a27d 8e 02 2f                     LDX  #STRBUF+3 POINT X TO THE START OF THE BUFFER  
5181 a280 30 01              L9065     LEAX $01,X          MOVE BUFFER POINTER UP ONE 
5182 a282 9f 0f                        STX  TEMPTR         SAVE BUFFER POINTER IN TEMPTR 
5183 a284 96 3a                        LDA  VARPTR+1       * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT 
5184 a286 90 10                        SUBA TEMPTR+1       * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER - 
5185 a288 90 8f                        SUBA VD9            * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING 
5186                         *              * TO THE FIRST DIGIT OF THE FORMAT STRING  
5187 a28a 27 38                        BEQ  L90A9          RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT 
5188 a28c a6 84                        LDA  ,X             GET THE CURRENT BUFFER CHARACTER 
5189 a28e 81 20                        CMPA #SPACE         SPACE? 
5190 a290 27 ee                        BEQ  L9065          YES - ADVANCE POINTER 
5191 a292 81 2a                        CMPA #'*'           ASTERISK? 
5192 a294 27 ea                        BEQ  L9065          YES - ADVANCE POINTER 
5193 a296 4f                           CLRA                A ZERO ON THE STACK IS END OF DATA POINTER 
5194 a297 34 02              L907C     PSHS A              PUSH A CHARACTER ONTO THE STACK 
5195 a299 a6 80                        LDA  ,X+            GET NEXT CHARACTER FROM BUFFER 
5196 a29b 81 2d                        CMPA #'-'           MINUS SIGN? 
5197 a29d 27 f8                        BEQ  L907C          YES 
5198 a29f 81 2b                        CMPA #'+'           PLUS SIGN? 
5199 a2a1 27 f4                        BEQ  L907C          YES 
5200 a2a3 91 00                        CMPA $'$'           DOLLAR SIGN? 
5201 a2a5 27 f0                        BEQ  L907C          YES 
5202 a2a7 81 30                        CMPA #'0'           ZERO? 
5203 a2a9 26 0e                        BNE  L909E          NO - ERROR 
5204 a2ab a6 01                        LDA  $01,X          GET CHARACTER FOLLOWING ZERO 
5205 a2ad 8d 16                        BSR  L90AA          CLEAR CARRY IF NUMERIC 
5206 a2af 25 08                        BLO  L909E          BRANCH IF NOT A NUMERIC CHARACTER - ERROR 
5207 a2b1 35 02              L9096     PULS A              * PULL A CHARACTER OFF OF THE STACK 
5208 a2b3 a7 82                        STA  ,-X            * AND PUT IT BACK IN THE STRING BUFFER 
5209 a2b5 26 fa                        BNE  L9096          * KEEP GOING UNTIL ZERO FLAG 
5210 a2b7 20 c7                        BRA  L9065          KEEP CLEANING UP THE INPUT BUFFER 
5211 a2b9 35 02              L909E     PULS A               
5212 a2bb 4d                           TSTA                * THE STACK AND EXIT WHEN 
5213 a2bc 26 fb                        BNE  L909E          * ZERO FLAG FOUND 
5214 a2be 9e 0f                        LDX  TEMPTR         GET THE STRING BUFFER START POINTER 
5215 a2c0 86 25                        LDA  #'%'           * PUT A % SIGN BEFORE THE ERROR POSITION TO 
5216 a2c2 a7 82                        STA  ,-X            * INDICATE AN ERROR 
5217 a2c4 39                 L90A9     RTS                  
5218                         *                              
5219                         * CLEAR CARRY IF NUMERIC                      
5220 a2c5 81 30              L90AA     CMPA #'0'           ASCII ZERO 
5221 a2c7 25 04                        BLO  L90B2          RETURN IF ACCA < ASCII 0 
5222 a2c9 80 3a                        SUBA #$3A           *  #'9'+1 
5223 a2cb 80 c6                        SUBA #$C6           * #-('9'+1)  CARRY CLEAR IF NUMERIC 
5224 a2cd 39                 L90B2     RTS                  
5225                         *                              
5226                         * PROCESS AN ITEM-LIST WHICH IS < 100,000,000                      
5227 a2ce 96 8e              L90B3     LDA  VD8            GET RIGHT DIGIT COUNTER 
5228 a2d0 27 01                        BEQ  L90B8          BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT 
5229 a2d2 4a                           DECA                SUBTRACT ONE FOR DECIMAL POINT 
5230 a2d3 9b 47              L90B8     ADDA V47            *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE 
5231                         *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED  
5232                         *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT  
5233 a2d5 2b 01                        BMI  L90BD          IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED 
5234 a2d7 4f                           CLRA                FORCE SHIFT COUNTER = 0 
5235 a2d8 34 02              L90BD     PSHS A              SAVE INITIAL SHIFT COUNTER ON THE STACK 
5236 a2da 2a 0a              L90BF     BPL  L90CB          EXIT ROUTINE IF POSITIVE 
5237 a2dc 34 02                        PSHS A              SAVE SHIFT COUNTER ON STACK 
5238 a2de bd 93 45                     JSR  LBB82          DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT 
5239 a2e1 35 02                        PULS A              GET SHIFT COUNTER FROM THE STACK 
5240 a2e3 4c                           INCA                BUMP SHIFT COUNTER UP BY ONE 
5241 a2e4 20 f4                        BRA  L90BF          CHECK FOR FURTHER DIVISION 
5242 a2e6 96 47              L90CB     LDA  V47            * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER 
5243 a2e8 a0 e0                        SUBA ,S+            * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE 
5244 a2ea 97 47                        STA  V47            * FPA0 WAS SHIFTED ABOVE 
5245 a2ec 8b 09                        ADDA #$09           * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO 
5246 a2ee 2b 19                        BMI  L90EE          * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM 
5247 a2f0 96 8f                        LDA  VD9            *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL 
5248 a2f2 80 09                        SUBA #$09           *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL 
5249 a2f4 90 47                        SUBA V47            *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9 
5250 a2f6 8d 0d                        BSR  L90EA          *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER 
5251 a2f8 bd a4 7e                     JSR  L9263          INITIALIZE DECIMAL POINT AND COMMA COUNTERS 
5252 a2fb 20 1d                        BRA  L90FF          PROCESS THE REMAINDER OF THE PRINT ITEM 
5253                         *                              
5254                         * PUT (ACCA+1) ASCII ZEROES IN BUFFER                      
5255 a2fd 34 02              L90E2     PSHS A              SAVE ZERO COUNTER 
5256 a2ff 86 30                        LDA  #'0'           * INSERT A ZERO INTO 
5257 a301 a7 c0                        STA  ,U+            * THE BUFFER 
5258 a303 35 02                        PULS A              RESTORE ZERO COUNTER 
5259                                                        
5260                         * PUT ACCA ASCII ZEROES INTO THE BUFFER                      
5261 a305 4a                 L90EA     DECA                DECREMENT ZERO COUNTER 
5262 a306 2a f5                        BPL  L90E2          BRANCH IF NOT DONE 
5263 a308 39                           RTS                  
5264                                                        
5265 a309 96 8f              L90EE     LDA  VD9            * GET THE LEFT DIGIT COUNTER AND PUT 
5266 a30b 8d f8                        BSR  L90EA          * THAT MANY ZEROES IN THE STRiNG BUFFER 
5267 a30d bd a4 68                     JSR  L924D          PUT THE DECIMAL POINT IN THE STRING BUFFER 
5268 a310 86 f7                        LDA  #-9            *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT 
5269 a312 90 47                        SUBA V47            *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9 
5270 a314 8d ef                        BSR  L90EA          *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER 
5271 a316 0f 45                        CLR  V45            CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT 
5272 a318 0f 8d                        CLR  VD7            CLEAR THE COMMA COUNTER - SUPPRESS COMMAS 
5273 a31a bd a4 1d           L90FF     JSR  L9202          DECODE FPA0 INTO A DECIMAL ASCII STRING 
5274 a31d 96 8e                        LDA  VD8            GET THE RIGHT DIGIT COUNTER 
5275 a31f 26 02                        BNE  L9108          BRANCH IF RIGHT DIGIT COUNTER <> 0 
5276 a321 de 39                        LDU  VARPTR         RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT 
5277 a323 9b 47              L9108     ADDA V47            *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY 
5278                         * *FILLER ZEROES TO BE OUTPUT TO THE RIGHT OF LAST SIGNIFICANT DATA                      
5279                         *         *SIGNIFICANT DATA            
5280 a325 16 ff 43                     LBRA L9050          INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC 
5281                         *                              
5282                         * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT                      
5283 a328 96 4f              L910D     LDA  FP0EXP         * GET EXPONENT OF FPA0 AND 
5284 a32a 34 02                        PSHS A              * SAVE IT ON THE STACK 
5285 a32c 27 03                        BEQ  L9116          BRANCH IF FPA0 = 0 
5286 a32e bd a3 e8                     JSR  L91CD          *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT 
5287                         *         *DIGITS TO THE LEFT OF THE DECIMAL POINT  
5288 a331 96 8e              L9116     LDA  VD8            GET THE RIGHT DIGIT COUNTER 
5289 a333 27 01                        BEQ  L911B          BRANCH IF NO FORMATTED DIGITS TO THE RIGHT 
5290 a335 4a                           DECA                SUBTRACT ONE FOR THE DECIMAL POINT 
5291 a336 9b 8f              L911B     ADDA VD9            ADD TO THE LEFT DIGIT COUNTER 
5292 a338 7f 02 2f                     CLR  STRBUF+3       CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION 
5293 a33b d6 90                        LDB  VDA            * GET THE STATUS BYTE FOR A 
5294 a33d c4 04                        ANDB #$04           * POST-BYTE FORCE; BRANCH IF 
5295 a33f 26 03                        BNE  L9129          * A POST-BYTE FORCE 
5296 a341 73 02 2f                     COM  STRBUF+3       TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE 
5297 a344 bb 02 2f           L9129     ADDA STRBUF+3       SUBTRACT 1 IF NO POST BYTE FORCE 
5298 a347 80 09                        SUBA #$09           *SUBTRACT 9 (DUE TO THE CONVERSION TO 9 
5299                         *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)  
5300 a349 34 02                        PSHS A              * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER 
5301                         *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF  
5302                         *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.  
5303 a34b 2a 0a              L9130     BPL  L913C          NO MORE SHIFTS WHEN ACCA >= 0 
5304 a34d 34 02                        PSHS A              SAVE SHIFT COUNTER 
5305 a34f bd 93 45                     JSR  LBB82          DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE 
5306 a352 35 02                        PULS A              RESTORE THE SHIFT COUNTER 
5307 a354 4c                           INCA                ADD 1 TO SHIFT COUNTER 
5308 a355 20 f4                        BRA  L9130          CHECK FOR FURTHER SHIFTING (DIVISION) 
5309 a357 a6 e4              L913C     LDA  ,S             *GET THE INITIAL VALUE OF THE SHIFT COUNTER 
5310 a359 2b 01                        BMI  L9141          *AND BRANCH IF SHIFTING HAS TAKEN PLACE 
5311 a35b 4f                           CLRA                RESET ACCA IF NO SHIFTING HAS TAKEN PLACE 
5312 a35c 40                 L9141     NEGA                *CALCULATE THE POSITION OF THE DECIMAL POINT BY 
5313 a35d 9b 8f                        ADDA VD9            *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER 
5314 a35f 4c                           INCA                *PLUS ONE AND THE POST-BYTE POSlTION, IF USED 
5315 a360 bb 02 2f                     ADDA STRBUF+3       * 
5316 a363 97 45                        STA  V45            SAVE DECIMAL POINT COUNTER 
5317 a365 0f 8d                        CLR  VD7            CLEAR COMMA COUNTER - NO COMMAS INSERTED 
5318 a367 bd a4 1d                     JSR  L9202          CONVERT FPA0 INTO ASCII DECIMAL STRING 
5319 a36a 35 02                        PULS A              * GET THE INITIAL VALUE OF SHIFT COUNTER AND 
5320 a36c bd a4 9c                     JSR  L9281          * INSERT THAT MANY ZEROES INTO THE BUFFER 
5321 a36f 96 8e                        LDA  VD8            *GET THE RIGHT DIGIT COUNTER AND BRANCH 
5322 a371 26 02                        BNE  L915A          *IF NOT ZERO 
5323 a373 33 5f                        LEAU $-01,U         MOVE BUFFER POINTER BACK ONE 
5324                                                        
5325                         * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER                      
5326 a375 e6 e0              L915A     LDB  ,S+            GET ORIGINAL EXPONENT OF FPA0 
5327 a377 27 09                        BEQ  L9167          BRANCH IF EXPONENT = 0 
5328 a379 d6 47                        LDB  V47            GET BASE 10 EXPONENT 
5329 a37b cb 09                        ADDB #$09           ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION 
5330 a37d d0 8f                        SUBB VD9            SUBTRACT LEFT DIGIT COUNTER 
5331 a37f f0 02 2f                     SUBB STRBUF+3       ADD ONE TO EXPONENT IF POST-SIGN FORCE 
5332 a382 86 2b              L9167     LDA  #'+'           PLUS SIGN 
5333 a384 5d                           TSTB TEST EXPONENT   
5334 a385 2a 03                        BPL  L916F          BRANCH IF POSITIVE EXPONENT 
5335 a387 86 2d                        LDA  #'-'           MINUS SIGN 
5336 a389 50                           NEGB                CONVERT EXPONENT TO POSITIVE NUMBER 
5337 a38a a7 41              L916F     STA  $01,U          PUT SIGN OF EXPONENT IN STRING BUFFER 
5338 a38c 86 45                        LDA  #'E'           * PUT AN ‘E’ (EXPONENTIATION FLAG) IN 
5339 a38e a7 c1                        STA  ,U++           * BUFFER AND SKIP OVER THE SIGN 
5340 a390 86 2f                        LDA  #$2F           * WAS LDA #'0'-1 
5341                         *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA                      
5342 a392 4c                 L9177     INCA                ADD ONE TO TENS DIGIT COUNTER 
5343 a393 c0 0a                        SUBB #10            *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS 
5344 a395 24 fb                        BCC  L9177          * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY 
5345 a397 cb 3a                        ADDB #$3A           WAS ADDB #'9'+1 
5346 a399 ed c1                        STD  ,U++           SAVE EXPONENT IN BUFFER 
5347 a39b 6f c4                        CLR  ,U             CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR 
5348 a39d 7e a2 6f                     JMP  L9054          INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC. 
5349                                                        
5350                         * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN                      
5351 a3a0 8e 02 30           L9185     LDX  #STRBUF+4      POINT X TO START OF PRINT ITEM BUFFER 
5352 a3a3 e6 84                        LDB  ,X             * GET SIGN BYTE OF ITEM-LIST BUFFER 
5353 a3a5 34 04                        PSHS B              * AND SAVE IT ON THE STACK 
5354 a3a7 86 20                        LDA  #SPACE         DEFAULT PAD WITH BLANKS 
5355 a3a9 d6 90                        LDB  VDA            * GET STATUS BYTE AND CHECK FOR 
5356 a3ab c5 20                        BITB #$20           * ASTERISK LEFT PADDING 
5357 a3ad 35 04                        PULS B              GET SIGN BYTE AGAIN 
5358 a3af 27 08                        BEQ  L919E          BRANCH IF NO PADDING 
5359 a3b1 86 2a                        LDA  #'*'           PAD WITH ASTERISK 
5360 a3b3 c1 20                        CMPB #SPACE         WAS THE FIRST BYTE A BLANK (POSITIVE)? 
5361 a3b5 26 02                        BNE  L919E          NO 
5362 a3b7 1f 89                        TFR  A,B            TRANSFER PAD CHARACTER TO ACCB 
5363 a3b9 34 04              L919E     PSHS B              SAVE FIRST CHARACTER ON STACK 
5364 a3bb a7 80              L91A0     STA  ,X+            STORE PAD CHARACTER IN BUFFER 
5365 a3bd e6 84                        LDB  ,X             GET NEXT CHARACTER IN BUFFER 
5366 a3bf 27 10                        BEQ  L91B6          INSERT A ZERO IF END OF BUFFER 
5367 a3c1 c1 45                        CMPB #'E'           * CHECK FOR AN ‘E’ AND 
5368 a3c3 27 0c                        BEQ  L91B6          * PUT A ZERO BEFORE IT 
5369 a3c5 c1 30                        CMPB #'0'           * REPLACE LEADING ZEROES WITH 
5370 a3c7 27 f2                        BEQ  L91A0          * PAD CHARACTERS 
5371 a3c9 c1 2c                        CMPB #','           * REPLACE LEADING COMMAS 
5372 a3cb 27 ee                        BEQ  L91A0          * WITH PAD CHARACTERS 
5373 a3cd c1 2e                        CMPB #'.'           * CHECK FOR DECIMAL POINT 
5374 a3cf 26 04                        BNE  L91BA          * AND DON’T PUT A ZERO BEFORE IT 
5375 a3d1 86 30              L91B6     LDA  #'0'           * REPLACE PREVIOUS CHARACTER 
5376 a3d3 a7 82                        STA  ,-X            * WITH A ZERO 
5377 a3d5 96 90              L91BA     LDA  VDA            * GET STATUS BYTE, CHECK 
5378 a3d7 85 10                        BITA #$10           * FOR FLOATING $ 
5379 a3d9 27 04                        BEQ  L91C4          * BRANCH IF NO FLOATING $ 
5380 a3db c6 24                        LDB  #'$'           * STORE A $ IN 
5381 a3dd e7 82                        STB  ,-X            * BUFFER 
5382 a3df 84 04              L91C4     ANDA #$04           CHECK PRE-SIGN FLAG 
5383 a3e1 35 04                        PULS B              GET SIGN CHARACTER 
5384 a3e3 26 02                        BNE  L91CC          RETURN IF POST-SIGN REQUIRED 
5385 a3e5 e7 82                        STB  ,-X            STORE FIRST CHARACTER 
5386 a3e7 39                 L91CC     RTS                  
5387                         *                              
5388                         * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.                      
5389                         * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).                      
5390 a3e8 34 40              L91CD     PSHS U              SAVE BUFFER POINTER 
5391 a3ea 4f                           CLRA                INITIAL EXPONENT OFFSET = 0 
5392 a3eb 97 47              L91D0     STA  V47            SAVE EXPONENT OFFSET 
5393 a3ed d6 4f                        LDB  FP0EXP         GET EXPONENT OF FPA0 
5394 a3ef c1 80                        CMPB #$80           * COMPARE TO EXPONENT OF .5 
5395 a3f1 22 11                        BHI  L91E9          * AND BRANCH IF FPA0 > = 1.0 
5396                                                        
5397                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1                      
5398 a3f3 8e 95 88                     LDX  #LBDC0         POINT X TO FP NUMBER (1E+09) 
5399 a3f6 bd 92 8d                     JSR  LBACA          MULTIPLY FPA0 BY 1E+09 
5400 a3f9 96 47                        LDA  V47            GET EXPONENT OFFSET 
5401 a3fb 80 09                        SUBA #$09           SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE) 
5402 a3fd 20 ec                        BRA  L91D0          CHECK TO SEE IF > 1.0 
5403 a3ff bd 93 45           L91E4     JSR  LBB82          DIVIDE FPA0 BY 10 
5404 a402 0c 47                        INC  V47            INCREMENT EXPONENT OFFSET 
5405 a404 8e 95 83           L91E9     LDX  #LBDBB         POINT X TO FP NUMBER (999,999,999) 
5406 a407 bd 94 63                     JSR  LBCA0          COMPARE FPA0 TO X 
5407 a40a 2e f3                        BGT  L91E4          BRANCH IF FPA0 > 999,999,999 
5408 a40c 8e 95 7e           L91F1     LDX  #LBDB6         POINT X TO FP NUMBER (99,999,999.9) 
5409 a40f bd 94 63                     JSR  LBCA0          COMPARE FPA0 TO X 
5410 a412 2e 07                        BGT  L9200          RETURN IF 999,999,999 > FPA0 > 99,999,999.9 
5411 a414 bd 93 2d                     JSR  LBB6A          MULTIPLY FPA0 BY 10 
5412 a417 0a 47                        DEC  V47            DECREMENT EXPONENT OFFSET 
5413 a419 20 f1                        BRA  L91F1          KEEP UNNORMALIZING 
5414 a41b 35 c0              L9200     PULS U,PC           RESTORE BUFFER POINTER AND RETURN 
5415                         *                              
5416                         * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT                      
5417                         * INTO A DECIMAL ASCII STRING IN THE BUFFER                      
5418 a41d 34 40              L9202     PSHS U              SAVE BUFFER POINTER 
5419 a41f bd 91 77                     JSR  LB9B4          ADD .5 TO FPA0 (ROUND OFF) 
5420 a422 bd 94 8b                     JSR  LBCC8          CONVERT FPA0 TO INTEGER FORMAT 
5421 a425 35 40                        PULS U              RESTORE BUFFER POINTER 
5422                         *                              
5423                         * CONVERT FPA0 INTO A DECIMAL ASCII STRING                      
5424 a427 8e 96 8d                     LDX  #LBEC5         POINT X TO UNNORMALIZED POWERS OF 10 
5425 a42a c6 80                        LDB  #$80           INITIALIZE DIGIT COUNTER TO 0 + $80. 
5426                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA                      
5427                         * IS NEGATIVE. WHEN YOU ‘ADD’ A NEGATIVE MANTISSA, IT IS                      
5428                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB                      
5429                         * IS HOW THIS ROUTINE KNOWS THAT A ‘SUBTRACTION’ IS OCCURRING.                      
5430 a42c 8d 36              L9211     BSR  L9249          CHECK FOR COMMA INSERTION 
5431 a42e 96 53              L9213     LDA  FPA0+3         * ‘ADD’ A POWER OF 10 MANTISSA TO FPA0. 
5432 a430 ab 03                        ADDA $03,X          * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION 
5433 a432 97 53                        STA  FPA0+3         * WILL BE WHAT REALLY TAKES PLACE. 
5434 a434 96 52                        LDA  FPA0+2         * 
5435 a436 a9 02                        ADCA $02,X          * 
5436 a438 97 52                        STA  FPA0+2         * 
5437 a43a 96 51                        LDA  FPA0+1         * 
5438 a43c a9 01                        ADCA $01,X          * 
5439 a43e 97 51                        STA  FPA0+1         * 
5440 a440 96 50                        LDA  FPA0           * 
5441 a442 a9 84                        ADCA ,X             * 
5442 a444 97 50                        STA  FPA0           * 
5443 a446 5c                           INCB                ADD ONE TO DIGIT COUNTER 
5444 a447 56                           RORB ROTATE CARRY INTO BIT 7  
5445 a448 59                           ROLB                * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND 
5446 a449 28 e3                        BVC  L9213          * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA 
5447 a44b 24 03                        BCC  L9235          BRANCH IF SUBTRACTING MANTISSA 
5448 a44d c0 0b                        SUBB #10+1          WAS SUBB #10+1 
5449 a44f 50                           NEGB                * IF ADDING MANTISSA 
5450 a450 cb 2f              L9235     ADDB #$2F           WAS ADDB #'0'-1 
5451 a452 30 04                        LEAX $04,X          MOVE TO NEXT POWER OF 10 MANTISSA 
5452 a454 1f 98                        TFR  B,A            SAVE DIGIT IN ACCA 
5453 a456 84 7f                        ANDA #$7F           MASK OFF ADD/SUBTRACT FLAG (BIT 7) 
5454 a458 a7 c0                        STA  ,U+            STORE DIGIT IN BUFFER 
5455 a45a 53                           COMB                TOGGLE ADD/SUBTRACT FLAG 
5456 a45b c4 80                        ANDB #$80           MASK OFF EVERYTHING BUT ADD/SUB FLAG 
5457 a45d 8c 96 b1                     CMPX #LBEE9         COMPARE TO END OF UNNORMALIZED POWERS OF 10 
5458 a460 26 ca                        BNE  L9211          BRANCH IF NOT DONE 
5459 a462 6f c4                        CLR  ,U             PUT A ZERO AT END OF INTEGER 
5460                                                        
5461                         * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION                      
5462 a464 0a 45              L9249     DEC  V45            DECREMENT DECIMAL POINT COUNTER 
5463 a466 26 09                        BNE  L9256          NOT TIME FOR DECIMAL POINT 
5464 a468 df 39              L924D     STU  VARPTR         SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT 
5465 a46a 86 2e                        LDA  #'.'           * STORE A DECIMAL 
5466 a46c a7 c0                        STA  ,U+            * POINT IN THE OUTPUT BUFFER 
5467 a46e 0f 8d                        CLR  VD7            * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255 
5468                         *                             * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED 
5469 a470 39                           RTS                  
5470 a471 0a 8d              L9256     DEC  VD7            DECREMENT COMMA COUNTER 
5471 a473 26 08                        BNE  L9262          RETURN IF NOT TIME FOR COMMA 
5472 a475 86 03                        LDA  #$03           * RESET COMMA COUNTER TO 3; THREE 
5473 a477 97 8d                        STA  VD7            * DIGITS BETWEEN COMMAS 
5474 a479 86 2c                        LDA  #','           * PUT A COMMA INTO 
5475 a47b a7 c0                        STA  ,U+            * THE BUFFER 
5476 a47d 39                 L9262     RTS                  
5477                                                        
5478                         * INITIALIZE DECIMAL POINT AND COMMA COUNTERS                      
5479 a47e 96 47              L9263     LDA  V47            GET THE BASE 10 EXPONENT OFFSET 
5480 a480 8b 0a                        ADDA #10            * ADD 10 (FPA0 WAS ‘NORMALIZED’ TO 9 PLACES LEFT 
5481 a482 97 45                        STA  V45            * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER 
5482 a484 4c                           INCA                ADD ONE FOR THE DECIMAL POINT 
5483 a485 80 03              L926A     SUBA #$03           * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE 
5484 a487 24 fc                        BCC  L926A          * THE REMAINDER IN ACCA 
5485 a489 8b 05                        ADDA #$05           CONVERT REMAINDER INTO A NUMBER FROM 1-3 
5486 a48b 97 8d                        STA  VD7            SAVE COMMA COUNTER 
5487 a48d 96 90                        LDA  VDA            GET STATUS BYTE 
5488 a48f 84 40                        ANDA #$40           CHECK FOR COMMA FLAG 
5489 a491 26 02                        BNE  L927A          BRANCH IF COMMA FLAG ACTIVE 
5490 a493 97 8d                        STA  VD7            CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA 
5491 a495 39                 L927A     RTS                  
5492                         *                              
5493                         * INSERT ACCA ZEROES INTO THE BUFFER                      
5494 a496 34 02              L927B     PSHS A              SAVE ZEROES COUNTER 
5495 a498 8d ca                        BSR  L9249          CHECK FOR DECIMAL POINT 
5496 a49a 35 02                        PULS A              RESTORE ZEROES COUNTER 
5497 a49c 4a                 L9281     DECA                * DECREMENT ZEROES COUNTER AND 
5498 a49d 2b 0a                        BMI  L928E          * RETURN IF < 0 
5499 a49f 34 02                        PSHS A              SAVE ZEROES COUNTER 
5500 a4a1 86 30                        LDA  #'0'           * PUT A ZERO INTO 
5501 a4a3 a7 c0                        STA  ,U+            * THE BUFFER 
5502 a4a5 a6 e0                        LDA  ,S+            RESTORE THE ZEROES COUNTER 
5503 a4a7 26 ed                        BNE  L927B          BRANCH IF NOT DONE 
5504 a4a9 39                 L928E     RTS                  
5505                                                        
5506                                                        
5507                         * LINE                         
5508 a4aa 81 89              LINE      CMPA #$89            
5509 a4ac 10 27 f9 4c                  LBEQ L89C0           
5510 a4b0 7e 8a 5f                     JMP  LB277           
5511                                                        
5512                         
5513                         ;	----------------------------------------------------------------------------------------------------
5514                         ;	LFD: Code in ROM, CHARAD stay in RAM because receive a pointer
5515                         							   
5516 a4b3 0c 7d              GETNCH    INC  <CHARAD+1      *PV INCREMENT LS BYTE OF INPUT POINTER 
5517 a4b5 26 02                        BNE  GETCCH         *PV BRANCH IF NOT ZERO (NO CARRY) 
5518 a4b7 0c 7c                        INC  <CHARAD        *PV INCREMENT MS BYTE OF INPUT POINTER 
5519 a4b9 a6 9f 00 7c        GETCCH    lda	[CHARAD]           *PV OP CODE OF LDA EXTENDED 
5520                         
5521                         ;CHARAD    RMB  2              *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT 
5522                         ;         *    CHARACTER WHICH THE BASIC INTERPRETER IS  
5523                         ;         *    PROCESSING      
5524 a4bd 7e 81 db                     JMP  BROMHK         JUMP BACK INTO THE BASIC RUM 
5525                         ;	----------------------------------------------------------------------------------------------------
5526                         		  
5527                         * END OF EXTENDED BASIC                      
5528                                   		  
5529                                   ;ORG  $FFF0           
5530                         		  
5531                         ;LBFF0     FDB  $0000          RESERVED 
5532                         ;LBFF2     FDB  SW3VEC         SWI3 
5533                         ;LBFF4     FDB  SW2VEC         SWI2 
5534                         ;LBFF6     FDB  FRQVEC         FIRQ 
5535                         ;LBFF8     FDB  IRQVEC         IRQ 
5536                         ;LBFFA     FDB  SWIVEC         SWI 
5537                         ;LBFFC     FDB  NMIVEC         NMI 
5538                         ;LBFFE     FDB  RESVEC         RESET 
5539                                                        
